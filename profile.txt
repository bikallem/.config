Time	Sum	Command
1118	10118	> builtin source /usr/local/Cellar/fish/3.0.2/share/fish/config.fish
51	51	-> set -g IFS \n\ \t
20	20	-> set -qg __fish_added_user_paths
17	17	-> set -g __fish_added_user_paths
16	16	-> function __fish_default_command_not_found_handler
    printf "fish: Unknown command %s\n" (string escape -- $argv[1]) >&2
...
7	376	-> if status --is-interactive
    # The user has seemingly explicitly launched an old fish with too-new scripts installed.
    if not contains -- "string" (builtin -n)
        set -g __is_launched_without_string 1
        # XXX nostring - fix old fish binaries with no `string' builtin.
        # When executed on fish 2.2.0, the `else' block after this would
        # force on 24-bit mode due to changes to in test behavior.
        # These "XXX nostring" hacks were added for 2.3.1
        set_color --bold
        echo "You appear to be trying to launch an old fish binary with newer scripts "
        echo "installed into" (set_color --underline)"$__fish_data_dir"
        set_color normal
        echo -e "\nThis is an unsupported configuration.\n"
        set_color yellow
        echo "You may need to uninstall and reinstall fish!"
        set_color normal
        # Remove this code when we've made it safer to upgrade fish.
    else
        # Enable truecolor/24-bit support for select terminals
        # Ignore Screen and emacs' ansi-term as they swallow the sequences, rendering the text white.
        if not set -q STY
            and not string match -q -- 'eterm*' $TERM
            and begin
                set -q KONSOLE_PROFILE_NAME # KDE's konsole
                or string match -q -- "*:*" $ITERM_SESSION_ID # Supporting versions of iTerm2 will include a colon here
                or string match -q -- "st-*" $TERM # suckless' st
                or test -n "$VTE_VERSION" -a "$VTE_VERSION" -ge 3600 # Should be all gtk3-vte-based terms after version 3.6.0.0
                or test "$COLORTERM" = truecolor -o "$COLORTERM" = 24bit # slang expects this
            end
            # Only set it if it isn't to allow override by setting to 0
            set -q fish_term24bit
            or set -g fish_term24bit 1
        end
    end
else
    # Hook up the default as the principal command_not_found handler
    # in case we are not interactive
    function __fish_command_not_found_handler --on-event fish_command_not_found
        __fish_default_command_not_found_handler $argv
    end
...
18	18	--> status --is-interactive
5	351	--> if not contains -- "string" (builtin -n)
        set -g __is_launched_without_string 1
        # XXX nostring - fix old fish binaries with no `string' builtin.
        # When executed on fish 2.2.0, the `else' block after this would
        # force on 24-bit mode due to changes to in test behavior.
        # These "XXX nostring" hacks were added for 2.3.1
        set_color --bold
        echo "You appear to be trying to launch an old fish binary with newer scripts "
        echo "installed into" (set_color --underline)"$__fish_data_dir"
        set_color normal
        echo -e "\nThis is an unsupported configuration.\n"
        set_color yellow
        echo "You may need to uninstall and reinstall fish!"
        set_color normal
        # Remove this code when we've made it safer to upgrade fish.
    else
        # Enable truecolor/24-bit support for select terminals
        # Ignore Screen and emacs' ansi-term as they swallow the sequences, rendering the text white.
        if not set -q STY
            and not string match -q -- 'eterm*' $TERM
            and begin
                set -q KONSOLE_PROFILE_NAME # KDE's konsole
                or string match -q -- "*:*" $ITERM_SESSION_ID # Supporting versions of iTerm2 will include a colon here
                or string match -q -- "st-*" $TERM # suckless' st
                or test -n "$VTE_VERSION" -a "$VTE_VERSION" -ge 3600 # Should be all gtk3-vte-based terms after version 3.6.0.0
                or test "$COLORTERM" = truecolor -o "$COLORTERM" = 24bit # slang expects this
            end
            # Only set it if it isn't to allow override by setting to 0
            set -q fish_term24bit
            or set -g fish_term24bit 1
        end
    ...
148	195	---> not contains -- "string" (builtin -n)
47	47	----> builtin -n
9	151	---> if not set -q STY
            and not string match -q -- 'eterm*' $TERM
            and begin
                set -q KONSOLE_PROFILE_NAME # KDE's konsole
                or string match -q -- "*:*" $ITERM_SESSION_ID # Supporting versions of iTerm2 will include a colon here
                or string match -q -- "st-*" $TERM # suckless' st
                or test -n "$VTE_VERSION" -a "$VTE_VERSION" -ge 3600 # Should be all gtk3-vte-based terms after version 3.6.0.0
                or test "$COLORTERM" = truecolor -o "$COLORTERM" = 24bit # slang expects this
            end
            # Only set it if it isn't to allow override by setting to 0
            set -q fish_term24bit
            or set -g fish_term24bit 1
        ...
16	16	----> not set -q STY
39	39	----> not string match -q -- 'eterm*' $TERM
9	51	----> begin
                set -q KONSOLE_PROFILE_NAME # KDE's konsole
                or string match -q -- "*:*" $ITERM_SESSION_ID # Supporting versions of iTerm2 will include a colon here
                or string match -q -- "st-*" $TERM # suckless' st
                or test -n "$VTE_VERSION" -a "$VTE_VERSION" -ge 3600 # Should be all gtk3-vte-based terms after version 3.6.0.0
                or test "$COLORTERM" = truecolor -o "$COLORTERM" = 24bit # slang expects this
            ...
15	15	-----> set -q KONSOLE_PROFILE_NAME
27	27	-----> string match -q -- "*:*" $ITERM_SESSION_ID
15	15	----> set -q fish_term24bit
21	21	----> set -g fish_term24bit 1
29	29	-> set -g __fish_config_dir ~/.config/fish
6	44	-> if set -q XDG_CONFIG_HOME
    set __fish_config_dir $XDG_CONFIG_HOME/fish
...
15	15	--> set -q XDG_CONFIG_HOME
23	23	--> set __fish_config_dir $XDG_CONFIG_HOME/fish
22	22	-> set -l userdatadir ~/.local/share
1	15	-> if set -q XDG_DATA_HOME
    set userdatadir $XDG_DATA_HOME
...
14	14	--> set -q XDG_DATA_HOME
15	15	-> set -l __extra_completionsdir
15	15	-> set -l __extra_functionsdir
15	15	-> set -l __extra_confdir
7	229	-> if test -f $__fish_data_dir/__fish_build_paths.fish
    source $__fish_data_dir/__fish_build_paths.fish
...
55	55	--> test -f $__fish_data_dir/__fish_build_paths.fish
111	167	--> source $__fish_data_dir/__fish_build_paths.fish
22	22	---> set __extra_completionsdir /usr/local/share/fish/vendor_completions.d
18	18	---> set __extra_functionsdir /usr/local/share/fish/vendor_functions.d
16	16	---> set __extra_confdir /usr/local/share/fish/vendor_conf.d
7	58	-> if not set -q fish_function_path
    set fish_function_path $__fish_config_dir/functions $__fish_sysconf_dir/functions $__extra_functionsdir $__fish_data_dir/functions
...
15	15	--> not set -q fish_function_path
36	36	--> set fish_function_path $__fish_config_dir/functions $__fish_sysconf_dir/functions $__extra_functionsdir $__fish_data_dir/functions
3	88	-> if not contains -- $__fish_data_dir/functions $fish_function_path
    set fish_function_path $fish_function_path $__fish_data_dir/functions
...
85	85	--> not contains -- $__fish_data_dir/functions $fish_function_path
7	62	-> if not set -q fish_complete_path
    set fish_complete_path $__fish_config_dir/completions $__fish_sysconf_dir/completions $__extra_completionsdir $__fish_data_dir/completions $userdatadir/fish/generated_completions
...
15	15	--> not set -q fish_complete_path
40	40	--> set fish_complete_path $__fish_config_dir/completions $__fish_sysconf_dir/completions $__extra_completionsdir $__fish_data_dir/completions $userdatadir/fish/generated_completions
3	48	-> if not contains -- $__fish_data_dir/completions $fish_complete_path
    set fish_complete_path $fish_complete_path $__fish_data_dir/completions
...
45	45	--> not contains -- $__fish_data_dir/completions $fish_complete_path
6	6	-> function :
    # no-op function for compatibility with sh, bash, and others.
    # Often used to insert a comment into a chain of commands without having
	# it eat up the remainder of the line, handy in Makefiles.
...
2	20	-> if test -d /usr/xpg4/bin
    if not contains -- /usr/xpg4/bin $PATH
        set PATH /usr/xpg4/bin $PATH
    end
...
18	18	--> test -d /usr/xpg4/bin
16	16	-> function __fish_reconstruct_path -d "Update PATH when fish_user_paths changes" --on-variable fish_user_paths
    set -l local_path $PATH

    for x in $__fish_added_user_paths
        set -l idx (contains --index -- $x $local_path)
        and set -e local_path[$idx]
    end

    set -g __fish_added_user_paths
    if set -q fish_user_paths
        for x in $fish_user_paths[-1..1]
            if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -g __fish_added_user_paths $__fish_added_user_paths $x
            end
            set local_path $x $local_path
        end
    end

    set -xg PATH $local_path
...
30	30	-> function fish_sigtrap_handler --on-signal TRAP --no-scope-shadowing --description "Signal handler for the TRAP signal. Launches a debug prompt."
    breakpoint
...
9	9	-> function __fish_on_interactive --on-event fish_prompt
    __fish_config_interactive
    functions -e __fish_on_interactive
...
114	658	-> __fish_set_locale
362	371	--> source /usr/local/Cellar/fish/3.0.2/share/fish/functions/__fish_set_locale.fish
9	9	---> function __fish_set_locale
    set -l LOCALE_VARS
    set -a LOCALE_VARS LANG LANGUAGE LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE
    set -a LOCALE_VARS LC_MONETARY LC_MESSAGES LC_PAPER LC_NAME LC_ADDRESS
    set -a LOCALE_VARS LC_TELEPHONE LC_MEASUREMENT LC_IDENTIFICATION

    # We check LC_ALL to figure out if we have a locale but we don't set it later. That is because
    # locale.conf doesn't allow it so we should not set it.
    for locale_var in $LOCALE_VARS LC_ALL
        if set -q $locale_var
            return 0
        end
    end

    # Try to extract the locale from the kernel boot commandline. The splitting here is a bit weird,
    # but we operate under the assumption that the locale can't include whitespace. Other whitespace
    # shouldn't concern us, but a quoted "locale.LANG=SOMETHING" as a value to something else might.
    # Here the last definition of a variable takes precedence.
    if test -r /proc/cmdline
        for var in (string match -ra 'locale.[^=]+=\S+' < /proc/cmdline)
            set -l kv (string replace 'locale.' '' -- $var | string split '=')
            # Only set locale variables, not other stuff contained in these files - this also
            # automatically ignores comments.
            if contains -- $kv[1] $LOCALE_VARS
                and set -q kv[2]
                set -gx $kv[1] (string trim -c '\'"' -- $kv[2])
            end
        end
    end

    # Now read the config files we know are used by various OS distros.
    #
    # /etc/sysconfig/i18n is for old Red Hat derivatives (and possibly of no use anymore).
    #
    # /etc/env.d/02locale is from OpenRC.
    #
    # The rest are systemd inventions but also used elsewhere (e.g. Void Linux). systemd's
    # documentation is a bit unclear on this. We merge all the config files (and the commandline),
    # which seems to be what systemd itself does. (I.e. the value for a variable will be taken from
    # the highest-precedence source) We read the systemd files first since they are a newer
    # invention and therefore the rest are likely to be accumulated cruft.
    #
    # NOTE: Slackware puts the locale in /etc/profile.d/lang.sh, which we can't use because it's a
    # full POSIX-shell script.
    set -l user_cfg_dir (set -q XDG_CONFIG_HOME; and echo $XDG_CONFIG_HOME; or echo ~/.config)
    for f in $user_cfg_dir/locale.conf /etc/locale.conf /etc/env.d/02locale /etc/sysconfig/i18n
        if test -r $f
            while read -l kv
                set kv (string split '=' -- $kv)
                if contains -- $kv[1] $LOCALE_VARS
                    and set -q kv[2]
                    # Do not set already set variables again - this makes the merging happen.
                    if not set -q $kv[1]
                        set -gx $kv[1] (string trim -c '\'"' -- $kv[2])
                    end
                end
            end <$f
        end
    end

    # If we really cannot get anything, at least set character encoding to UTF-8.
    for locale_var in $LOCALE_VARS LC_ALL
        if set -q $locale_var
            return 0
        end
    end
    set -gx LC_CTYPE en_US.UTF-8
...
25	25	--> set -l LOCALE_VARS
27	27	--> set -a LOCALE_VARS LANG LANGUAGE LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE
25	25	--> set -a LOCALE_VARS LC_MONETARY LC_MESSAGES LC_PAPER LC_NAME LC_ADDRESS
26	26	--> set -a LOCALE_VARS LC_TELEPHONE LC_MEASUREMENT LC_IDENTIFICATION
31	70	--> for locale_var in $LOCALE_VARS LC_ALL
        if set -q $locale_var
            return 0
        end
    ...
7	39	---> if set -q $locale_var
            return 0
        ...
18	18	----> set -q $locale_var
14	14	----> return 0
12	12	-> function . --description 'Evaluate contents of file (deprecated, see "source")' --no-scope-shadowing
    if test (count $argv) -eq 0
        # Uses tty directly, as isatty depends on "."
        and tty 0>&0 >/dev/null
        echo "source: '.' command is deprecated, and doesn't work with STDIN anymore. Did you mean 'source' or './'?" >&2
        return 1
    else
        source $argv
    end
...
2	18	-> if not set -q __fish_init_2_3_0
    if set -q fish_user_abbreviations
        set -l fab
        for abbr in $fish_user_abbreviations
            set fab $fab (string replace -r '^([^ =]+)=(.*)$' '$1 $2' -- $abbr)
        end
        set fish_user_abbreviations $fab
    end
    set -U __fish_init_2_3_0
...
16	16	--> not set -q __fish_init_2_3_0
12	3276	-> if command -sq /usr/libexec/path_helper
    # Adapt construct_path from the macOS /usr/libexec/path_helper
    # executable for fish; see
    # https://opensource.apple.com/source/shell_cmds/shell_cmds-203/path_helper/path_helper.c.auto.html .
    function __fish_macos_set_env -d "set an environment variable like path_helper does (macOS only)"
        set -l result

        for path_file in $argv[2] $argv[3]/*
            if test -f $path_file
                while read -l entry
                    if not contains $entry $result
                        set result $result $entry
                    end
                end <$path_file
            end
        end

        for entry in $$argv[1]
            if not contains $entry $result
                set result $result $entry
            end
        end

        set -xg $argv[1] $result
    end

    __fish_macos_set_env 'PATH' '/etc/paths' '/etc/paths.d'
    if [ -n "$MANPATH" ]
        __fish_macos_set_env 'MANPATH' '/etc/manpaths' '/etc/manpaths.d'
    end
    functions -e __fish_macos_set_env
...
50	50	--> command -sq /usr/libexec/path_helper
12	12	--> function __fish_macos_set_env -d "set an environment variable like path_helper does (macOS only)"
        set -l result

        for path_file in $argv[2] $argv[3]/*
            if test -f $path_file
                while read -l entry
                    if not contains $entry $result
                        set result $result $entry
                    end
                end <$path_file
            end
        end

        for entry in $$argv[1]
            if not contains $entry $result
                set result $result $entry
            end
        end

        set -xg $argv[1] $result
    ...
33	3114	--> __fish_macos_set_env 'PATH' '/etc/paths' '/etc/paths.d'
18	18	---> set -l result
163	1143	---> for path_file in $argv[2] $argv[3]/*
            if test -f $path_file
                while read -l entry
                    if not contains $entry $result
                        set result $result $entry
                    end
                end <$path_file
            end
        ...
12	466	----> if test -f $path_file
                while read -l entry
                    if not contains $entry $result
                        set result $result $entry
                    end
                end <$path_file
            ...
35	35	-----> test -f $path_file
86	419	-----> while read -l entry
                    if not contains $entry $result
                        set result $result $entry
                    end
                end <$path_file
38	38	------> read -l entry
17	51	------> if not contains $entry $result
                        set result $result $entry
                    ...
19	19	-------> not contains $entry $result
15	15	-------> set result $result $entry
16	16	------> read -l entry
9	41	------> if not contains $entry $result
                        set result $result $entry
                    ...
14	14	-------> not contains $entry $result
18	18	-------> set result $result $entry
14	14	------> read -l entry
8	41	------> if not contains $entry $result
                        set result $result $entry
                    ...
16	16	-------> not contains $entry $result
17	17	-------> set result $result $entry
14	14	------> read -l entry
9	47	------> if not contains $entry $result
                        set result $result $entry
                    ...
17	17	-------> not contains $entry $result
21	21	-------> set result $result $entry
14	14	------> read -l entry
8	46	------> if not contains $entry $result
                        set result $result $entry
                    ...
18	18	-------> not contains $entry $result
20	20	-------> set result $result $entry
11	11	------> read -l entry
12	188	----> if test -f $path_file
                while read -l entry
                    if not contains $entry $result
                        set result $result $entry
                    end
                end <$path_file
            ...
34	34	-----> test -f $path_file
52	142	-----> while read -l entry
                    if not contains $entry $result
                        set result $result $entry
                    end
                end <$path_file
19	19	------> read -l entry
15	59	------> if not contains $entry $result
                        set result $result $entry
                    ...
21	21	-------> not contains $entry $result
23	23	-------> set result $result $entry
12	12	------> read -l entry
25	326	----> if test -f $path_file
                while read -l entry
                    if not contains $entry $result
                        set result $result $entry
                    end
                end <$path_file
            ...
32	32	-----> test -f $path_file
62	269	-----> while read -l entry
                    if not contains $entry $result
                        set result $result $entry
                    end
                end <$path_file
18	18	------> read -l entry
15	65	------> if not contains $entry $result
                        set result $result $entry
                    ...
22	22	-------> not contains $entry $result
28	28	-------> set result $result $entry
14	14	------> read -l entry
10	54	------> if not contains $entry $result
                        set result $result $entry
                    ...
20	20	-------> not contains $entry $result
24	24	-------> set result $result $entry
13	13	------> read -l entry
1	32	------> if not contains $entry $result
                        set result $result $entry
                    ...
31	31	-------> not contains $entry $result
11	11	------> read -l entry
120	1830	---> for entry in $$argv[1]
            if not contains $entry $result
                set result $result $entry
            end
        ...
13	97	----> if not contains $entry $result
                set result $result $entry
            ...
43	43	-----> not contains $entry $result
41	41	-----> set result $result $entry
9	86	----> if not contains $entry $result
                set result $result $entry
            ...
35	35	-----> not contains $entry $result
42	42	-----> set result $result $entry
10	82	----> if not contains $entry $result
                set result $result $entry
            ...
33	33	-----> not contains $entry $result
39	39	-----> set result $result $entry
12	87	----> if not contains $entry $result
                set result $result $entry
            ...
33	33	-----> not contains $entry $result
42	42	-----> set result $result $entry
9	84	----> if not contains $entry $result
                set result $result $entry
            ...
34	34	-----> not contains $entry $result
41	41	-----> set result $result $entry
12	87	----> if not contains $entry $result
                set result $result $entry
            ...
34	34	-----> not contains $entry $result
41	41	-----> set result $result $entry
10	88	----> if not contains $entry $result
                set result $result $entry
            ...
35	35	-----> not contains $entry $result
43	43	-----> set result $result $entry
10	94	----> if not contains $entry $result
                set result $result $entry
            ...
39	39	-----> not contains $entry $result
45	45	-----> set result $result $entry
9	93	----> if not contains $entry $result
                set result $result $entry
            ...
37	37	-----> not contains $entry $result
47	47	-----> set result $result $entry
9	100	----> if not contains $entry $result
                set result $result $entry
            ...
39	39	-----> not contains $entry $result
52	52	-----> set result $result $entry
11	99	----> if not contains $entry $result
                set result $result $entry
            ...
39	39	-----> not contains $entry $result
49	49	-----> set result $result $entry
11	104	----> if not contains $entry $result
                set result $result $entry
            ...
40	40	-----> not contains $entry $result
53	53	-----> set result $result $entry
11	108	----> if not contains $entry $result
                set result $result $entry
            ...
42	42	-----> not contains $entry $result
55	55	-----> set result $result $entry
2	45	----> if not contains $entry $result
                set result $result $entry
            ...
43	43	-----> not contains $entry $result
3	42	----> if not contains $entry $result
                set result $result $entry
            ...
39	39	-----> not contains $entry $result
3	41	----> if not contains $entry $result
                set result $result $entry
            ...
38	38	-----> not contains $entry $result
3	44	----> if not contains $entry $result
                set result $result $entry
            ...
41	41	-----> not contains $entry $result
3	41	----> if not contains $entry $result
                set result $result $entry
            ...
38	38	-----> not contains $entry $result
11	100	----> if not contains $entry $result
                set result $result $entry
            ...
38	38	-----> not contains $entry $result
51	51	-----> set result $result $entry
1	42	----> if not contains $entry $result
                set result $result $entry
            ...
41	41	-----> not contains $entry $result
1	44	----> if not contains $entry $result
                set result $result $entry
            ...
43	43	-----> not contains $entry $result
10	102	----> if not contains $entry $result
                set result $result $entry
            ...
40	40	-----> not contains $entry $result
52	52	-----> set result $result $entry
90	90	---> set -xg $argv[1] $result
1	22	--> if [ -n "$MANPATH" ]
        __fish_macos_set_env 'MANPATH' '/etc/manpaths' '/etc/manpaths.d'
    ...
21	21	---> [ -n "$MANPATH" ]
66	66	--> functions -e __fish_macos_set_env
2	17	-> if status --is-login
    #
    # Put linux consoles in unicode mode.
    #
    if test "$TERM" = linux
        if string match -qir '\.UTF' -- $LANG
            if command -sq unicode_start
                unicode_start
            end
        end
    end
...
15	15	--> status --is-login
25	188	-> __fish_reconstruct_path
50	50	--> set -l local_path $PATH
15	15	--> for x in $__fish_added_user_paths
        set -l idx (contains --index -- $x $local_path)
        and set -e local_path[$idx]
    ...
17	17	--> set -g __fish_added_user_paths
2	16	--> if set -q fish_user_paths
        for x in $fish_user_paths[-1..1]
            if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -g __fish_added_user_paths $__fish_added_user_paths $x
            end
            set local_path $x $local_path
        end
    ...
14	14	---> set -q fish_user_paths
65	65	--> set -xg PATH $local_path
6	6	-> function __fish_expand_pid_args
    for arg in $argv
        if string match -qr '^%\d+$' -- $arg
            # set newargv $newargv (jobs -p $arg)
            jobs -p $arg
            if not test $status -eq 0
                return 1
            end
        else
            printf "%s\n" $arg
        end
    end
...
4	4	-> function bg
    builtin bg (__fish_expand_pid_args $argv)
...
3	3	-> function fg
    builtin fg (__fish_expand_pid_args $argv)
...
3	3	-> function kill
    command kill (__fish_expand_pid_args $argv)
...
3	3	-> function wait
    builtin wait (__fish_expand_pid_args $argv)
...
4	4	-> function disown
    builtin disown (__fish_expand_pid_args $argv)
...
17	17	-> set -l sourcelist
355	3590	-> for file in $__fish_config_dir/conf.d/*.fish $__fish_sysconf_dir/conf.d/*.fish $__extra_confdir/*.fish
    set -l basename (string replace -r '^.*/' '' -- $file)
    contains -- $basename $sourcelist
    and continue
    set sourcelist $sourcelist $basename
    # Also skip non-files or unreadable files.
    # This allows one to use e.g. symlinks to /dev/null to "mask" something (like in systemd).
    [ -f $file -a -r $file ]
    and source $file
...
53	576	--> set -l basename (string replace -r '^.*/' '' -- $file)
198	523	---> string replace -r '^.*/' '' -- $file
158	325	----> source /usr/local/Cellar/fish/3.0.2/share/fish/functions/string.fish
1	167	-----> if not contains string (builtin -n)
    function string
        if not set -q __is_launched_without_string
            if status --is-interactive
                # We've been autoloaded after fish < 2.3.0 upgraded to >= 2.3.1 - no string builtin
                set_color --bold >&2
                echo "Fish has been upgraded, and the scripts on your system are not compatible" >&2
                echo "with this prior instance of fish. You can probably run:" >&2
                set_color green >&2
                echo -e "\n exec fish" >&2
                set_color normal >&2
                echo "… to replace this process with a new one in-place." >&2
                set -g __is_launched_without_string 1
            end
        end
        set -p PATH $__fish_bin_dir
        set string_cmd string \'$argv\'

        if fish -c 'contains string (builtin -n)'
            fish -c "$string_cmd"
        else
            return 127
        end
    end
...
125	166	------> not contains string (builtin -n)
41	41	-------> builtin -n
24	24	--> contains -- $basename $sourcelist
22	22	--> set sourcelist $sourcelist $basename
55	55	--> [ -f $file -a -r $file ]
193	1052	--> source $file
35	859	---> if command -s pipenv > /dev/null
    
    # complete --command pipenv --arguments "(env _PIPENV_COMPLETE=complete-fish COMMANDLINE=(commandline -cp) pipenv)" -f
    
    function __pipenv_shell_activate --on-variable PWD
        if status --is-command-substitution
            return
        end
        if not test -e "$PWD/Pipfile"
            if not string match -q "$__pipenv_fish_initial_pwd"/'*' "$PWD/"
                set -U __pipenv_fish_final_pwd "$PWD"
                exit
            end
            return
        end

        if not test -n "$PIPENV_ACTIVE"
          if pipenv --venv >/dev/null 2>&1
            set -x __pipenv_fish_initial_pwd "$PWD"

            if [ "$pipenv_fish_fancy" = 'yes' ]
                set -- __pipenv_fish_arguments $__pipenv_fish_arguments --fancy
            end

            pipenv shell $__pipenv_fish_arguments

            set -e __pipenv_fish_initial_pwd
            if test -n "$__pipenv_fish_final_pwd"
                cd "$__pipenv_fish_final_pwd"
                set -e __pipenv_fish_final_pwd
            end
          end
        end
    end
else
    function pipenv -d "https://pipenv.readthedocs.io/en/latest/"
        echo "Install https://pipenv.readthedocs.io/en/latest/ to use this plugin." > /dev/stderr
        return 1
    end
...
807	807	----> command -s pipenv > /dev/null
17	17	----> function __pipenv_shell_activate --on-variable PWD
        if status --is-command-substitution
            return
        end
        if not test -e "$PWD/Pipfile"
            if not string match -q "$__pipenv_fish_initial_pwd"/'*' "$PWD/"
                set -U __pipenv_fish_final_pwd "$PWD"
                exit
            end
            return
        end

        if not test -n "$PIPENV_ACTIVE"
          if pipenv --venv >/dev/null 2>&1
            set -x __pipenv_fish_initial_pwd "$PWD"

            if [ "$pipenv_fish_fancy" = 'yes' ]
                set -- __pipenv_fish_arguments $__pipenv_fish_arguments --fancy
            end

            pipenv shell $__pipenv_fish_arguments

            set -e __pipenv_fish_initial_pwd
            if test -n "$__pipenv_fish_final_pwd"
                cd "$__pipenv_fish_final_pwd"
                set -e __pipenv_fish_final_pwd
            end
          end
        end
    ...
64	122	--> set -l basename (string replace -r '^.*/' '' -- $file)
58	58	---> string replace -r '^.*/' '' -- $file
28	28	--> contains -- $basename $sourcelist
27	27	--> set sourcelist $sourcelist $basename
57	57	--> [ -f $file -a -r $file ]
192	294	--> source $file
25	25	---> set -q FZF_TMUX_HEIGHT
16	16	---> set -q FZF_DEFAULT_OPTS
15	15	---> set -q FZF_LEGACY_KEYBINDINGS
18	18	---> set -q FZF_PREVIEW_FILE_CMD
15	15	---> set -q FZF_PREVIEW_DIR_CMD
13	13	---> function fzf_uninstall -e fzf_uninstall
    # disabled until we figure out a sensible way to ensure user overrides
    # are not erased
    # set -l _vars (set | command grep -E "^FZF.*\$" | command awk '{print $1;}')
    # for var in $_vars
    #     eval (set -e $var)
    # end
...
66	115	--> set -l basename (string replace -r '^.*/' '' -- $file)
49	49	---> string replace -r '^.*/' '' -- $file
37	37	--> contains -- $basename $sourcelist
29	29	--> set sourcelist $sourcelist $basename
55	55	--> [ -f $file -a -r $file ]
280	742	--> source $file
15	430	---> if test "$FZF_LEGACY_KEYBINDINGS" -eq 1
    bind \ct '__fzf_find_file'
    bind \cr '__fzf_reverse_isearch'
    bind \ec '__fzf_cd'
    bind \eC '__fzf_cd --hidden'
    bind \cg '__fzf_open'
    bind \co '__fzf_open --editor'

    if bind -M insert >/dev/null 2>/dev/null
        bind -M insert \ct '__fzf_find_file'
        bind -M insert \cr '__fzf_reverse_isearch'
        bind -M insert \ec '__fzf_cd'
        bind -M insert \eC '__fzf_cd --hidden'
        bind -M insert \cg '__fzf_open'
        bind -M insert \co '__fzf_open --editor'
    end
else
    bind \co '__fzf_find_file'
    bind \cr '__fzf_reverse_isearch'
    bind \ec '__fzf_cd'
    bind \eC '__fzf_cd --hidden'
    bind \eO '__fzf_open'
    bind \eo '__fzf_open --editor'

    if bind -M insert >/dev/null 2>/dev/null
        bind -M insert \co '__fzf_find_file'
        bind -M insert \cr '__fzf_reverse_isearch'
        bind -M insert \ec '__fzf_cd'
        bind -M insert \eC '__fzf_cd --hidden'
        bind -M insert \eO '__fzf_open'
        bind -M insert \eo '__fzf_open --editor'
    end
...
42	42	----> test "$FZF_LEGACY_KEYBINDINGS" -eq 1
76	76	----> bind \ct '__fzf_find_file'
22	22	----> bind \cr '__fzf_reverse_isearch'
20	20	----> bind \ec '__fzf_cd'
19	19	----> bind \eC '__fzf_cd --hidden'
19	19	----> bind \cg '__fzf_open'
18	18	----> bind \co '__fzf_open --editor'
16	199	----> if bind -M insert >/dev/null 2>/dev/null
        bind -M insert \ct '__fzf_find_file'
        bind -M insert \cr '__fzf_reverse_isearch'
        bind -M insert \ec '__fzf_cd'
        bind -M insert \eC '__fzf_cd --hidden'
        bind -M insert \cg '__fzf_open'
        bind -M insert \co '__fzf_open --editor'
    ...
45	45	-----> bind -M insert >/dev/null 2>/dev/null
22	22	-----> bind -M insert \ct '__fzf_find_file'
19	19	-----> bind -M insert \cr '__fzf_reverse_isearch'
26	26	-----> bind -M insert \ec '__fzf_cd'
28	28	-----> bind -M insert \eC '__fzf_cd --hidden'
24	24	-----> bind -M insert \cg '__fzf_open'
19	19	-----> bind -M insert \co '__fzf_open --editor'
3	20	---> if set -q FZF_COMPLETE
    bind \t '__fzf_complete'
    if bind -M insert >/dev/null 2>/dev/null
        bind -M insert \t '__fzf_complete'
    end
...
17	17	----> set -q FZF_COMPLETE
12	12	---> function fzf_key_bindings_uninstall -e fzf_key_bindings_uninstall
    # disabled until we figure out a sensible way to ensure user overrides
    # are not erased
    # set -l _bindings (bind -a | sed -En "s/(')?__fzf.*\$//p" | sed 's/bind/bind -e/')
    # for binding in $_bindings
    #     eval $binding
    # end
...
100	100	> builtin source /usr/local/Cellar/fish/3.0.2/etc/fish/config.fish
370	31376	> builtin source /Users/nathan/.config/fish/config.fish
2	23	-> if status --is-login
  set -gx fish_greeting ""

  switch (uname)
  case Linux
      echo Hi Tux!
      set -gx HOMEBREW_PREFIX "/home/linuxbrew/.linuxbrew";
      set -gx HOMEBREW_CELLAR "/home/linuxbrew/.linuxbrew/Cellar";
      set -gx HOMEBREW_REPOSITORY "/home/linuxbrew/.linuxbrew/Homebrew";
      set -g fish_user_paths "/home/linuxbrew/.linuxbrew/bin" "/home/linuxbrew/.linuxbrew/sbin" $fish_user_paths;
      set -q MANPATH; or set MANPATH ''; set -gx MANPATH "/home/linuxbrew/.linuxbrew/share/man" $MANPATH;
      set -q INFOPATH; or set INFOPATH ''; set -gx INFOPATH "/home/linuxbrew/.linuxbrew/share/info" $INFOPATH;
  case Darwin
      set -gx PATH /usr/local/bin /usr/bin /bin /usr/sbin /sbin /usr/local/sbin /usr/local/MacGPG2/bin /Library/TeX/texbin
      # Use GNU utilities instead of macOS versions
      set -gx PATH /usr/local/opt/{coreutils,findutils,grep,gnu-sed,make}/libexec/gnubin $PATH
      # Use Homebrew curl
      set -gx PATH /usr/local/opt/curl/bin $PATH
      # Use installed LLVM tools
      set -gx PATH /usr/local/opt/llvm/bin $PATH
  case '*'
      echo Unknown OS, you may want to add some config!
      uname
  end


  # XDG Directories
  set -gx XDG_CONFIG_HOME $HOME/.config
  # set -gx XDG_CACHE_HOME $HOME/.cache
  # set -gx XDG_DATA_HOME $HOME/.local/share

  # Bootstrap fisher
  # https://github.com/jorgebucaran/fisher
  if not functions -q fisher
      curl https://git.io/fisher --create-dirs -sLo "$XDG_CONFIG_HOME/fish/functions/fisher.fish"
      fish -c fisher
  end

  # Set vi bindings
  set -gx fish_key_bindings fish_user_key_bindings

  # Set editor
  set -gx EDITOR nvim

  # FZF
  set -gx FZF_DEFAULT_COMMAND  'rg -g !.git/ --files --hidden'

  # AWS
  set -gx SAM_CLI_TELEMETRY 0

  # Load aliases
  source ~/.config/fish/aliases.fish

  # Load secrets
  # source ~/.config/fish/secrets.fish

  # Force certain more-secure behaviors from homebrew
  set -x HOMEBREW_NO_INSECURE_REDIRECT 1
  set -x HOMEBREW_CASK_OPTS --require-sha
  set -gx HOMEBREW_NO_ANALYTICS 1

  # Java
  if type --no-function --quiet nodenv
    status --is-interactive; and jenv init - | source
  end

  # JavaScript specific settings
  # Set up nodenv
  if type --no-function --quiet nodenv
    status --is-interactive; and nodenv init - | source
  end

  # Ruby specific settings
  # Rbenv
  if type --no-function --quiet rbenv
    status --is-interactive; and rbenv init - | source
  end
  # set -gx PATH /usr/local/opt/ruby/bin $PATH

  # Go specific settings
  set -gx GOPATH ~/Developer/go
  set -gx PATH $GOPATH/bin $PATH

  # Python settings
  set -gx PATH $HOME/.poetry/bin $PATH
  if type --no-function --quiet pyenv
    status --is-interactive; and pyenv init - | source
  end
  # Use pyenv's current python version
  set -gx PIPENV_PYTHON $HOME/.pyenv/shims/python

  # Rust specific settings
  # Rust tools XDG compatibility
  # set -gx CARGO_HOME "$XDG_DATA_HOME"/cargo
  # set -gx RUSTUP_HOME "$XDG_DATA_HOME"/rustup

  # set -gx PATH $PATH $CARGO_HOME/bin

  # Io specific settings
  # set -gx EERIEDIR ~/.eerie
  # set -gx PATH $PATH $EERIEDIR/base/bin $EERIEDIR/activeEnv/bin

#   # Keybase development
#   set -e KEYBASE_PERF
#   set -x KEYBASE_LOCAL_DEBUG 1
#   set -x KEYBASE_DEV_TOOL_ROOTS "$HOME/Library/Application Support/Google/Chrome/Default/Extensions/fmkadmapgofadopljbjfkapdkoienihi,$HOME/Library/Application Support/Google/Chrome/Default/Extensions/hgldghadipiblonfkkicmgcbbijnpeog"
#   set -x RUN_MODE devel
#   # set -gx PATH /usr/local/opt/mysql@5.6/bin $PATH
#   # Android
#   # set -x ANDROID_HOME "$HOME/Library/Android/sdk"
#   # set -x PATH $PATH $ANDROID_HOME/tools $ANDROID_HOME/platform-tools $ANDROID_HOME/tools/bin $ANDROID_HOME/emulator

...
21	21	--> status --is-login
37	37	-> test -e {$HOME}/.iterm2_shell_integration.fish
401	30946	-> source {$HOME}/.iterm2_shell_integration.fish
16	3285	--> if begin; status --is-interactive; and not functions -q -- iterm2_status; and [ "$ITERM_ENABLE_SHELL_INTEGRATION_WITH_TMUX""$TERM" != screen ]; and [ "$TERM" != dumb ]; and [ "$TERM" != linux ]; end
  function iterm2_status
    printf "\033]133;D;%s\007" $argv
  end

  # Mark start of prompt
  function iterm2_prompt_mark
    printf "\033]133;A\007"
  end

  # Mark end of prompt
  function iterm2_prompt_end
    printf "\033]133;B\007"
  end

  # Tell terminal to create a mark at this location
  function iterm2_preexec
    # For other shells we would output status here but we can't do that in fish.
    printf "\033]133;C;\007"
  end

  # Usage: iterm2_set_user_var key value
  # These variables show up in badges (and later in other places). For example
  # iterm2_set_user_var currentDirectory "$PWD"
  # Gives a variable accessible in a badge by \(user.currentDirectory)
  # Calls to this go in iterm2_print_user_vars.
  function iterm2_set_user_var
    printf "\033]1337;SetUserVar=%s=%s\007" "$argv[1]" (printf "%s" "$argv[2]" | base64 | tr -d "\n")
  end

  # iTerm2 inform terminal that command starts here
  function iterm2_precmd
    printf "\033]1337;RemoteHost=%s@%s\007\033]1337;CurrentDir=%s\007" $USER $iterm2_hostname $PWD

    # Users can define a function called iterm2_print_user_vars.
    # It should call iterm2_set_user_var and produce no other output.
    if functions -q -- iterm2_print_user_vars
      iterm2_print_user_vars
    end

  end

  functions -c fish_prompt iterm2_fish_prompt

  functions -c fish_mode_prompt iterm2_fish_mode_prompt
  function fish_mode_prompt --description 'Write out the mode prompt; do not replace this. Instead, change fish_mode_prompt before sourcing .iterm2_shell_integration.fish, or modify iterm2_fish_mode_prompt instead.'
     set -l last_status $status

     iterm2_status $last_status
     if not functions iterm2_fish_prompt | grep iterm2_prompt_mark > /dev/null
       iterm2_prompt_mark
     end
     sh -c "exit $last_status"

     iterm2_fish_mode_prompt
  end

  function fish_prompt --description 'Write out the prompt; do not replace this. Instead, change fish_prompt before sourcing .iterm2_shell_integration.fish, or modify iterm2_fish_prompt instead.'
     # Remove the trailing newline from the original prompt. This is done
     # using the string builtin from fish, but to make sure any escape codes
     # are correctly interpreted, use %b for printf.
     printf "%b" (string join "\n" (iterm2_fish_prompt))

     iterm2_prompt_end
  end

  function underscore_change -v _
    if [ x$_ = xfish ]
      iterm2_precmd
    else
      iterm2_preexec
    end
  end

  # If hostname -f is slow for you, set iterm2_hostname before sourcing this script
  if not set -q iterm2_hostname
    set iterm2_hostname (hostname -f 2>/dev/null)
    # some flavors of BSD (i.e. NetBSD and OpenBSD) don't have the -f option
    if test $status -ne 0
      set iterm2_hostname (hostname)
    end
  end

  iterm2_precmd
  printf "\033]1337;ShellIntegrationVersion=7;shell=fish\007"
...
12	159	---> begin; status --is-interactive; and not functions -q -- iterm2_status; and [ "$ITERM_ENABLE_SHELL_INTEGRATION_WITH_TMUX""$TERM" != screen ]; and [ "$TERM" != dumb ]; and [ "$TERM" != linux ]; ...
20	20	----> status --is-interactive
62	62	----> not functions -q -- iterm2_status
29	29	----> [ "$ITERM_ENABLE_SHELL_INTEGRATION_WITH_TMUX""$TERM" != screen ]
18	18	----> [ "$TERM" != dumb ]
18	18	----> [ "$TERM" != linux ]
6	6	---> function iterm2_status
    printf "\033]133;D;%s\007" $argv
  ...
5	5	---> function iterm2_prompt_mark
    printf "\033]133;A\007"
  ...
4	4	---> function iterm2_prompt_end
    printf "\033]133;B\007"
  ...
4	4	---> function iterm2_preexec
    # For other shells we would output status here but we can't do that in fish.
    printf "\033]133;C;\007"
  ...
7	7	---> function iterm2_set_user_var
    printf "\033]1337;SetUserVar=%s=%s\007" "$argv[1]" (printf "%s" "$argv[2]" | base64 | tr -d "\n")
  ...
4	4	---> function iterm2_precmd
    printf "\033]1337;RemoteHost=%s@%s\007\033]1337;CurrentDir=%s\007" $USER $iterm2_hostname $PWD

    # Users can define a function called iterm2_print_user_vars.
    # It should call iterm2_set_user_var and produce no other output.
    if functions -q -- iterm2_print_user_vars
      iterm2_print_user_vars
    end

  ...
110	544	---> functions -c fish_prompt iterm2_fish_prompt
372	434	----> source /Users/nathan/.config/fish/functions/fish_prompt.fish
12	12	-----> function _user_host_name -d "Displays the user and host name if connected via SSH"
  if test -n "$SSH_TTY"
    switch "$USER"
      case root toor
        set user_color red
      case '*'
        set user_color yellow
    end
    echo -s (set_color --bold $user_color) $USER (set_color normal) ' at ' (set_color --bold blue) (prompt_hostname) (set_color normal) ' '
  end
...
10	10	-----> function _directory -d "Writes the colorized present working directory"
  echo -s 'in ' (set_color --bold cyan) (prompt_pwd) (set_color normal)
...
8	8	-----> function _node -d "Writes the node version if there is a package.json"
  if test -f ./package.json
    echo -s (set_color --bold green) ' ⬢ ' (node -v) (set_color normal)
  end
...
9	9	-----> function _ruby -d "Writes the ruby version if there are ruby files"
  if test -f Gemfile # -o -f Rakefile -o (count *.rb) -gt 0
    echo -s (set_color --bold red) ' 💎 ' (rbenv version-name) (set_color normal)
  end
...
8	8	-----> function _git_status -d "Writes the current git status, if there is one."
  set -l branch_name (__fish_git_prompt "%s" | sed 's/ //')
  if test -z $branch_name
    return
  end

  echo -s (set_color normal) " on "
  set -l dirty (command git status --porcelain ^/dev/null)
  if test -z "$dirty"
    set_color --bold green
  else
    set_color --bold red
  end
  echo -s "$branch_name" (set_color normal)

  set -l unpushed_changes (git cherry -v ^/dev/null)
  if test -z "$unpushed_changes"
    return
  end

  echo -s " with " (set_color --bold magenta) "unpushed" (set_color normal)

...
7	7	-----> function _vim_mode -d "Writes the current vim mode"
  if test "$fish_key_bindings" = "fish_vi_key_bindings"
    switch $fish_bind_mode
      case default
        set_color --bold red
        echo -n 🅽
      case insert
        set_color --bold green
        echo -n 🅸
      case replace_one
        set_color --bold green
        echo -n 🆁
      case visual
        set_color --bold brmagenta
        echo -n 🆅
    end
    echo " "
    set_color normal
  end
...
8	8	-----> function fish_prompt -d "Write out the prompt"
  echo -nes "\n" (_vim_mode) (_user_host_name) (_directory) (_git_status) (_node) (_ruby) '\n› '
...
115	201	---> functions -c fish_mode_prompt iterm2_fish_mode_prompt
72	86	----> source /Users/nathan/.config/fish/functions/fish_mode_prompt.fish
14	14	-----> function fish_mode_prompt --description 'Displays the current mode'
  # This is a function override, we handle displaying the mode in the prompt directly in `fish_prompt.fish`
  # See https://github.com/fish-shell/fish-shell/issues/3232#issuecomment-232670506
...
15	15	---> function fish_mode_prompt --description 'Write out the mode prompt; do not replace this. Instead, change fish_mode_prompt before sourcing .iterm2_shell_integration.fish, or modify iterm2_fish_mode_prompt instead.'
     set -l last_status $status

     iterm2_status $last_status
     if not functions iterm2_fish_prompt | grep iterm2_prompt_mark > /dev/null
       iterm2_prompt_mark
     end
     sh -c "exit $last_status"

     iterm2_fish_mode_prompt
  ...
14	14	---> function fish_prompt --description 'Write out the prompt; do not replace this. Instead, change fish_prompt before sourcing .iterm2_shell_integration.fish, or modify iterm2_fish_prompt instead.'
     # Remove the trailing newline from the original prompt. This is done
     # using the string builtin from fish, but to make sure any escape codes
     # are correctly interpreted, use %b for printf.
     printf "%b" (string join "\n" (iterm2_fish_prompt))

     iterm2_prompt_end
  ...
7	7	---> function underscore_change -v _
    if [ x$_ = xfish ]
      iterm2_precmd
    else
      iterm2_preexec
    end
  ...
8	2073	---> if not set -q iterm2_hostname
    set iterm2_hostname (hostname -f 2>/dev/null)
    # some flavors of BSD (i.e. NetBSD and OpenBSD) don't have the -f option
    if test $status -ne 0
      set iterm2_hostname (hostname)
    end
  ...
22	22	----> not set -q iterm2_hostname
89	2004	----> set iterm2_hostname (hostname -f 2>/dev/null)
1733	1915	-----> hostname -f 2>/dev/null
146	182	------> source /usr/local/Cellar/fish/3.0.2/share/fish/functions/hostname.fish
36	36	-------> set -q USERDOMAIN
3	39	----> if test $status -ne 0
      set iterm2_hostname (hostname)
    ...
36	36	-----> test $status -ne 0
23	198	---> iterm2_precmd
113	113	----> printf "\033]1337;RemoteHost=%s@%s\007\033]1337;CurrentDir=%s\007" $USER $iterm2_hostname $PWD
3	62	----> if functions -q -- iterm2_print_user_vars
      iterm2_print_user_vars
    ...
59	59	-----> functions -q -- iterm2_print_user_vars
28	28	---> printf "\033]1337;ShellIntegrationVersion=7;shell=fish\007"
145	2943	--> alias imgcat=~/.iterm2/imgcat
358	373	---> source /usr/local/Cellar/fish/3.0.2/share/fish/functions/alias.fish
15	15	----> function alias --description 'Creates a function wrapping a command'
    set -l options 'h/help' 's/save'
    argparse -n alias --max-args=2 $options -- $argv
    or return

    if set -q _flag_help
        __fish_print_help alias
        return 0
    end

    set -l name
    set -l body
    set -l prefix
    set -l first_word
    set -l wrapped_cmd

    if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    end

    # sanity check
    if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    end

    # Extract the first command from the body. This is supposed to replace all non-escaped (i.e.
    # preceded by an odd number of `\`) spaces with a newline so it splits on them. See issue #2220
    # for why the following borderline incomprehensible code exists.
    set -l tmp (string replace -ra -- "([^\\\ ])((\\\\\\\)*) " '$1\n' $body)
    set first_word (string trim -- $tmp[1])
    # If the user does something like `alias x 'foo; bar'` we need to strip the semicolon.
    set base_command (string trim -c ';' -- $first_word)
    if set -q tmp[2]
        set body $tmp[2..-1]
    else
        set body
    end

    # Prevent the alias from immediately running into an infinite recursion if
    # $body starts with the same command as $name.
    if test $base_command = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    end
    set -l cmd_string (string escape -- "alias $argv")
    set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
    echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
    if set -q _flag_save
        funcsave $name
    end
    #echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end"
...
28	28	---> set -l options 'h/help' 's/save'
43	43	---> argparse -n alias --max-args=2 $options -- $argv
3	19	---> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
16	16	----> set -q _flag_help
14	14	---> set -l name
13	13	---> set -l body
15	15	---> set -l prefix
15	15	---> set -l first_word
15	15	---> set -l wrapped_cmd
14	161	---> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
14	14	----> not set -q argv[1]
13	13	----> not set -q argv[2]
51	84	----> set -l tmp (string split -m 1 "=" -- $argv) ""
33	33	-----> string split -m 1 "=" -- $argv
19	19	----> set name $tmp[1]
17	17	----> set body $tmp[2]
5	40	---> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
19	19	----> test -z "$name"
16	16	----> test -z "$body"
48	109	---> set -l tmp (string replace -ra -- "([^\\\ ])((\\\\\\\)*) " '$1\n' $body)
61	61	----> string replace -ra -- "([^\\\ ])((\\\\\\\)*) " '$1\n' $body
42	67	---> set first_word (string trim -- $tmp[1])
25	25	----> string trim -- $tmp[1]
43	68	---> set base_command (string trim -c ';' -- $first_word)
25	25	----> string trim -c ';' -- $first_word
6	35	---> if set -q tmp[2]
        set body $tmp[2..-1]
    else
        set body
    ...
15	15	----> set -q tmp[2]
14	14	----> set body
1	23	---> if test $base_command = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
22	22	----> test $base_command = $name
44	73	---> set -l cmd_string (string escape -- "alias $argv")
29	29	----> string escape -- "alias $argv"
90	811	---> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
721	721	----> string join ' ' -- $first_word $body | string escape
806	831	---> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
25	25	----> function imgcat --wraps '~/.iterm2/imgcat' --description 'alias imgcat=~/.iterm2/imgcat';  ~/.iterm2/imgcat  $argv; ...
3	45	---> if set -q _flag_save
        funcsave $name
    ...
42	42	----> set -q _flag_save
64	2334	--> alias imgls=~/.iterm2/imgls
26	26	---> set -l options 'h/help' 's/save'
36	36	---> argparse -n alias --max-args=2 $options -- $argv
1	17	---> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
16	16	----> set -q _flag_help
15	15	---> set -l name
14	14	---> set -l body
15	15	---> set -l prefix
15	15	---> set -l first_word
17	17	---> set -l wrapped_cmd
14	169	---> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
15	15	----> not set -q argv[1]
14	14	----> not set -q argv[2]
58	89	----> set -l tmp (string split -m 1 "=" -- $argv) ""
31	31	-----> string split -m 1 "=" -- $argv
19	19	----> set name $tmp[1]
18	18	----> set body $tmp[2]
4	41	---> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
20	20	----> test -z "$name"
17	17	----> test -z "$body"
47	90	---> set -l tmp (string replace -ra -- "([^\\\ ])((\\\\\\\)*) " '$1\n' $body)
43	43	----> string replace -ra -- "([^\\\ ])((\\\\\\\)*) " '$1\n' $body
42	66	---> set first_word (string trim -- $tmp[1])
24	24	----> string trim -- $tmp[1]
43	68	---> set base_command (string trim -c ';' -- $first_word)
25	25	----> string trim -c ';' -- $first_word
7	37	---> if set -q tmp[2]
        set body $tmp[2..-1]
    else
        set body
    ...
17	17	----> set -q tmp[2]
13	13	----> set body
1	24	---> if test $base_command = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
23	23	----> test $base_command = $name
43	69	---> set -l cmd_string (string escape -- "alias $argv")
26	26	----> string escape -- "alias $argv"
67	732	---> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
665	665	----> string join ' ' -- $first_word $body | string escape
742	772	---> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
30	30	----> function imgls --wraps '~/.iterm2/imgls' --description 'alias imgls=~/.iterm2/imgls';  ~/.iterm2/imgls  $argv; ...
3	47	---> if set -q _flag_save
        funcsave $name
    ...
44	44	----> set -q _flag_save
84	2578	--> alias it2attention=~/.iterm2/it2attention
28	28	---> set -l options 'h/help' 's/save'
38	38	---> argparse -n alias --max-args=2 $options -- $argv
1	17	---> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
16	16	----> set -q _flag_help
15	15	---> set -l name
14	14	---> set -l body
15	15	---> set -l prefix
15	15	---> set -l first_word
16	16	---> set -l wrapped_cmd
12	169	---> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
15	15	----> not set -q argv[1]
14	14	----> not set -q argv[2]
59	91	----> set -l tmp (string split -m 1 "=" -- $argv) ""
32	32	-----> string split -m 1 "=" -- $argv
20	20	----> set name $tmp[1]
17	17	----> set body $tmp[2]
4	54	---> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
30	30	----> test -z "$name"
20	20	----> test -z "$body"
53	102	---> set -l tmp (string replace -ra -- "([^\\\ ])((\\\\\\\)*) " '$1\n' $body)
49	49	----> string replace -ra -- "([^\\\ ])((\\\\\\\)*) " '$1\n' $body
46	80	---> set first_word (string trim -- $tmp[1])
34	34	----> string trim -- $tmp[1]
55	122	---> set base_command (string trim -c ';' -- $first_word)
67	67	----> string trim -c ';' -- $first_word
8	47	---> if set -q tmp[2]
        set body $tmp[2..-1]
    else
        set body
    ...
20	20	----> set -q tmp[2]
19	19	----> set body
2	29	---> if test $base_command = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
27	27	----> test $base_command = $name
56	89	---> set -l cmd_string (string escape -- "alias $argv")
33	33	----> string escape -- "alias $argv"
80	821	---> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
741	741	----> string join ' ' -- $first_word $body | string escape
753	781	---> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
28	28	----> function it2attention --wraps '~/.iterm2/it2attention' --description 'alias it2attention=~/.iterm2/it2attention';  ~/.iterm2/it2attention  $argv; ...
3	42	---> if set -q _flag_save
        funcsave $name
    ...
39	39	----> set -q _flag_save
62	2296	--> alias it2check=~/.iterm2/it2check
27	27	---> set -l options 'h/help' 's/save'
39	39	---> argparse -n alias --max-args=2 $options -- $argv
2	18	---> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
16	16	----> set -q _flag_help
14	14	---> set -l name
14	14	---> set -l body
15	15	---> set -l prefix
15	15	---> set -l first_word
15	15	---> set -l wrapped_cmd
10	168	---> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
15	15	----> not set -q argv[1]
14	14	----> not set -q argv[2]
59	91	----> set -l tmp (string split -m 1 "=" -- $argv) ""
32	32	-----> string split -m 1 "=" -- $argv
20	20	----> set name $tmp[1]
18	18	----> set body $tmp[2]
3	41	---> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
21	21	----> test -z "$name"
17	17	----> test -z "$body"
48	93	---> set -l tmp (string replace -ra -- "([^\\\ ])((\\\\\\\)*) " '$1\n' $body)
45	45	----> string replace -ra -- "([^\\\ ])((\\\\\\\)*) " '$1\n' $body
42	67	---> set first_word (string trim -- $tmp[1])
25	25	----> string trim -- $tmp[1]
42	68	---> set base_command (string trim -c ';' -- $first_word)
26	26	----> string trim -c ';' -- $first_word
6	36	---> if set -q tmp[2]
        set body $tmp[2..-1]
    else
        set body
    ...
16	16	----> set -q tmp[2]
14	14	----> set body
2	25	---> if test $base_command = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
23	23	----> test $base_command = $name
44	74	---> set -l cmd_string (string escape -- "alias $argv")
30	30	----> string escape -- "alias $argv"
75	729	---> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
654	654	----> string join ' ' -- $first_word $body | string escape
722	744	---> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
22	22	----> function it2check --wraps '~/.iterm2/it2check' --description 'alias it2check=~/.iterm2/it2check';  ~/.iterm2/it2check  $argv; ...
2	32	---> if set -q _flag_save
        funcsave $name
    ...
30	30	----> set -q _flag_save
121	2825	--> alias it2copy=~/.iterm2/it2copy
26	26	---> set -l options 'h/help' 's/save'
38	38	---> argparse -n alias --max-args=2 $options -- $argv
1	17	---> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
16	16	----> set -q _flag_help
15	15	---> set -l name
13	13	---> set -l body
14	14	---> set -l prefix
15	15	---> set -l first_word
14	14	---> set -l wrapped_cmd
11	169	---> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
15	15	----> not set -q argv[1]
14	14	----> not set -q argv[2]
57	91	----> set -l tmp (string split -m 1 "=" -- $argv) ""
34	34	-----> string split -m 1 "=" -- $argv
20	20	----> set name $tmp[1]
18	18	----> set body $tmp[2]
3	40	---> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
20	20	----> test -z "$name"
17	17	----> test -z "$body"
48	91	---> set -l tmp (string replace -ra -- "([^\\\ ])((\\\\\\\)*) " '$1\n' $body)
43	43	----> string replace -ra -- "([^\\\ ])((\\\\\\\)*) " '$1\n' $body
43	68	---> set first_word (string trim -- $tmp[1])
25	25	----> string trim -- $tmp[1]
43	68	---> set base_command (string trim -c ';' -- $first_word)
25	25	----> string trim -c ';' -- $first_word
5	35	---> if set -q tmp[2]
        set body $tmp[2..-1]
    else
        set body
    ...
16	16	----> set -q tmp[2]
14	14	----> set body
2	24	---> if test $base_command = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
22	22	----> test $base_command = $name
44	73	---> set -l cmd_string (string escape -- "alias $argv")
29	29	----> string escape -- "alias $argv"
87	872	---> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
785	785	----> string join ' ' -- $first_word $body | string escape
1007	1069	---> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
62	62	----> function it2copy --wraps '~/.iterm2/it2copy' --description 'alias it2copy=~/.iterm2/it2copy';  ~/.iterm2/it2copy  $argv; ...
4	43	---> if set -q _flag_save
        funcsave $name
    ...
39	39	----> set -q _flag_save
112	3135	--> alias it2dl=~/.iterm2/it2dl
31	31	---> set -l options 'h/help' 's/save'
43	43	---> argparse -n alias --max-args=2 $options -- $argv
5	71	---> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
66	66	----> set -q _flag_help
31	31	---> set -l name
61	61	---> set -l body
25	25	---> set -l prefix
18	18	---> set -l first_word
17	17	---> set -l wrapped_cmd
23	208	---> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
18	18	----> not set -q argv[1]
15	15	----> not set -q argv[2]
74	112	----> set -l tmp (string split -m 1 "=" -- $argv) ""
38	38	-----> string split -m 1 "=" -- $argv
21	21	----> set name $tmp[1]
19	19	----> set body $tmp[2]
4	44	---> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
22	22	----> test -z "$name"
18	18	----> test -z "$body"
83	229	---> set -l tmp (string replace -ra -- "([^\\\ ])((\\\\\\\)*) " '$1\n' $body)
146	146	----> string replace -ra -- "([^\\\ ])((\\\\\\\)*) " '$1\n' $body
93	141	---> set first_word (string trim -- $tmp[1])
48	48	----> string trim -- $tmp[1]
79	126	---> set base_command (string trim -c ';' -- $first_word)
47	47	----> string trim -c ';' -- $first_word
15	175	---> if set -q tmp[2]
        set body $tmp[2..-1]
    else
        set body
    ...
96	96	----> set -q tmp[2]
64	64	----> set body
3	39	---> if test $base_command = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
36	36	----> test $base_command = $name
57	90	---> set -l cmd_string (string escape -- "alias $argv")
33	33	----> string escape -- "alias $argv"
81	863	---> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
782	782	----> string join ' ' -- $first_word $body | string escape
753	781	---> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
28	28	----> function it2dl --wraps '~/.iterm2/it2dl' --description 'alias it2dl=~/.iterm2/it2dl';  ~/.iterm2/it2dl  $argv; ...
2	30	---> if set -q _flag_save
        funcsave $name
    ...
28	28	----> set -q _flag_save
79	2260	--> alias it2getvar=~/.iterm2/it2getvar
26	26	---> set -l options 'h/help' 's/save'
35	35	---> argparse -n alias --max-args=2 $options -- $argv
1	17	---> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
16	16	----> set -q _flag_help
14	14	---> set -l name
13	13	---> set -l body
15	15	---> set -l prefix
15	15	---> set -l first_word
15	15	---> set -l wrapped_cmd
12	167	---> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
15	15	----> not set -q argv[1]
14	14	----> not set -q argv[2]
55	88	----> set -l tmp (string split -m 1 "=" -- $argv) ""
33	33	-----> string split -m 1 "=" -- $argv
20	20	----> set name $tmp[1]
18	18	----> set body $tmp[2]
4	42	---> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
21	21	----> test -z "$name"
17	17	----> test -z "$body"
48	91	---> set -l tmp (string replace -ra -- "([^\\\ ])((\\\\\\\)*) " '$1\n' $body)
43	43	----> string replace -ra -- "([^\\\ ])((\\\\\\\)*) " '$1\n' $body
42	67	---> set first_word (string trim -- $tmp[1])
25	25	----> string trim -- $tmp[1]
42	67	---> set base_command (string trim -c ';' -- $first_word)
25	25	----> string trim -c ';' -- $first_word
5	35	---> if set -q tmp[2]
        set body $tmp[2..-1]
    else
        set body
    ...
16	16	----> set -q tmp[2]
14	14	----> set body
1	24	---> if test $base_command = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
23	23	----> test $base_command = $name
44	73	---> set -l cmd_string (string escape -- "alias $argv")
29	29	----> string escape -- "alias $argv"
76	695	---> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
619	619	----> string join ' ' -- $first_word $body | string escape
707	740	---> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
33	33	----> function it2getvar --wraps '~/.iterm2/it2getvar' --description 'alias it2getvar=~/.iterm2/it2getvar';  ~/.iterm2/it2getvar  $argv; ...
3	30	---> if set -q _flag_save
        funcsave $name
    ...
27	27	----> set -q _flag_save
66	2177	--> alias it2setcolor=~/.iterm2/it2setcolor
26	26	---> set -l options 'h/help' 's/save'
35	35	---> argparse -n alias --max-args=2 $options -- $argv
3	18	---> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
15	15	----> set -q _flag_help
14	14	---> set -l name
13	13	---> set -l body
14	14	---> set -l prefix
14	14	---> set -l first_word
14	14	---> set -l wrapped_cmd
11	167	---> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
15	15	----> not set -q argv[1]
14	14	----> not set -q argv[2]
58	89	----> set -l tmp (string split -m 1 "=" -- $argv) ""
31	31	-----> string split -m 1 "=" -- $argv
20	20	----> set name $tmp[1]
18	18	----> set body $tmp[2]
3	41	---> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
21	21	----> test -z "$name"
17	17	----> test -z "$body"
49	90	---> set -l tmp (string replace -ra -- "([^\\\ ])((\\\\\\\)*) " '$1\n' $body)
41	41	----> string replace -ra -- "([^\\\ ])((\\\\\\\)*) " '$1\n' $body
42	67	---> set first_word (string trim -- $tmp[1])
25	25	----> string trim -- $tmp[1]
41	67	---> set base_command (string trim -c ';' -- $first_word)
26	26	----> string trim -c ';' -- $first_word
6	35	---> if set -q tmp[2]
        set body $tmp[2..-1]
    else
        set body
    ...
16	16	----> set -q tmp[2]
13	13	----> set body
3	25	---> if test $base_command = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
22	22	----> test $base_command = $name
44	73	---> set -l cmd_string (string escape -- "alias $argv")
29	29	----> string escape -- "alias $argv"
69	675	---> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
606	606	----> string join ' ' -- $first_word $body | string escape
657	694	---> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
37	37	----> function it2setcolor --wraps '~/.iterm2/it2setcolor' --description 'alias it2setcolor=~/.iterm2/it2setcolor';  ~/.iterm2/it2setcolor  $argv; ...
3	29	---> if set -q _flag_save
        funcsave $name
    ...
26	26	----> set -q _flag_save
88	2280	--> alias it2setkeylabel=~/.iterm2/it2setkeylabel
24	24	---> set -l options 'h/help' 's/save'
34	34	---> argparse -n alias --max-args=2 $options -- $argv
1	17	---> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
16	16	----> set -q _flag_help
14	14	---> set -l name
14	14	---> set -l body
15	15	---> set -l prefix
15	15	---> set -l first_word
14	14	---> set -l wrapped_cmd
10	162	---> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
15	15	----> not set -q argv[1]
14	14	----> not set -q argv[2]
54	85	----> set -l tmp (string split -m 1 "=" -- $argv) ""
31	31	-----> string split -m 1 "=" -- $argv
20	20	----> set name $tmp[1]
18	18	----> set body $tmp[2]
5	41	---> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
20	20	----> test -z "$name"
16	16	----> test -z "$body"
48	91	---> set -l tmp (string replace -ra -- "([^\\\ ])((\\\\\\\)*) " '$1\n' $body)
43	43	----> string replace -ra -- "([^\\\ ])((\\\\\\\)*) " '$1\n' $body
43	67	---> set first_word (string trim -- $tmp[1])
24	24	----> string trim -- $tmp[1]
42	68	---> set base_command (string trim -c ';' -- $first_word)
26	26	----> string trim -c ';' -- $first_word
5	35	---> if set -q tmp[2]
        set body $tmp[2..-1]
    else
        set body
    ...
16	16	----> set -q tmp[2]
14	14	----> set body
2	24	---> if test $base_command = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
22	22	----> test $base_command = $name
44	70	---> set -l cmd_string (string escape -- "alias $argv")
26	26	----> string escape -- "alias $argv"
67	700	---> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
633	633	----> string join ' ' -- $first_word $body | string escape
724	756	---> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
32	32	----> function it2setkeylabel --wraps '~/.iterm2/it2setkeylabel' --description 'alias it2setkeylabel=~/.iterm2/it2setkeylabel';  ~/.iterm2/it2setkeylabel  $argv; ...
3	31	---> if set -q _flag_save
        funcsave $name
    ...
28	28	----> set -q _flag_save
64	2183	--> alias it2ul=~/.iterm2/it2ul
26	26	---> set -l options 'h/help' 's/save'
35	35	---> argparse -n alias --max-args=2 $options -- $argv
1	17	---> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
16	16	----> set -q _flag_help
15	15	---> set -l name
13	13	---> set -l body
14	14	---> set -l prefix
15	15	---> set -l first_word
15	15	---> set -l wrapped_cmd
9	163	---> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
16	16	----> not set -q argv[1]
15	15	----> not set -q argv[2]
55	85	----> set -l tmp (string split -m 1 "=" -- $argv) ""
30	30	-----> string split -m 1 "=" -- $argv
20	20	----> set name $tmp[1]
18	18	----> set body $tmp[2]
3	41	---> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
20	20	----> test -z "$name"
18	18	----> test -z "$body"
49	89	---> set -l tmp (string replace -ra -- "([^\\\ ])((\\\\\\\)*) " '$1\n' $body)
40	40	----> string replace -ra -- "([^\\\ ])((\\\\\\\)*) " '$1\n' $body
44	68	---> set first_word (string trim -- $tmp[1])
24	24	----> string trim -- $tmp[1]
42	67	---> set base_command (string trim -c ';' -- $first_word)
25	25	----> string trim -c ';' -- $first_word
5	34	---> if set -q tmp[2]
        set body $tmp[2..-1]
    else
        set body
    ...
16	16	----> set -q tmp[2]
13	13	----> set body
2	24	---> if test $base_command = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
22	22	----> test $base_command = $name
43	68	---> set -l cmd_string (string escape -- "alias $argv")
25	25	----> string escape -- "alias $argv"
70	669	---> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
599	599	----> string join ' ' -- $first_word $body | string escape
664	717	---> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
53	53	----> function it2ul --wraps '~/.iterm2/it2ul' --description 'alias it2ul=~/.iterm2/it2ul';  ~/.iterm2/it2ul  $argv; ...
3	29	---> if set -q _flag_save
        funcsave $name
    ...
26	26	----> set -q _flag_save
89	2249	--> alias it2universion=~/.iterm2/it2universion
24	24	---> set -l options 'h/help' 's/save'
34	34	---> argparse -n alias --max-args=2 $options -- $argv
2	17	---> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
15	15	----> set -q _flag_help
15	15	---> set -l name
13	13	---> set -l body
15	15	---> set -l prefix
15	15	---> set -l first_word
14	14	---> set -l wrapped_cmd
11	163	---> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
15	15	----> not set -q argv[1]
14	14	----> not set -q argv[2]
56	86	----> set -l tmp (string split -m 1 "=" -- $argv) ""
30	30	-----> string split -m 1 "=" -- $argv
19	19	----> set name $tmp[1]
18	18	----> set body $tmp[2]
3	41	---> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
20	20	----> test -z "$name"
18	18	----> test -z "$body"
48	91	---> set -l tmp (string replace -ra -- "([^\\\ ])((\\\\\\\)*) " '$1\n' $body)
43	43	----> string replace -ra -- "([^\\\ ])((\\\\\\\)*) " '$1\n' $body
43	68	---> set first_word (string trim -- $tmp[1])
25	25	----> string trim -- $tmp[1]
43	69	---> set base_command (string trim -c ';' -- $first_word)
26	26	----> string trim -c ';' -- $first_word
6	35	---> if set -q tmp[2]
        set body $tmp[2..-1]
    else
        set body
    ...
15	15	----> set -q tmp[2]
14	14	----> set body
1	23	---> if test $base_command = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
22	22	----> test $base_command = $name
44	70	---> set -l cmd_string (string escape -- "alias $argv")
26	26	----> string escape -- "alias $argv"
65	671	---> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
606	606	----> string join ' ' -- $first_word $body | string escape
706	736	---> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
30	30	----> function it2universion --wraps '~/.iterm2/it2universion' --description 'alias it2universion=~/.iterm2/it2universion';  ~/.iterm2/it2universion  $argv; ...
3	46	---> if set -q _flag_save
        funcsave $name
    ...
43	43	----> set -q _flag_save
23	163	> underscore_change VARIABLE SET _
13	140	-> if [ x$_ = xfish ]
      iterm2_precmd
    else
      iterm2_preexec
    ...
24	24	--> [ x$_ = xfish ]
19	103	--> iterm2_precmd
53	53	---> printf "\033]1337;RemoteHost=%s@%s\007\033]1337;CurrentDir=%s\007" $USER $iterm2_hostname $PWD
3	31	---> if functions -q -- iterm2_print_user_vars
      iterm2_print_user_vars
    ...
28	28	----> functions -q -- iterm2_print_user_vars
102	110	> source /usr/local/Cellar/fish/3.0.2/share/fish/functions/fish_title.fish
8	8	-> function fish_title
    echo (status current-command) (__fish_pwd)
...
18	3109	> fish_title
78	3091	-> echo (status current-command) (__fish_pwd)
32	32	--> status current-command
119	2981	--> __fish_pwd
123	2758	---> source /usr/local/Cellar/fish/3.0.2/share/fish/functions/__fish_pwd.fish
80	2635	----> switch (uname)
    case 'CYGWIN_*'
        function __fish_pwd --description "Show current path"
            pwd | sed -e 's-^/cygdrive/\(.\)/\?-\u\1:/-'
        end
    case '*'
        function __fish_pwd --description "Show current path"
            pwd
        end
...
2535	2535	-----> uname
20	20	-----> function __fish_pwd --description "Show current path"
            pwd
        ...
104	104	---> pwd
31	39360	> __fish_on_interactive
229	39307	-> __fish_config_interactive
1150	1174	--> source /usr/local/Cellar/fish/3.0.2/share/fish/functions/__fish_config_interactive.fish
24	24	---> function __fish_config_interactive -d "Initializations that should be performed when entering interactive mode"
    if not set -q __fish_init_3_x
        # Perform transitions relevant to going from fish 2.x to 3.x.

        # Migrate old universal abbreviations to the new scheme.
        __fish_abbr_old | source

        set -U __fish_init_3_x
    end

    # Make sure this function is only run once.
    if set -q __fish_config_interactive_done
        return
    end

    set -g __fish_config_interactive_done
    set -g __fish_active_key_bindings

    # Set the correct user data directory
    set -l userdatadir ~/.local/share
    if set -q XDG_DATA_HOME
        set userdatadir $XDG_DATA_HOME
    end

    if not set -q fish_greeting
        set -l line1 (_ 'Welcome to fish, the friendly interactive shell')
        set -l line2 ''
        if not set -q __fish_init_2_3_0
            set line2 \n(_ 'Type `help` for instructions on how to use fish')
        end
        set -U fish_greeting "$line1$line2"
    end

    if set -q fish_private_mode
        set -l line (_ "fish is running in private mode, history will not be persisted.")
        set -g fish_greeting $fish_greeting.\n$line
    end

    #
    # If we are starting up for the first time, set various defaults.
    #
    # bump this to 2_4_0 when rolling release if anything changes after 9/10/2016
    if not set -q __fish_init_2_39_8
        # Regular syntax highlighting colors
        set -q fish_color_normal
        or set -U fish_color_normal normal
        set -q fish_color_command
        or set -U fish_color_command 005fd7
        set -q fish_color_param
        or set -U fish_color_param 00afff
        set -q fish_color_redirection
        or set -U fish_color_redirection 00afff
        set -q fish_color_comment
        or set -U fish_color_comment 990000
        set -q fish_color_error
        or set -U fish_color_error ff0000
        set -q fish_color_escape
        or set -U fish_color_escape 00a6b2
        set -q fish_color_operator
        or set -U fish_color_operator 00a6b2
        set -q fish_color_end
        or set -U fish_color_end 009900
        set -q fish_color_quote
        or set -U fish_color_quote 999900
        set -q fish_color_autosuggestion
        or set -U fish_color_autosuggestion 555 brblack
        set -q fish_color_user
        or set -U fish_color_user brgreen

        set -q fish_color_host
        or set -U fish_color_host normal
        set -q fish_color_valid_path
        or set -U fish_color_valid_path --underline

        set -q fish_color_cwd
        or set -U fish_color_cwd green
        set -q fish_color_cwd_root
        or set -U fish_color_cwd_root red

        # Background color for matching quotes and parenthesis
        set -q fish_color_match
        or set -U fish_color_match --background=brblue

        # Background color for search matches
        set -q fish_color_search_match
        or set -U fish_color_search_match bryellow --background=brblack

        # Background color for selections
        set -q fish_color_selection
        or set -U fish_color_selection white --bold --background=brblack

        set -q fish_color_cancel
        or set -U fish_color_cancel -r

        # Pager colors
        set -q fish_pager_color_prefix
        or set -U fish_pager_color_prefix white --bold --underline
        set -q fish_pager_color_completion
        or set -U fish_pager_color_completion
        set -q fish_pager_color_description
        or set -U fish_pager_color_description B3A06D yellow
        set -q fish_pager_color_progress
        or set -U fish_pager_color_progress brwhite --background=cyan

        #
        # Directory history colors
        #
        set -q fish_color_history_current
        or set -U fish_color_history_current --bold


        set -U __fish_init_2_39_8
    end

    #
    # Generate man page completions if not present.
    #
    # Don't do this if we're being invoked as part of running unit tests.
    if not set -q FISH_UNIT_TESTS_RUNNING
        if not test -d $userdatadir/fish/generated_completions
            # Generating completions from man pages needs python (see issue #3588).

            # We cannot simply do `fish_update_completions &` because it is a function.
            # We cannot do `eval` since it is a function.
            # We don't want to call `fish -c` since that is unnecessary and sources config.fish again.
            # Hence we'll call python directly.
            # c_m_p.py should work with any python version.
            set -l update_args -B $__fish_data_dir/tools/create_manpage_completions.py --manpath --cleanup-in '~/.config/fish/completions' --cleanup-in '~/.config/fish/generated_completions'
            for py in python{3,2,}
                if command -sq $py
                    $py $update_args >/dev/null 2>&1 &
                    break
                end
            end
        end
    end

    #
    # Print a greeting.
    # fish_greeting can be a function (preferred) or a variable.
    #
    if status --is-interactive
        if functions -q fish_greeting
            fish_greeting
        else
            # The greeting used to be skipped when fish_greeting was empty (not just undefined)
            # Keep it that way to not print superfluous newlines on old configuration
            test -n "$fish_greeting"
            and echo $fish_greeting
        end
    end

    #
    # This event handler makes sure the prompt is repainted when
    # fish_color_cwd changes value. Like all event handlers, it can't be
    # autoloaded.
    #
    function __fish_repaint --on-variable fish_color_cwd --description "Event handler, repaints the prompt when fish_color_cwd changes"
        if status --is-interactive
            set -e __fish_prompt_cwd
            commandline -f repaint 2>/dev/null
        end
    end

    function __fish_repaint_root --on-variable fish_color_cwd_root --description "Event handler, repaints the prompt when fish_color_cwd_root changes"
        if status --is-interactive
            set -e __fish_prompt_cwd
            commandline -f repaint 2>/dev/null
        end
    end

    #
    # Completions for SysV startup scripts. These aren't bound to any
    # specific command, so they can't be autoloaded.
    #
    if test -d /etc/init.d
        complete -x -p "/etc/init.d/*" -a start --description 'Start service'
        complete -x -p "/etc/init.d/*" -a stop --description 'Stop service'
        complete -x -p "/etc/init.d/*" -a status --description 'Print service status'
        complete -x -p "/etc/init.d/*" -a restart --description 'Stop and then start service'
        complete -x -p "/etc/init.d/*" -a reload --description 'Reload service configuration'
    end

    #
    # We want to show our completions for the [ (test) builtin, but
    # we don't want to create a [.fish. test.fish will not be loaded until
    # the user tries [ interactively.
    #
    complete -c [ --wraps test

    # Reload key bindings when binding variable change
    function __fish_reload_key_bindings -d "Reload key bindings when binding variable change" --on-variable fish_key_bindings
        # Make sure some key bindings are set
        if not set -q fish_key_bindings
            set -U fish_key_bindings fish_default_key_bindings
        end

        # Do nothing if the key bindings didn't actually change.
        # This could be because the variable was set to the existing value
        # or because it was a local variable.
        # If fish_key_bindings is empty on the first run, we still need to set the defaults.
        if test "$fish_key_bindings" = "$__fish_active_key_bindings" -a -n "$fish_key_bindings"
            return
        end
        # Check if fish_key_bindings is a valid function.
        # If not, either keep the previous bindings (if any) or revert to default.
        # Also print an error so the user knows.
        if not functions -q "$fish_key_bindings"
            echo "There is no fish_key_bindings function called: '$fish_key_bindings'" >&2
            # We need to see if this is a defined function, otherwise we'd be in an endless loop.
            if functions -q $__fish_active_key_bindings
                echo "Keeping $__fish_active_key_bindings" >&2
                # Set the variable to the old value so this error doesn't happen again.
                set fish_key_bindings $__fish_active_key_bindings
                return 1
            else if functions -q fish_default_key_bindings
                echo "Reverting to default bindings" >&2
                set fish_key_bindings fish_default_key_bindings
                # Return because we are called again
                return 0
            else
                # If we can't even find the default bindings, something is broken.
                # Without it, we would eventually run into the stack size limit, but that'd print hundreds of duplicate lines
                # so we should give up earlier.
                echo "Cannot find fish_default_key_bindings, falling back to very simple bindings." >&2
                echo "Most likely something is wrong with your installation." >&2
                return 0
            end
        end
        set -g __fish_active_key_bindings "$fish_key_bindings"
        set -g fish_bind_mode default
        if test "$fish_key_bindings" = fish_default_key_bindings
            # Redirect stderr per #1155
            fish_default_key_bindings 2>/dev/null
        else
            $fish_key_bindings 2>/dev/null
        end
        # Load user key bindings if they are defined
        if functions --query fish_user_key_bindings >/dev/null
            fish_user_key_bindings 2>/dev/null
        end
    end

    # Load key bindings
    __fish_reload_key_bindings

    if not set -q FISH_UNIT_TESTS_RUNNING
        # Enable bracketed paste before every prompt (see __fish_shared_bindings for the bindings).
        # Disable it for unit tests so we don't have to add the sequences to bind.expect
        function __fish_enable_bracketed_paste --on-event fish_prompt
            printf "\e[?2004h"
        end

        # Disable BP before every command because that might not support it.
        function __fish_disable_bracketed_paste --on-event fish_preexec --on-event fish_exit
            printf "\e[?2004l"
        end

        # Tell the terminal we support BP. Since we are in __f_c_i, the first fish_prompt
        # has already fired.
        __fish_enable_bracketed_paste
    end

    function __fish_winch_handler --on-signal WINCH -d "Repaint screen when window changes size"
        commandline -f repaint >/dev/null 2>/dev/null
    end

    # Notify terminals when $PWD changes (issue #906).
    # VTE based terminals, Terminal.app, and iTerm.app support this.
    set -q VTE_VERSION
    or set -l VTE_VERSION 0
    set -q TERM_PROGRAM
    or set -l TERM_PROGRAM
    if test "$VTE_VERSION" -ge 3405 -o "$TERM_PROGRAM" = "Apple_Terminal"
        function __update_cwd_osc --on-variable PWD --description 'Notify capable terminals when $PWD changes'
            if status --is-command-substitution
                or set -q INSIDE_EMACS
                return
            end
            printf \e\]7\;file://\%s\%s\a $hostname (string escape --style=url $PWD)
        end
        __update_cwd_osc # Run once because we might have already inherited a PWD from an old tab
    end

    ### Command-not-found handlers
    # This can be overridden by defining a new __fish_command_not_found_handler function
    if not type -q __fish_command_not_found_handler
        # Read the OS/Distro from /etc/os-release.
        # This has a "ID=" line that defines the exact distribution,
        # and an "ID_LIKE=" line that defines what it is derived from or otherwise like.
        # For our purposes, we use both.
        set -l os
        if test -r /etc/os-release
            set os (string match -r '^ID(?:_LIKE)?\s*=.*' < /etc/os-release | \
            string replace -r '^ID(?:_LIKE)?\s*=(.*)' '$1' | string trim -c '\'"' | string split " ")
        end

        # First check if we are on OpenSUSE since SUSE's handler has no options
        # but the same name and path as Ubuntu's.
        if contains -- suse $os
            or contains -- sles $os
            and type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/bin/command-not-found $argv[1]
            end
            # Check for Fedora's handler
        else if test -f /usr/libexec/pk-command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/libexec/pk-command-not-found $argv[1]
            end
            # Check in /usr/lib, this is where modern Ubuntus place this command
        else if test -f /usr/lib/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/lib/command-not-found -- $argv[1]
            end
            # Check for NixOS handler
        else if test -f /run/current-system/sw/bin/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /run/current-system/sw/bin/command-not-found $argv
            end
            # Ubuntu Feisty places this command in the regular path instead
        else if type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                command-not-found -- $argv[1]
            end
            # pkgfile is an optional, but official, package on Arch Linux
            # it ships with example handlers for bash and zsh, so we'll follow that format
        else if type -p -q pkgfile
            function __fish_command_not_found_handler --on-event fish_command_not_found
                set -l __packages (pkgfile --binaries --verbose -- $argv[1] 2>/dev/null)
                if test $status -eq 0
                    printf "%s may be found in the following packages:\n" "$argv[1]"
                    printf "  %s\n" $__packages
                else
                    __fish_default_command_not_found_handler $argv[1]
                end
            end
            # Use standard fish command not found handler otherwise
        else
            function __fish_command_not_found_handler --on-event fish_command_not_found
                __fish_default_command_not_found_handler $argv[1]
            end
        end
    end
...
2	26	--> if not set -q __fish_init_3_x
        # Perform transitions relevant to going from fish 2.x to 3.x.

        # Migrate old universal abbreviations to the new scheme.
        __fish_abbr_old | source

        set -U __fish_init_3_x
    ...
24	24	---> not set -q __fish_init_3_x
2	18	--> if set -q __fish_config_interactive_done
        return
    ...
16	16	---> set -q __fish_config_interactive_done
19	19	--> set -g __fish_config_interactive_done
15	15	--> set -g __fish_active_key_bindings
24	24	--> set -l userdatadir ~/.local/share
1	15	--> if set -q XDG_DATA_HOME
        set userdatadir $XDG_DATA_HOME
    ...
14	14	---> set -q XDG_DATA_HOME
3	16	--> if not set -q fish_greeting
        set -l line1 (_ 'Welcome to fish, the friendly interactive shell')
        set -l line2 ''
        if not set -q __fish_init_2_3_0
            set line2 \n(_ 'Type `help` for instructions on how to use fish')
        end
        set -U fish_greeting "$line1$line2"
    ...
13	13	---> not set -q fish_greeting
3	16	--> if set -q fish_private_mode
        set -l line (_ "fish is running in private mode, history will not be persisted.")
        set -g fish_greeting $fish_greeting.\n$line
    ...
13	13	---> set -q fish_private_mode
2	15	--> if not set -q __fish_init_2_39_8
        # Regular syntax highlighting colors
        set -q fish_color_normal
        or set -U fish_color_normal normal
        set -q fish_color_command
        or set -U fish_color_command 005fd7
        set -q fish_color_param
        or set -U fish_color_param 00afff
        set -q fish_color_redirection
        or set -U fish_color_redirection 00afff
        set -q fish_color_comment
        or set -U fish_color_comment 990000
        set -q fish_color_error
        or set -U fish_color_error ff0000
        set -q fish_color_escape
        or set -U fish_color_escape 00a6b2
        set -q fish_color_operator
        or set -U fish_color_operator 00a6b2
        set -q fish_color_end
        or set -U fish_color_end 009900
        set -q fish_color_quote
        or set -U fish_color_quote 999900
        set -q fish_color_autosuggestion
        or set -U fish_color_autosuggestion 555 brblack
        set -q fish_color_user
        or set -U fish_color_user brgreen

        set -q fish_color_host
        or set -U fish_color_host normal
        set -q fish_color_valid_path
        or set -U fish_color_valid_path --underline

        set -q fish_color_cwd
        or set -U fish_color_cwd green
        set -q fish_color_cwd_root
        or set -U fish_color_cwd_root red

        # Background color for matching quotes and parenthesis
        set -q fish_color_match
        or set -U fish_color_match --background=brblue

        # Background color for search matches
        set -q fish_color_search_match
        or set -U fish_color_search_match bryellow --background=brblack

        # Background color for selections
        set -q fish_color_selection
        or set -U fish_color_selection white --bold --background=brblack

        set -q fish_color_cancel
        or set -U fish_color_cancel -r

        # Pager colors
        set -q fish_pager_color_prefix
        or set -U fish_pager_color_prefix white --bold --underline
        set -q fish_pager_color_completion
        or set -U fish_pager_color_completion
        set -q fish_pager_color_description
        or set -U fish_pager_color_description B3A06D yellow
        set -q fish_pager_color_progress
        or set -U fish_pager_color_progress brwhite --background=cyan

        #
        # Directory history colors
        #
        set -q fish_color_history_current
        or set -U fish_color_history_current --bold


        set -U __fish_init_2_39_8
    ...
13	13	---> not set -q __fish_init_2_39_8
9	59	--> if not set -q FISH_UNIT_TESTS_RUNNING
        if not test -d $userdatadir/fish/generated_completions
            # Generating completions from man pages needs python (see issue #3588).

            # We cannot simply do `fish_update_completions &` because it is a function.
            # We cannot do `eval` since it is a function.
            # We don't want to call `fish -c` since that is unnecessary and sources config.fish again.
            # Hence we'll call python directly.
            # c_m_p.py should work with any python version.
            set -l update_args -B $__fish_data_dir/tools/create_manpage_completions.py --manpath --cleanup-in '~/.config/fish/completions' --cleanup-in '~/.config/fish/generated_completions'
            for py in python{3,2,}
                if command -sq $py
                    $py $update_args >/dev/null 2>&1 &
                    break
                end
            end
        end
    ...
14	14	---> not set -q FISH_UNIT_TESTS_RUNNING
2	36	---> if not test -d $userdatadir/fish/generated_completions
            # Generating completions from man pages needs python (see issue #3588).

            # We cannot simply do `fish_update_completions &` because it is a function.
            # We cannot do `eval` since it is a function.
            # We don't want to call `fish -c` since that is unnecessary and sources config.fish again.
            # Hence we'll call python directly.
            # c_m_p.py should work with any python version.
            set -l update_args -B $__fish_data_dir/tools/create_manpage_completions.py --manpath --cleanup-in '~/.config/fish/completions' --cleanup-in '~/.config/fish/generated_completions'
            for py in python{3,2,}
                if command -sq $py
                    $py $update_args >/dev/null 2>&1 &
                    break
                end
            end
        ...
34	34	----> not test -d $userdatadir/fish/generated_completions
5	107	--> if status --is-interactive
        if functions -q fish_greeting
            fish_greeting
        else
            # The greeting used to be skipped when fish_greeting was empty (not just undefined)
            # Keep it that way to not print superfluous newlines on old configuration
            test -n "$fish_greeting"
            and echo $fish_greeting
        end
    ...
17	17	---> status --is-interactive
7	85	---> if functions -q fish_greeting
            fish_greeting
        else
            # The greeting used to be skipped when fish_greeting was empty (not just undefined)
            # Keep it that way to not print superfluous newlines on old configuration
            test -n "$fish_greeting"
            and echo $fish_greeting
        ...
57	57	----> functions -q fish_greeting
21	21	----> test -n "$fish_greeting"
16	16	--> function __fish_repaint --on-variable fish_color_cwd --description "Event handler, repaints the prompt when fish_color_cwd changes"
        if status --is-interactive
            set -e __fish_prompt_cwd
            commandline -f repaint 2>/dev/null
        end
    ...
16	16	--> function __fish_repaint_root --on-variable fish_color_cwd_root --description "Event handler, repaints the prompt when fish_color_cwd_root changes"
        if status --is-interactive
            set -e __fish_prompt_cwd
            commandline -f repaint 2>/dev/null
        end
    ...
2	30	--> if test -d /etc/init.d
        complete -x -p "/etc/init.d/*" -a start --description 'Start service'
        complete -x -p "/etc/init.d/*" -a stop --description 'Stop service'
        complete -x -p "/etc/init.d/*" -a status --description 'Print service status'
        complete -x -p "/etc/init.d/*" -a restart --description 'Stop and then start service'
        complete -x -p "/etc/init.d/*" -a reload --description 'Reload service configuration'
    ...
28	28	---> test -d /etc/init.d
61	61	--> complete -c [ --wraps test
14	14	--> function __fish_reload_key_bindings -d "Reload key bindings when binding variable change" --on-variable fish_key_bindings
        # Make sure some key bindings are set
        if not set -q fish_key_bindings
            set -U fish_key_bindings fish_default_key_bindings
        end

        # Do nothing if the key bindings didn't actually change.
        # This could be because the variable was set to the existing value
        # or because it was a local variable.
        # If fish_key_bindings is empty on the first run, we still need to set the defaults.
        if test "$fish_key_bindings" = "$__fish_active_key_bindings" -a -n "$fish_key_bindings"
            return
        end
        # Check if fish_key_bindings is a valid function.
        # If not, either keep the previous bindings (if any) or revert to default.
        # Also print an error so the user knows.
        if not functions -q "$fish_key_bindings"
            echo "There is no fish_key_bindings function called: '$fish_key_bindings'" >&2
            # We need to see if this is a defined function, otherwise we'd be in an endless loop.
            if functions -q $__fish_active_key_bindings
                echo "Keeping $__fish_active_key_bindings" >&2
                # Set the variable to the old value so this error doesn't happen again.
                set fish_key_bindings $__fish_active_key_bindings
                return 1
            else if functions -q fish_default_key_bindings
                echo "Reverting to default bindings" >&2
                set fish_key_bindings fish_default_key_bindings
                # Return because we are called again
                return 0
            else
                # If we can't even find the default bindings, something is broken.
                # Without it, we would eventually run into the stack size limit, but that'd print hundreds of duplicate lines
                # so we should give up earlier.
                echo "Cannot find fish_default_key_bindings, falling back to very simple bindings." >&2
                echo "Most likely something is wrong with your installation." >&2
                return 0
            end
        end
        set -g __fish_active_key_bindings "$fish_key_bindings"
        set -g fish_bind_mode default
        if test "$fish_key_bindings" = fish_default_key_bindings
            # Redirect stderr per #1155
            fish_default_key_bindings 2>/dev/null
        else
            $fish_key_bindings 2>/dev/null
        end
        # Load user key bindings if they are defined
        if functions --query fish_user_key_bindings >/dev/null
            fish_user_key_bindings 2>/dev/null
        end
    ...
32	33602	--> __fish_reload_key_bindings
2	18	---> if not set -q fish_key_bindings
            set -U fish_key_bindings fish_default_key_bindings
        ...
16	16	----> not set -q fish_key_bindings
1	33	---> if test "$fish_key_bindings" = "$__fish_active_key_bindings" -a -n "$fish_key_bindings"
            return
        ...
32	32	----> test "$fish_key_bindings" = "$__fish_active_key_bindings" -a -n "$fish_key_bindings"
1	1437	---> if not functions -q "$fish_key_bindings"
            echo "There is no fish_key_bindings function called: '$fish_key_bindings'" >&2
            # We need to see if this is a defined function, otherwise we'd be in an endless loop.
            if functions -q $__fish_active_key_bindings
                echo "Keeping $__fish_active_key_bindings" >&2
                # Set the variable to the old value so this error doesn't happen again.
                set fish_key_bindings $__fish_active_key_bindings
                return 1
            else if functions -q fish_default_key_bindings
                echo "Reverting to default bindings" >&2
                set fish_key_bindings fish_default_key_bindings
                # Return because we are called again
                return 0
            else
                # If we can't even find the default bindings, something is broken.
                # Without it, we would eventually run into the stack size limit, but that'd print hundreds of duplicate lines
                # so we should give up earlier.
                echo "Cannot find fish_default_key_bindings, falling back to very simple bindings." >&2
                echo "Most likely something is wrong with your installation." >&2
                return 0
            end
        ...
122	1436	----> not functions -q "$fish_key_bindings"
1299	1314	-----> source /usr/local/Cellar/fish/3.0.2/share/fish/functions/fish_vi_key_bindings.fish
15	15	------> function fish_vi_key_bindings --description 'vi-like key bindings for fish'
    if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    end

    # Erase all bindings if not explicitly requested otherwise to
    # allow for hybrid bindings.
    # This needs to be checked here because if we are called again
    # via the variable handler the argument will be gone.
    set -l rebind true
    if test "$argv[1]" = "--no-erase"
        set rebind false
        set -e argv[1]
    else
        bind --erase --all --preset # clear earlier bindings, if any
    end

    # Allow just calling this function to correctly set the bindings.
    # Because it's a rather discoverable name, users will execute it
    # and without this would then have subtly broken bindings.
    if test "$fish_key_bindings" != "fish_vi_key_bindings"
        and test "$rebind" = "true"
        # Allow the user to set the variable universally.
        set -q fish_key_bindings
        or set -g fish_key_bindings
        # This triggers the handler, which calls us again and ensures the user_key_bindings
        # are executed.
        set fish_key_bindings fish_vi_key_bindings
        return
    end

    # The default escape timeout is 300ms. But for users of Vi bindings that can be slightly
    # annoying when trying to switch to Vi "normal" mode. So set a shorter timeout in this case
    # unless the user has explicitly set the delay.
    set -q fish_escape_delay_ms
    or set -g fish_escape_delay_ms 100

    set -l init_mode insert
    # These are only the special vi-style keys
    # not end/home, we share those.
    set -l eol_keys \$ g\$
    set -l bol_keys \^ 0 g\^

    if contains -- $argv[1] insert default visual
        set init_mode $argv[1]
    else if set -q argv[1]
        # We should still go on so the bindings still get set.
        echo "Unknown argument $argv" >&2
    end

    # Inherit shared key bindings.
    # Do this first so vi-bindings win over default.
    for mode in insert default visual
        __fish_shared_key_bindings -M $mode
    end

    bind -s --preset -M insert \r execute
    bind -s --preset -M insert \n execute

    bind -s --preset -M insert "" self-insert

    # Add way to kill current command line while in insert mode.
    bind -s --preset -M insert \cc __fish_cancel_commandline
    # Add a way to switch from insert to normal (command) mode.
    # Note if we are paging, we want to stay in insert mode
    # See #2871
    bind -s --preset -M insert \e "if commandline -P; commandline -f cancel; else; set fish_bind_mode default; commandline -f backward-char force-repaint; end"

    # Default (command) mode
    bind -s --preset :q exit
    bind -s --preset -m insert \cc __fish_cancel_commandline
    bind -s --preset -M default h backward-char
    bind -s --preset -M default l forward-char
    bind -s --preset -m insert \n execute
    bind -s --preset -m insert \r execute
    bind -s --preset -m insert i force-repaint
    bind -s --preset -m insert I beginning-of-line force-repaint
    bind -s --preset -m insert a forward-char force-repaint
    bind -s --preset -m insert A end-of-line force-repaint
    bind -s --preset -m visual v begin-selection force-repaint

    #bind -s --preset -m insert o "commandline -a \n" down-line force-repaint
    #bind -s --preset -m insert O beginning-of-line "commandline -i \n" up-line force-repaint # doesn't work

    bind -s --preset gg beginning-of-buffer
    bind -s --preset G end-of-buffer

    for key in $eol_keys
        bind -s --preset $key end-of-line
    end
    for key in $bol_keys
        bind -s --preset $key beginning-of-line
    end

    bind -s --preset u history-search-backward
    bind -s --preset \cr history-search-forward

    bind -s --preset [ history-token-search-backward
    bind -s --preset ] history-token-search-forward

    bind -s --preset k up-or-search
    bind -s --preset j down-or-search
    bind -s --preset b backward-word
    bind -s --preset B backward-bigword
    bind -s --preset ge backward-word
    bind -s --preset gE backward-bigword
    bind -s --preset w forward-word forward-char
    bind -s --preset W forward-bigword forward-char
    bind -s --preset e forward-char forward-word backward-char
    bind -s --preset E forward-bigword backward-char

    # OS X SnowLeopard doesn't have these keys. Don't show an annoying error message.
    # Vi/Vim doesn't support these keys in insert mode but that seems silly so we do so anyway.
    bind -s --preset -M insert -k home beginning-of-line 2>/dev/null
    bind -s --preset -M default -k home beginning-of-line 2>/dev/null
    bind -s --preset -M insert -k end end-of-line 2>/dev/null
    bind -s --preset -M default -k end end-of-line 2>/dev/null

    # Vi moves the cursor back if, after deleting, it is at EOL.
    # To emulate that, move forward, then backward, which will be a NOP
    # if there is something to move forward to.
    bind -s --preset -M default x delete-char forward-char backward-char
    bind -s --preset -M default X backward-delete-char
    bind -s --preset -M insert -k dc delete-char forward-char backward-char
    bind -s --preset -M default -k dc delete-char forward-char backward-char

    # Backspace deletes a char in insert mode, but not in normal/default mode.
    bind -s --preset -M insert -k backspace backward-delete-char
    bind -s --preset -M default -k backspace backward-char
    bind -s --preset -M insert \ch backward-delete-char
    bind -s --preset -M default \ch backward-char
    bind -s --preset -M insert \x7f backward-delete-char
    bind -s --preset -M default \x7f backward-char
    bind -s --preset -M insert \e\[3\;2~ backward-delete-char # Mavericks Terminal.app shift-ctrl-delete
    bind -s --preset -M default \e\[3\;2~ backward-delete-char # Mavericks Terminal.app shift-ctrl-delete

    bind -s --preset dd kill-whole-line
    bind -s --preset D kill-line
    bind -s --preset d\$ kill-line
    bind -s --preset d\^ backward-kill-line
    bind -s --preset dw kill-word
    bind -s --preset dW kill-bigword
    bind -s --preset diw forward-char forward-char backward-word kill-word
    bind -s --preset diW forward-char forward-char backward-bigword kill-bigword
    bind -s --preset daw forward-char forward-char backward-word kill-word
    bind -s --preset daW forward-char forward-char backward-bigword kill-bigword
    bind -s --preset de kill-word
    bind -s --preset dE kill-bigword
    bind -s --preset db backward-kill-word
    bind -s --preset dB backward-kill-bigword
    bind -s --preset dge backward-kill-word
    bind -s --preset dgE backward-kill-bigword
    bind -s --preset df begin-selection forward-jump kill-selection end-selection
    bind -s --preset dt begin-selection forward-jump backward-char kill-selection end-selection
    bind -s --preset dF begin-selection backward-jump kill-selection end-selection
    bind -s --preset dT begin-selection backward-jump forward-char kill-selection end-selection

    bind -s --preset -m insert s delete-char force-repaint
    bind -s --preset -m insert S kill-whole-line force-repaint
    bind -s --preset -m insert cc kill-whole-line force-repaint
    bind -s --preset -m insert C kill-line force-repaint
    bind -s --preset -m insert c\$ kill-line force-repaint
    bind -s --preset -m insert c\^ backward-kill-line force-repaint
    bind -s --preset -m insert cw kill-word force-repaint
    bind -s --preset -m insert cW kill-bigword force-repaint
    bind -s --preset -m insert ciw forward-char forward-char backward-word kill-word force-repaint
    bind -s --preset -m insert ciW forward-char forward-char backward-bigword kill-bigword force-repaint
    bind -s --preset -m insert caw forward-char forward-char backward-word kill-word force-repaint
    bind -s --preset -m insert caW forward-char forward-char backward-bigword kill-bigword force-repaint
    bind -s --preset -m insert ce kill-word force-repaint
    bind -s --preset -m insert cE kill-bigword force-repaint
    bind -s --preset -m insert cb backward-kill-word force-repaint
    bind -s --preset -m insert cB backward-kill-bigword force-repaint
    bind -s --preset -m insert cge backward-kill-word force-repaint
    bind -s --preset -m insert cgE backward-kill-bigword force-repaint

    bind -s --preset '~' capitalize-word
    bind -s --preset gu downcase-word
    bind -s --preset gU upcase-word

    bind -s --preset J end-of-line delete-char
    bind -s --preset K 'man (commandline -t) 2>/dev/null; or echo -n \a'

    bind -s --preset yy kill-whole-line yank
    bind -s --preset Y kill-whole-line yank
    bind -s --preset y\$ kill-line yank
    bind -s --preset y\^ backward-kill-line yank
    bind -s --preset yw kill-word yank
    bind -s --preset yW kill-bigword yank
    bind -s --preset yiw forward-char forward-char backward-word kill-word yank
    bind -s --preset yiW forward-char forward-char backward-bigword kill-bigword yank
    bind -s --preset yaw forward-char forward-char backward-word kill-word yank
    bind -s --preset yaW forward-char forward-char backward-bigword kill-bigword yank
    bind -s --preset ye kill-word yank
    bind -s --preset yE kill-bigword yank
    bind -s --preset yb backward-kill-word yank
    bind -s --preset yB backward-kill-bigword yank
    bind -s --preset yge backward-kill-word yank
    bind -s --preset ygE backward-kill-bigword yank

    bind -s --preset f forward-jump
    bind -s --preset F backward-jump
    bind -s --preset t forward-jump-till
    bind -s --preset T backward-jump-till
    bind -s --preset ';' repeat-jump
    bind -s --preset , repeat-jump-reverse

    # in emacs yank means paste
    bind -s --preset p yank
    bind -s --preset P backward-char yank
    bind -s --preset gp yank-pop

    bind -s --preset '"*p' "commandline -i ( xsel -p; echo )[1]"
    bind -s --preset '"*P' backward-char "commandline -i ( xsel -p; echo )[1]"

    #
    # Lowercase r, enters replace_one mode
    #
    bind -s --preset -m replace_one r force-repaint
    bind -s --preset -M replace_one -m default '' delete-char self-insert backward-char force-repaint
    bind -s --preset -M replace_one -m default \e cancel force-repaint

    #
    # visual mode
    #
    bind -s --preset -M visual h backward-char
    bind -s --preset -M visual l forward-char

    bind -s --preset -M visual k up-line
    bind -s --preset -M visual j down-line

    bind -s --preset -M visual b backward-word
    bind -s --preset -M visual B backward-bigword
    bind -s --preset -M visual ge backward-word
    bind -s --preset -M visual gE backward-bigword
    bind -s --preset -M visual w forward-word
    bind -s --preset -M visual W forward-bigword
    bind -s --preset -M visual e forward-word
    bind -s --preset -M visual E forward-bigword
    bind -s --preset -M visual o swap-selection-start-stop force-repaint

    bind -s --preset -M visual f forward-jump
    bind -s --preset -M visual t forward-jump-till
    bind -s --preset -M visual F backward-jump
    bind -s --preset -M visual T backward-jump-till

    for key in $eol_keys
        bind -s --preset -M visual $key end-of-line
    end
    for key in $bol_keys
        bind -s --preset -M visual $key beginning-of-line
    end

    bind -s --preset -M visual -m insert c kill-selection end-selection force-repaint
    bind -s --preset -M visual -m default d kill-selection end-selection force-repaint
    bind -s --preset -M visual -m default x kill-selection end-selection force-repaint
    bind -s --preset -M visual -m default X kill-whole-line end-selection force-repaint
    bind -s --preset -M visual -m default y kill-selection yank end-selection force-repaint
    bind -s --preset -M visual -m default '"*y' "commandline -s | xsel -p; commandline -f end-selection force-repaint"

    bind -s --preset -M visual -m default \cc end-selection force-repaint
    bind -s --preset -M visual -m default \e end-selection force-repaint

    # Make it easy to turn an unexecuted command into a comment in the shell history. Also, remove
    # the commenting chars so the command can be further edited then executed.
    bind -s --preset -M default \# __fish_toggle_comment_commandline
    bind -s --preset -M visual \# __fish_toggle_comment_commandline

    # Set the cursor shape
    # After executing once, this will have defined functions listening for the variable.
    # Therefore it needs to be before setting fish_bind_mode.
    fish_vi_cursor

    set fish_bind_mode $init_mode

...
34	34	---> set -g __fish_active_key_bindings "$fish_key_bindings"
19	19	---> set -g fish_bind_mode default
12	17176	---> if test "$fish_key_bindings" = fish_default_key_bindings
            # Redirect stderr per #1155
            fish_default_key_bindings 2>/dev/null
        else
            $fish_key_bindings 2>/dev/null
        ...
23	23	----> test "$fish_key_bindings" = fish_default_key_bindings
395	17141	----> $fish_key_bindings 2>/dev/null
4	45	-----> if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    ...
22	22	------> contains -- -h $argv
19	19	------> contains -- --help $argv
18	18	-----> set -l rebind true
7	59	-----> if test "$argv[1]" = "--no-erase"
        set rebind false
        set -e argv[1]
    else
        bind --erase --all --preset # clear earlier bindings, if any
    ...
23	23	------> test "$argv[1]" = "--no-erase"
29	29	------> bind --erase --all --preset
3	26	-----> if test "$fish_key_bindings" != "fish_vi_key_bindings"
        and test "$rebind" = "true"
        # Allow the user to set the variable universally.
        set -q fish_key_bindings
        or set -g fish_key_bindings
        # This triggers the handler, which calls us again and ensures the user_key_bindings
        # are executed.
        set fish_key_bindings fish_vi_key_bindings
        return
    ...
23	23	------> test "$fish_key_bindings" != "fish_vi_key_bindings"
17	17	-----> set -q fish_escape_delay_ms
24	24	-----> set -g fish_escape_delay_ms 100
19	19	-----> set -l init_mode insert
21	21	-----> set -l eol_keys \$ g\$
20	20	-----> set -l bol_keys \^ 0 g\^
4	49	-----> if contains -- $argv[1] insert default visual
        set init_mode $argv[1]
    else if set -q argv[1]
        # We should still go on so the bindings still get set.
        echo "Unknown argument $argv" >&2
    ...
31	31	------> contains -- $argv[1] insert default visual
14	14	------> set -q argv[1]
35	10390	-----> for mode in insert default visual
        __fish_shared_key_bindings -M $mode
    ...
222	3691	------> __fish_shared_key_bindings -M $mode
608	640	-------> source /usr/local/Cellar/fish/3.0.2/share/fish/functions/__fish_shared_key_bindings.fish
13	13	--------> function __fish_shared_key_bindings -d "Bindings shared between emacs and vi mode"
    # These are some bindings that are supposed to be shared between vi mode and default mode.
    # They are supposed to be unrelated to text-editing (or movement).
    # This takes $argv so the vi-bindings can pass the mode they are valid in.

    if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    end

    bind --preset $argv \cy yank
    or return # protect against invalid $argv
    bind --preset $argv \ey yank-pop

    # Left/Right arrow
    bind --preset $argv -k right forward-char
    bind --preset $argv -k left backward-char
    bind --preset $argv \e\[C forward-char
    bind --preset $argv \e\[D backward-char
    # Some terminals output these when they're in in keypad mode.
    bind --preset $argv \eOC forward-char
    bind --preset $argv \eOD backward-char

    bind --preset $argv -k ppage beginning-of-history
    bind --preset $argv -k npage end-of-history

    # Interaction with the system clipboard.
    bind --preset $argv \cx fish_clipboard_copy
    bind --preset $argv \cv fish_clipboard_paste

    bind --preset $argv \e cancel
    bind --preset $argv \t complete
    bind --preset $argv \cs pager-toggle-search
    # shift-tab does a tab complete followed by a search.
    bind --preset $argv --key btab complete-and-search

    bind --preset $argv \e\n "commandline -i \n"
    bind --preset $argv \e\r "commandline -i \n"

    bind --preset $argv -k down down-or-search
    bind --preset $argv -k up up-or-search
    bind --preset $argv \e\[A up-or-search
    bind --preset $argv \e\[B down-or-search
    bind --preset $argv \eOA up-or-search
    bind --preset $argv \eOB down-or-search

    # Alt-left/Alt-right
    bind --preset $argv \e\eOC nextd-or-forward-word
    bind --preset $argv \e\eOD prevd-or-backward-word
    bind --preset $argv \e\e\[C nextd-or-forward-word
    bind --preset $argv \e\e\[D prevd-or-backward-word
    bind --preset $argv \eO3C nextd-or-forward-word
    bind --preset $argv \eO3D prevd-or-backward-word
    bind --preset $argv \e\[3C nextd-or-forward-word
    bind --preset $argv \e\[3D prevd-or-backward-word
    bind --preset $argv \e\[1\;3C nextd-or-forward-word
    bind --preset $argv \e\[1\;3D prevd-or-backward-word
    bind --preset $argv \e\[1\;9C nextd-or-forward-word #iTerm2
    bind --preset $argv \e\[1\;9D prevd-or-backward-word #iTerm2

    # Alt-up/Alt-down
    bind --preset $argv \e\eOA history-token-search-backward
    bind --preset $argv \e\eOB history-token-search-forward
    bind --preset $argv \e\e\[A history-token-search-backward
    bind --preset $argv \e\e\[B history-token-search-forward
    bind --preset $argv \eO3A history-token-search-backward
    bind --preset $argv \eO3B history-token-search-forward
    bind --preset $argv \e\[3A history-token-search-backward
    bind --preset $argv \e\[3B history-token-search-forward
    bind --preset $argv \e\[1\;3A history-token-search-backward
    bind --preset $argv \e\[1\;3B history-token-search-forward
    bind --preset $argv \e\[1\;9A history-token-search-backward # iTerm2
    bind --preset $argv \e\[1\;9B history-token-search-forward # iTerm2
    # Bash compatibility
    # https://github.com/fish-shell/fish-shell/issues/89
    bind --preset $argv \e. history-token-search-backward

    bind --preset $argv \el __fish_list_current_token
    bind --preset $argv \ew 'set tok (commandline -pt); if test $tok[1]; echo; whatis $tok[1]; commandline -f repaint; end'
    # ncurses > 6.0 sends a "delete scrollback" sequence along with clear.
    # This string replace removes it.
    bind --preset $argv \cl 'echo -n (clear | string replace \e\[3J ""); commandline -f repaint'
    bind --preset $argv \cc __fish_cancel_commandline
    bind --preset $argv \cu backward-kill-line
    bind --preset $argv \cw backward-kill-path-component
    bind --preset $argv \e\[F end-of-line
    bind --preset $argv \e\[H beginning-of-line

    bind --preset $argv \ed 'set -l cmd (commandline); if test -z "$cmd"; echo; dirh; commandline -f repaint; else; commandline -f kill-word; end'
    bind --preset $argv \cd delete-or-exit

    # Allow reading manpages by pressing F1 (many GUI applications) or Alt+h (like in zsh).
    bind --preset $argv -k f1 __fish_man_page
    bind --preset $argv \eh __fish_man_page

    # This will make sure the output of the current command is paged using the default pager when
    # you press Meta-p.
    # If none is set, less will be used.
    bind --preset $argv \ep '__fish_paginate'

    # Make it easy to turn an unexecuted command into a comment in the shell history. Also,
    # remove the commenting chars so the command can be further edited then executed.
    bind --preset $argv \e\# __fish_toggle_comment_commandline

    # The [meta-e] and [meta-v] keystrokes invoke an external editor on the command buffer.
    bind --preset $argv \ee edit_command_buffer
    bind --preset $argv \ev edit_command_buffer

    # Support for "bracketed paste"
    # The way it works is that we acknowledge our support by printing
    # \e\[?2004h
    # then the terminal will "bracket" every paste in
    # \e\[200~ and \e\[201~
    # Every character in between those two will be part of the paste and should not cause a binding to execute (like \n executing commands).
    #
    # We enable it after every command and disable it before (in __fish_config_interactive.fish)
    #
    # Support for this seems to be ubiquitous - emacs enables it unconditionally (!) since 25.1 (though it only supports it since then,
    # it seems to be the last term to gain support).
    # TODO: Should we disable this in older emacsen?
    #
    # NOTE: This is more of a "security" measure than a proper feature.
    # The better way to paste remains the `fish_clipboard_paste` function (bound to \cv by default).
    # We don't disable highlighting here, so it will be redone after every character (which can be slow),
    # and it doesn't handle "paste-stop" sequences in the paste (which the terminal needs to strip, but KDE konsole doesn't).
    #
    # See http://thejh.net/misc/website-terminal-copy-paste. The second case will not be caught in KDE konsole.
    # Bind the starting sequence in every bind mode, even user-defined ones.

    # We usually just pass the text through as-is to facilitate pasting code,
    # but when the current token contains an unbalanced single-quote (`'`),
    # we escape all single-quotes and backslashes, effectively turning the paste
    # into one literal token, to facilitate pasting non-code (e.g. markdown or git commitishes)

    # Exclude paste mode or there'll be an additional binding after switching between emacs and vi
    for mode in (bind --list-modes | string match -v paste)
        bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
    end
    # This sequence ends paste-mode and returns to the previous mode we have saved before.
    bind --preset -M paste \e\[201~ '__fish_stop_bracketed_paste'
    # In paste-mode, everything self-inserts except for the sequence to get out of it
    bind --preset -M paste "" self-insert
    # Without this, a \r will overwrite the other text, rendering it invisible - which makes the exercise kinda pointless.
    # TODO: Test this in windows (\r\n line endings)
    bind --preset -M paste \r "commandline -i \n"
    bind --preset -M paste "'" "__fish_commandline_insert_escaped \' \$__fish_paste_quoted"
    bind --preset -M paste \\ "__fish_commandline_insert_escaped \\\ \$__fish_paste_quoted"
...
10	10	--------> function __fish_commandline_insert_escaped --description 'Insert the first arg escaped if a second arg is given'
    if set -q argv[2]
        commandline -i \\$argv[1]
    else
        commandline -i $argv[1]
    end
...
5	5	--------> function __fish_start_bracketed_paste
    # Save the last bind mode so we can restore it.
    set -g __fish_last_bind_mode $fish_bind_mode
    # If the token is currently single-quoted,
    # we escape single-quotes (and backslashes).
    __fish_commandline_is_singlequoted
    and set -g __fish_paste_quoted 1
...
4	4	--------> function __fish_stop_bracketed_paste
    # Restore the last bind mode.
    set fish_bind_mode $__fish_last_bind_mode
    set -e __fish_paste_quoted
    commandline -f force-repaint
...
4	70	-------> if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    ...
43	43	--------> contains -- -h $argv
23	23	--------> contains -- --help $argv
25	25	-------> bind --preset $argv \cy yank
32	32	-------> bind --preset $argv \ey yank-pop
28	28	-------> bind --preset $argv -k right forward-char
24	24	-------> bind --preset $argv -k left backward-char
23	23	-------> bind --preset $argv \e\[C forward-char
22	22	-------> bind --preset $argv \e\[D backward-char
20	20	-------> bind --preset $argv \eOC forward-char
20	20	-------> bind --preset $argv \eOD backward-char
22	22	-------> bind --preset $argv -k ppage beginning-of-history
23	23	-------> bind --preset $argv -k npage end-of-history
21	21	-------> bind --preset $argv \cx fish_clipboard_copy
24	24	-------> bind --preset $argv \cv fish_clipboard_paste
21	21	-------> bind --preset $argv \e cancel
20	20	-------> bind --preset $argv \t complete
20	20	-------> bind --preset $argv \cs pager-toggle-search
23	23	-------> bind --preset $argv --key btab complete-and-search
23	23	-------> bind --preset $argv \e\n "commandline -i \n"
22	22	-------> bind --preset $argv \e\r "commandline -i \n"
22	22	-------> bind --preset $argv -k down down-or-search
23	23	-------> bind --preset $argv -k up up-or-search
22	22	-------> bind --preset $argv \e\[A up-or-search
22	22	-------> bind --preset $argv \e\[B down-or-search
20	20	-------> bind --preset $argv \eOA up-or-search
22	22	-------> bind --preset $argv \eOB down-or-search
22	22	-------> bind --preset $argv \e\eOC nextd-or-forward-word
21	21	-------> bind --preset $argv \e\eOD prevd-or-backward-word
21	21	-------> bind --preset $argv \e\e\[C nextd-or-forward-word
22	22	-------> bind --preset $argv \e\e\[D prevd-or-backward-word
21	21	-------> bind --preset $argv \eO3C nextd-or-forward-word
21	21	-------> bind --preset $argv \eO3D prevd-or-backward-word
21	21	-------> bind --preset $argv \e\[3C nextd-or-forward-word
21	21	-------> bind --preset $argv \e\[3D prevd-or-backward-word
22	22	-------> bind --preset $argv \e\[1\;3C nextd-or-forward-word
25	25	-------> bind --preset $argv \e\[1\;3D prevd-or-backward-word
22	22	-------> bind --preset $argv \e\[1\;9C nextd-or-forward-word
22	22	-------> bind --preset $argv \e\[1\;9D prevd-or-backward-word
22	22	-------> bind --preset $argv \e\eOA history-token-search-backward
22	22	-------> bind --preset $argv \e\eOB history-token-search-forward
22	22	-------> bind --preset $argv \e\e\[A history-token-search-backward
22	22	-------> bind --preset $argv \e\e\[B history-token-search-forward
22	22	-------> bind --preset $argv \eO3A history-token-search-backward
24	24	-------> bind --preset $argv \eO3B history-token-search-forward
23	23	-------> bind --preset $argv \e\[3A history-token-search-backward
22	22	-------> bind --preset $argv \e\[3B history-token-search-forward
23	23	-------> bind --preset $argv \e\[1\;3A history-token-search-backward
22	22	-------> bind --preset $argv \e\[1\;3B history-token-search-forward
22	22	-------> bind --preset $argv \e\[1\;9A history-token-search-backward
23	23	-------> bind --preset $argv \e\[1\;9B history-token-search-forward
21	21	-------> bind --preset $argv \e. history-token-search-backward
21	21	-------> bind --preset $argv \el __fish_list_current_token
27	27	-------> bind --preset $argv \ew 'set tok (commandline -pt); if test $tok[1]; echo; whatis $tok[1]; commandline -f repaint; end'
23	23	-------> bind --preset $argv \cl 'echo -n (clear | string replace \e\[3J ""); commandline -f repaint'
21	21	-------> bind --preset $argv \cc __fish_cancel_commandline
20	20	-------> bind --preset $argv \cu backward-kill-line
21	21	-------> bind --preset $argv \cw backward-kill-path-component
22	22	-------> bind --preset $argv \e\[F end-of-line
22	22	-------> bind --preset $argv \e\[H beginning-of-line
27	27	-------> bind --preset $argv \ed 'set -l cmd (commandline); if test -z "$cmd"; echo; dirh; commandline -f repaint; else; commandline -f kill-word; end'
21	21	-------> bind --preset $argv \cd delete-or-exit
22	22	-------> bind --preset $argv -k f1 __fish_man_page
21	21	-------> bind --preset $argv \eh __fish_man_page
22	22	-------> bind --preset $argv \ep '__fish_paginate'
21	21	-------> bind --preset $argv \e\# __fish_toggle_comment_commandline
21	21	-------> bind --preset $argv \ee edit_command_buffer
21	21	-------> bind --preset $argv \ev edit_command_buffer
86	1177	-------> for mode in (bind --list-modes | string match -v paste)
        bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
    ...
999	999	--------> bind --list-modes | string match -v paste
59	59	--------> bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
33	33	--------> bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
27	27	-------> bind --preset -M paste \e\[201~ '__fish_stop_bracketed_paste'
35	35	-------> bind --preset -M paste "" self-insert
24	24	-------> bind --preset -M paste \r "commandline -i \n"
25	25	-------> bind --preset -M paste "'" "__fish_commandline_insert_escaped \' \$__fish_paste_quoted"
23	23	-------> bind --preset -M paste \\ "__fish_commandline_insert_escaped \\\ \$__fish_paste_quoted"
156	3212	------> __fish_shared_key_bindings -M $mode
5	51	-------> if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    ...
25	25	--------> contains -- -h $argv
21	21	--------> contains -- --help $argv
25	25	-------> bind --preset $argv \cy yank
25	25	-------> bind --preset $argv \ey yank-pop
28	28	-------> bind --preset $argv -k right forward-char
26	26	-------> bind --preset $argv -k left backward-char
25	25	-------> bind --preset $argv \e\[C forward-char
25	25	-------> bind --preset $argv \e\[D backward-char
22	22	-------> bind --preset $argv \eOC forward-char
22	22	-------> bind --preset $argv \eOD backward-char
33	33	-------> bind --preset $argv -k ppage beginning-of-history
34	34	-------> bind --preset $argv -k npage end-of-history
24	24	-------> bind --preset $argv \cx fish_clipboard_copy
23	23	-------> bind --preset $argv \cv fish_clipboard_paste
23	23	-------> bind --preset $argv \e cancel
23	23	-------> bind --preset $argv \t complete
23	23	-------> bind --preset $argv \cs pager-toggle-search
26	26	-------> bind --preset $argv --key btab complete-and-search
29	29	-------> bind --preset $argv \e\n "commandline -i \n"
25	25	-------> bind --preset $argv \e\r "commandline -i \n"
26	26	-------> bind --preset $argv -k down down-or-search
26	26	-------> bind --preset $argv -k up up-or-search
25	25	-------> bind --preset $argv \e\[A up-or-search
24	24	-------> bind --preset $argv \e\[B down-or-search
22	22	-------> bind --preset $argv \eOA up-or-search
21	21	-------> bind --preset $argv \eOB down-or-search
26	26	-------> bind --preset $argv \e\eOC nextd-or-forward-word
26	26	-------> bind --preset $argv \e\eOD prevd-or-backward-word
26	26	-------> bind --preset $argv \e\e\[C nextd-or-forward-word
28	28	-------> bind --preset $argv \e\e\[D prevd-or-backward-word
26	26	-------> bind --preset $argv \eO3C nextd-or-forward-word
32	32	-------> bind --preset $argv \eO3D prevd-or-backward-word
28	28	-------> bind --preset $argv \e\[3C nextd-or-forward-word
25	25	-------> bind --preset $argv \e\[3D prevd-or-backward-word
26	26	-------> bind --preset $argv \e\[1\;3C nextd-or-forward-word
26	26	-------> bind --preset $argv \e\[1\;3D prevd-or-backward-word
26	26	-------> bind --preset $argv \e\[1\;9C nextd-or-forward-word
26	26	-------> bind --preset $argv \e\[1\;9D prevd-or-backward-word
29	29	-------> bind --preset $argv \e\eOA history-token-search-backward
26	26	-------> bind --preset $argv \e\eOB history-token-search-forward
26	26	-------> bind --preset $argv \e\e\[A history-token-search-backward
26	26	-------> bind --preset $argv \e\e\[B history-token-search-forward
26	26	-------> bind --preset $argv \eO3A history-token-search-backward
26	26	-------> bind --preset $argv \eO3B history-token-search-forward
26	26	-------> bind --preset $argv \e\[3A history-token-search-backward
26	26	-------> bind --preset $argv \e\[3B history-token-search-forward
27	27	-------> bind --preset $argv \e\[1\;3A history-token-search-backward
27	27	-------> bind --preset $argv \e\[1\;3B history-token-search-forward
27	27	-------> bind --preset $argv \e\[1\;9A history-token-search-backward
27	27	-------> bind --preset $argv \e\[1\;9B history-token-search-forward
29	29	-------> bind --preset $argv \e. history-token-search-backward
24	24	-------> bind --preset $argv \el __fish_list_current_token
28	28	-------> bind --preset $argv \ew 'set tok (commandline -pt); if test $tok[1]; echo; whatis $tok[1]; commandline -f repaint; end'
27	27	-------> bind --preset $argv \cl 'echo -n (clear | string replace \e\[3J ""); commandline -f repaint'
23	23	-------> bind --preset $argv \cc __fish_cancel_commandline
23	23	-------> bind --preset $argv \cu backward-kill-line
23	23	-------> bind --preset $argv \cw backward-kill-path-component
26	26	-------> bind --preset $argv \e\[F end-of-line
25	25	-------> bind --preset $argv \e\[H beginning-of-line
29	29	-------> bind --preset $argv \ed 'set -l cmd (commandline); if test -z "$cmd"; echo; dirh; commandline -f repaint; else; commandline -f kill-word; end'
23	23	-------> bind --preset $argv \cd delete-or-exit
28	28	-------> bind --preset $argv -k f1 __fish_man_page
24	24	-------> bind --preset $argv \eh __fish_man_page
26	26	-------> bind --preset $argv \ep '__fish_paginate'
25	25	-------> bind --preset $argv \e\# __fish_toggle_comment_commandline
24	24	-------> bind --preset $argv \ee edit_command_buffer
31	31	-------> bind --preset $argv \ev edit_command_buffer
123	1204	-------> for mode in (bind --list-modes | string match -v paste)
        bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
    ...
924	924	--------> bind --list-modes | string match -v paste
109	109	--------> bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
48	48	--------> bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
26	26	-------> bind --preset -M paste \e\[201~ '__fish_stop_bracketed_paste'
24	24	-------> bind --preset -M paste "" self-insert
23	23	-------> bind --preset -M paste \r "commandline -i \n"
23	23	-------> bind --preset -M paste "'" "__fish_commandline_insert_escaped \' \$__fish_paste_quoted"
22	22	-------> bind --preset -M paste \\ "__fish_commandline_insert_escaped \\\ \$__fish_paste_quoted"
176	3452	------> __fish_shared_key_bindings -M $mode
4	49	-------> if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    ...
24	24	--------> contains -- -h $argv
21	21	--------> contains -- --help $argv
28	28	-------> bind --preset $argv \cy yank
27	27	-------> bind --preset $argv \ey yank-pop
31	31	-------> bind --preset $argv -k right forward-char
28	28	-------> bind --preset $argv -k left backward-char
27	27	-------> bind --preset $argv \e\[C forward-char
26	26	-------> bind --preset $argv \e\[D backward-char
23	23	-------> bind --preset $argv \eOC forward-char
22	22	-------> bind --preset $argv \eOD backward-char
28	28	-------> bind --preset $argv -k ppage beginning-of-history
28	28	-------> bind --preset $argv -k npage end-of-history
25	25	-------> bind --preset $argv \cx fish_clipboard_copy
24	24	-------> bind --preset $argv \cv fish_clipboard_paste
25	25	-------> bind --preset $argv \e cancel
24	24	-------> bind --preset $argv \t complete
23	23	-------> bind --preset $argv \cs pager-toggle-search
27	27	-------> bind --preset $argv --key btab complete-and-search
28	28	-------> bind --preset $argv \e\n "commandline -i \n"
26	26	-------> bind --preset $argv \e\r "commandline -i \n"
30	30	-------> bind --preset $argv -k down down-or-search
27	27	-------> bind --preset $argv -k up up-or-search
45	45	-------> bind --preset $argv \e\[A up-or-search
24	24	-------> bind --preset $argv \e\[B down-or-search
31	31	-------> bind --preset $argv \eOA up-or-search
30	30	-------> bind --preset $argv \eOB down-or-search
45	45	-------> bind --preset $argv \e\eOC nextd-or-forward-word
25	25	-------> bind --preset $argv \e\eOD prevd-or-backward-word
26	26	-------> bind --preset $argv \e\e\[C nextd-or-forward-word
26	26	-------> bind --preset $argv \e\e\[D prevd-or-backward-word
28	28	-------> bind --preset $argv \eO3C nextd-or-forward-word
25	25	-------> bind --preset $argv \eO3D prevd-or-backward-word
35	35	-------> bind --preset $argv \e\[3C nextd-or-forward-word
26	26	-------> bind --preset $argv \e\[3D prevd-or-backward-word
29	29	-------> bind --preset $argv \e\[1\;3C nextd-or-forward-word
28	28	-------> bind --preset $argv \e\[1\;3D prevd-or-backward-word
34	34	-------> bind --preset $argv \e\[1\;9C nextd-or-forward-word
28	28	-------> bind --preset $argv \e\[1\;9D prevd-or-backward-word
62	62	-------> bind --preset $argv \e\eOA history-token-search-backward
46	46	-------> bind --preset $argv \e\eOB history-token-search-forward
32	32	-------> bind --preset $argv \e\e\[A history-token-search-backward
29	29	-------> bind --preset $argv \e\e\[B history-token-search-forward
29	29	-------> bind --preset $argv \eO3A history-token-search-backward
28	28	-------> bind --preset $argv \eO3B history-token-search-forward
28	28	-------> bind --preset $argv \e\[3A history-token-search-backward
28	28	-------> bind --preset $argv \e\[3B history-token-search-forward
30	30	-------> bind --preset $argv \e\[1\;3A history-token-search-backward
29	29	-------> bind --preset $argv \e\[1\;3B history-token-search-forward
30	30	-------> bind --preset $argv \e\[1\;9A history-token-search-backward
29	29	-------> bind --preset $argv \e\[1\;9B history-token-search-forward
26	26	-------> bind --preset $argv \e. history-token-search-backward
28	28	-------> bind --preset $argv \el __fish_list_current_token
31	31	-------> bind --preset $argv \ew 'set tok (commandline -pt); if test $tok[1]; echo; whatis $tok[1]; commandline -f repaint; end'
27	27	-------> bind --preset $argv \cl 'echo -n (clear | string replace \e\[3J ""); commandline -f repaint'
25	25	-------> bind --preset $argv \cc __fish_cancel_commandline
24	24	-------> bind --preset $argv \cu backward-kill-line
25	25	-------> bind --preset $argv \cw backward-kill-path-component
27	27	-------> bind --preset $argv \e\[F end-of-line
27	27	-------> bind --preset $argv \e\[H beginning-of-line
31	31	-------> bind --preset $argv \ed 'set -l cmd (commandline); if test -z "$cmd"; echo; dirh; commandline -f repaint; else; commandline -f kill-word; end'
25	25	-------> bind --preset $argv \cd delete-or-exit
29	29	-------> bind --preset $argv -k f1 __fish_man_page
26	26	-------> bind --preset $argv \eh __fish_man_page
27	27	-------> bind --preset $argv \ep '__fish_paginate'
26	26	-------> bind --preset $argv \e\# __fish_toggle_comment_commandline
25	25	-------> bind --preset $argv \ee edit_command_buffer
25	25	-------> bind --preset $argv \ev edit_command_buffer
112	1241	-------> for mode in (bind --list-modes | string match -v paste)
        bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
    ...
988	988	--------> bind --list-modes | string match -v paste
54	54	--------> bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
35	35	--------> bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
52	52	--------> bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
28	28	-------> bind --preset -M paste \e\[201~ '__fish_stop_bracketed_paste'
23	23	-------> bind --preset -M paste "" self-insert
24	24	-------> bind --preset -M paste \r "commandline -i \n"
23	23	-------> bind --preset -M paste "'" "__fish_commandline_insert_escaped \' \$__fish_paste_quoted"
22	22	-------> bind --preset -M paste \\ "__fish_commandline_insert_escaped \\\ \$__fish_paste_quoted"
35	35	-----> bind -s --preset -M insert \r execute
28	28	-----> bind -s --preset -M insert \n execute
22	22	-----> bind -s --preset -M insert "" self-insert
23	23	-----> bind -s --preset -M insert \cc __fish_cancel_commandline
34	34	-----> bind -s --preset -M insert \e "if commandline -P; commandline -f cancel; else; set fish_bind_mode default; commandline -f backward-char force-repaint; end"
21	21	-----> bind -s --preset :q exit
22	22	-----> bind -s --preset -m insert \cc __fish_cancel_commandline
29	29	-----> bind -s --preset -M default h backward-char
31	31	-----> bind -s --preset -M default l forward-char
24	24	-----> bind -s --preset -m insert \n execute
22	22	-----> bind -s --preset -m insert \r execute
21	21	-----> bind -s --preset -m insert i force-repaint
22	22	-----> bind -s --preset -m insert I beginning-of-line force-repaint
24	24	-----> bind -s --preset -m insert a forward-char force-repaint
38	38	-----> bind -s --preset -m insert A end-of-line force-repaint
74	74	-----> bind -s --preset -m visual v begin-selection force-repaint
53	53	-----> bind -s --preset gg beginning-of-buffer
42	42	-----> bind -s --preset G end-of-buffer
39	143	-----> for key in $eol_keys
        bind -s --preset $key end-of-line
    ...
58	58	------> bind -s --preset $key end-of-line
46	46	------> bind -s --preset $key end-of-line
25	100	-----> for key in $bol_keys
        bind -s --preset $key beginning-of-line
    ...
27	27	------> bind -s --preset $key beginning-of-line
24	24	------> bind -s --preset $key beginning-of-line
24	24	------> bind -s --preset $key beginning-of-line
21	21	-----> bind -s --preset u history-search-backward
23	23	-----> bind -s --preset \cr history-search-forward
24	24	-----> bind -s --preset [ history-token-search-backward
20	20	-----> bind -s --preset ] history-token-search-forward
20	20	-----> bind -s --preset k up-or-search
20	20	-----> bind -s --preset j down-or-search
20	20	-----> bind -s --preset b backward-word
19	19	-----> bind -s --preset B backward-bigword
21	21	-----> bind -s --preset ge backward-word
24	24	-----> bind -s --preset gE backward-bigword
22	22	-----> bind -s --preset w forward-word forward-char
22	22	-----> bind -s --preset W forward-bigword forward-char
22	22	-----> bind -s --preset e forward-char forward-word backward-char
22	22	-----> bind -s --preset E forward-bigword backward-char
34	34	-----> bind -s --preset -M insert -k home beginning-of-line 2>/dev/null
29	29	-----> bind -s --preset -M default -k home beginning-of-line 2>/dev/null
27	27	-----> bind -s --preset -M insert -k end end-of-line 2>/dev/null
26	26	-----> bind -s --preset -M default -k end end-of-line 2>/dev/null
26	26	-----> bind -s --preset -M default x delete-char forward-char backward-char
23	23	-----> bind -s --preset -M default X backward-delete-char
34	34	-----> bind -s --preset -M insert -k dc delete-char forward-char backward-char
29	29	-----> bind -s --preset -M default -k dc delete-char forward-char backward-char
23	23	-----> bind -s --preset -M insert -k backspace backward-delete-char
22	22	-----> bind -s --preset -M default -k backspace backward-char
65	65	-----> bind -s --preset -M insert \ch backward-delete-char
39	39	-----> bind -s --preset -M default \ch backward-char
83	83	-----> bind -s --preset -M insert \x7f backward-delete-char
26	26	-----> bind -s --preset -M default \x7f backward-char
31	31	-----> bind -s --preset -M insert \e\[3\;2~ backward-delete-char
28	28	-----> bind -s --preset -M default \e\[3\;2~ backward-delete-char
22	22	-----> bind -s --preset dd kill-whole-line
20	20	-----> bind -s --preset D kill-line
22	22	-----> bind -s --preset d\$ kill-line
23	23	-----> bind -s --preset d\^ backward-kill-line
21	21	-----> bind -s --preset dw kill-word
21	21	-----> bind -s --preset dW kill-bigword
25	25	-----> bind -s --preset diw forward-char forward-char backward-word kill-word
26	26	-----> bind -s --preset diW forward-char forward-char backward-bigword kill-bigword
25	25	-----> bind -s --preset daw forward-char forward-char backward-word kill-word
25	25	-----> bind -s --preset daW forward-char forward-char backward-bigword kill-bigword
21	21	-----> bind -s --preset de kill-word
24	24	-----> bind -s --preset dE kill-bigword
23	23	-----> bind -s --preset db backward-kill-word
22	22	-----> bind -s --preset dB backward-kill-bigword
23	23	-----> bind -s --preset dge backward-kill-word
22	22	-----> bind -s --preset dgE backward-kill-bigword
26	26	-----> bind -s --preset df begin-selection forward-jump kill-selection end-selection
67	67	-----> bind -s --preset dt begin-selection forward-jump backward-char kill-selection end-selection
56	56	-----> bind -s --preset dF begin-selection backward-jump kill-selection end-selection
39	39	-----> bind -s --preset dT begin-selection backward-jump forward-char kill-selection end-selection
38	38	-----> bind -s --preset -m insert s delete-char force-repaint
25	25	-----> bind -s --preset -m insert S kill-whole-line force-repaint
26	26	-----> bind -s --preset -m insert cc kill-whole-line force-repaint
24	24	-----> bind -s --preset -m insert C kill-line force-repaint
30	30	-----> bind -s --preset -m insert c\$ kill-line force-repaint
28	28	-----> bind -s --preset -m insert c\^ backward-kill-line force-repaint
27	27	-----> bind -s --preset -m insert cw kill-word force-repaint
25	25	-----> bind -s --preset -m insert cW kill-bigword force-repaint
33	33	-----> bind -s --preset -m insert ciw forward-char forward-char backward-word kill-word force-repaint
36	36	-----> bind -s --preset -m insert ciW forward-char forward-char backward-bigword kill-bigword force-repaint
74	74	-----> bind -s --preset -m insert caw forward-char forward-char backward-word kill-word force-repaint
45	45	-----> bind -s --preset -m insert caW forward-char forward-char backward-bigword kill-bigword force-repaint
96	96	-----> bind -s --preset -m insert ce kill-word force-repaint
39	39	-----> bind -s --preset -m insert cE kill-bigword force-repaint
28	28	-----> bind -s --preset -m insert cb backward-kill-word force-repaint
26	26	-----> bind -s --preset -m insert cB backward-kill-bigword force-repaint
30	30	-----> bind -s --preset -m insert cge backward-kill-word force-repaint
27	27	-----> bind -s --preset -m insert cgE backward-kill-bigword force-repaint
25	25	-----> bind -s --preset '~' capitalize-word
24	24	-----> bind -s --preset gu downcase-word
24	24	-----> bind -s --preset gU upcase-word
23	23	-----> bind -s --preset J end-of-line delete-char
25	25	-----> bind -s --preset K 'man (commandline -t) 2>/dev/null; or echo -n \a'
24	24	-----> bind -s --preset yy kill-whole-line yank
22	22	-----> bind -s --preset Y kill-whole-line yank
32	32	-----> bind -s --preset y\$ kill-line yank
27	27	-----> bind -s --preset y\^ backward-kill-line yank
25	25	-----> bind -s --preset yw kill-word yank
24	24	-----> bind -s --preset yW kill-bigword yank
28	28	-----> bind -s --preset yiw forward-char forward-char backward-word kill-word yank
29	29	-----> bind -s --preset yiW forward-char forward-char backward-bigword kill-bigword yank
29	29	-----> bind -s --preset yaw forward-char forward-char backward-word kill-word yank
29	29	-----> bind -s --preset yaW forward-char forward-char backward-bigword kill-bigword yank
25	25	-----> bind -s --preset ye kill-word yank
24	24	-----> bind -s --preset yE kill-bigword yank
25	25	-----> bind -s --preset yb backward-kill-word yank
24	24	-----> bind -s --preset yB backward-kill-bigword yank
24	24	-----> bind -s --preset yge backward-kill-word yank
23	23	-----> bind -s --preset ygE backward-kill-bigword yank
21	21	-----> bind -s --preset f forward-jump
21	21	-----> bind -s --preset F backward-jump
21	21	-----> bind -s --preset t forward-jump-till
24	24	-----> bind -s --preset T backward-jump-till
23	23	-----> bind -s --preset ';' repeat-jump
21	21	-----> bind -s --preset , repeat-jump-reverse
20	20	-----> bind -s --preset p yank
22	22	-----> bind -s --preset P backward-char yank
82	82	-----> bind -s --preset gp yank-pop
36	36	-----> bind -s --preset '"*p' "commandline -i ( xsel -p; echo )[1]"
31	31	-----> bind -s --preset '"*P' backward-char "commandline -i ( xsel -p; echo )[1]"
23	23	-----> bind -s --preset -m replace_one r force-repaint
30	30	-----> bind -s --preset -M replace_one -m default '' delete-char self-insert backward-char force-repaint
27	27	-----> bind -s --preset -M replace_one -m default \e cancel force-repaint
23	23	-----> bind -s --preset -M visual h backward-char
22	22	-----> bind -s --preset -M visual l forward-char
22	22	-----> bind -s --preset -M visual k up-line
24	24	-----> bind -s --preset -M visual j down-line
23	23	-----> bind -s --preset -M visual b backward-word
22	22	-----> bind -s --preset -M visual B backward-bigword
24	24	-----> bind -s --preset -M visual ge backward-word
24	24	-----> bind -s --preset -M visual gE backward-bigword
22	22	-----> bind -s --preset -M visual w forward-word
23	23	-----> bind -s --preset -M visual W forward-bigword
23	23	-----> bind -s --preset -M visual e forward-word
23	23	-----> bind -s --preset -M visual E forward-bigword
24	24	-----> bind -s --preset -M visual o swap-selection-start-stop force-repaint
22	22	-----> bind -s --preset -M visual f forward-jump
22	22	-----> bind -s --preset -M visual t forward-jump-till
23	23	-----> bind -s --preset -M visual F backward-jump
23	23	-----> bind -s --preset -M visual T backward-jump-till
28	85	-----> for key in $eol_keys
        bind -s --preset -M visual $key end-of-line
    ...
29	29	------> bind -s --preset -M visual $key end-of-line
28	28	------> bind -s --preset -M visual $key end-of-line
19	97	-----> for key in $bol_keys
        bind -s --preset -M visual $key beginning-of-line
    ...
25	25	------> bind -s --preset -M visual $key beginning-of-line
26	26	------> bind -s --preset -M visual $key beginning-of-line
27	27	------> bind -s --preset -M visual $key beginning-of-line
30	30	-----> bind -s --preset -M visual -m insert c kill-selection end-selection force-repaint
26	26	-----> bind -s --preset -M visual -m default d kill-selection end-selection force-repaint
26	26	-----> bind -s --preset -M visual -m default x kill-selection end-selection force-repaint
26	26	-----> bind -s --preset -M visual -m default X kill-whole-line end-selection force-repaint
26	26	-----> bind -s --preset -M visual -m default y kill-selection yank end-selection force-repaint
35	35	-----> bind -s --preset -M visual -m default '"*y' "commandline -s | xsel -p; commandline -f end-selection force-repaint"
24	24	-----> bind -s --preset -M visual -m default \cc end-selection force-repaint
25	25	-----> bind -s --preset -M visual -m default \e end-selection force-repaint
25	25	-----> bind -s --preset -M default \# __fish_toggle_comment_commandline
24	24	-----> bind -s --preset -M visual \# __fish_toggle_comment_commandline
132	1145	-----> fish_vi_cursor
149	162	------> source /Users/nathan/.config/fish/functions/fish_vi_cursor.fish
13	13	-------> function fish_vi_cursor --on-variable fish_bind_mode
    if set -q __last_fish_bind_mode
        and test $__last_fish_bind_mode = $fish_bind_mode
        return
    end
    set -g __last_fish_bind_mode $fish_bind_mode
    switch $fish_bind_mode
        case insert
            printf '\e]50;CursorShape=1\x7'
        case default
            printf '\e]50;CursorShape=0\x7'
        case "*"
            printf '\e]50;CursorShape=0\x7'
    end
...
4	25	------> if set -q __last_fish_bind_mode
        and test $__last_fish_bind_mode = $fish_bind_mode
        return
    ...
21	21	-------> set -q __last_fish_bind_mode
24	24	------> set -g __last_fish_bind_mode $fish_bind_mode
57	802	------> switch $fish_bind_mode
        case insert
            printf '\e]50;CursorShape=1\x7'
        case default
            printf '\e]50;CursorShape=0\x7'
        case "*"
            printf '\e]50;CursorShape=0\x7'
    ...
745	745	-------> printf '\e]50;CursorShape=0\x7'
79	275	-----> set fish_bind_mode $init_mode
57	196	------> fish_vi_cursor VARIABLE SET fish_bind_mode
5	62	-------> if set -q __last_fish_bind_mode
        and test $__last_fish_bind_mode = $fish_bind_mode
        return
    ...
30	30	--------> set -q __last_fish_bind_mode
27	27	--------> test $__last_fish_bind_mode = $fish_bind_mode
23	23	-------> set -g __last_fish_bind_mode $fish_bind_mode
25	54	-------> switch $fish_bind_mode
        case insert
            printf '\e]50;CursorShape=1\x7'
        case default
            printf '\e]50;CursorShape=0\x7'
        case "*"
            printf '\e]50;CursorShape=0\x7'
    ...
29	29	--------> printf '\e]50;CursorShape=1\x7'
10	14853	---> if functions --query fish_user_key_bindings >/dev/null
            fish_user_key_bindings 2>/dev/null
        ...
139	276	----> functions --query fish_user_key_bindings >/dev/null
122	137	-----> source /Users/nathan/.config/fish/functions/fish_user_key_bindings.fish
15	15	------> function fish_user_key_bindings -d "Custom keybindings"
  fish_vi_key_bindings
...
56	14567	----> fish_user_key_bindings 2>/dev/null
311	14511	-----> fish_vi_key_bindings
5	49	------> if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    ...
26	26	-------> contains -- -h $argv
18	18	-------> contains -- --help $argv
18	18	------> set -l rebind true
7	249	------> if test "$argv[1]" = "--no-erase"
        set rebind false
        set -e argv[1]
    else
        bind --erase --all --preset # clear earlier bindings, if any
    ...
23	23	-------> test "$argv[1]" = "--no-erase"
219	219	-------> bind --erase --all --preset
3	34	------> if test "$fish_key_bindings" != "fish_vi_key_bindings"
        and test "$rebind" = "true"
        # Allow the user to set the variable universally.
        set -q fish_key_bindings
        or set -g fish_key_bindings
        # This triggers the handler, which calls us again and ensures the user_key_bindings
        # are executed.
        set fish_key_bindings fish_vi_key_bindings
        return
    ...
31	31	-------> test "$fish_key_bindings" != "fish_vi_key_bindings"
18	18	------> set -q fish_escape_delay_ms
18	18	------> set -l init_mode insert
19	19	------> set -l eol_keys \$ g\$
19	19	------> set -l bol_keys \^ 0 g\^
3	38	------> if contains -- $argv[1] insert default visual
        set init_mode $argv[1]
    else if set -q argv[1]
        # We should still go on so the bindings still get set.
        echo "Unknown argument $argv" >&2
    ...
21	21	-------> contains -- $argv[1] insert default visual
14	14	-------> set -q argv[1]
33	9165	------> for mode in insert default visual
        __fish_shared_key_bindings -M $mode
    ...
170	2954	-------> __fish_shared_key_bindings -M $mode
3	41	--------> if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    ...
20	20	---------> contains -- -h $argv
18	18	---------> contains -- --help $argv
24	24	--------> bind --preset $argv \cy yank
23	23	--------> bind --preset $argv \ey yank-pop
26	26	--------> bind --preset $argv -k right forward-char
23	23	--------> bind --preset $argv -k left backward-char
23	23	--------> bind --preset $argv \e\[C forward-char
21	21	--------> bind --preset $argv \e\[D backward-char
20	20	--------> bind --preset $argv \eOC forward-char
19	19	--------> bind --preset $argv \eOD backward-char
22	22	--------> bind --preset $argv -k ppage beginning-of-history
23	23	--------> bind --preset $argv -k npage end-of-history
21	21	--------> bind --preset $argv \cx fish_clipboard_copy
20	20	--------> bind --preset $argv \cv fish_clipboard_paste
21	21	--------> bind --preset $argv \e cancel
21	21	--------> bind --preset $argv \t complete
20	20	--------> bind --preset $argv \cs pager-toggle-search
22	22	--------> bind --preset $argv --key btab complete-and-search
29	29	--------> bind --preset $argv \e\n "commandline -i \n"
25	25	--------> bind --preset $argv \e\r "commandline -i \n"
23	23	--------> bind --preset $argv -k down down-or-search
23	23	--------> bind --preset $argv -k up up-or-search
23	23	--------> bind --preset $argv \e\[A up-or-search
22	22	--------> bind --preset $argv \e\[B down-or-search
48	48	--------> bind --preset $argv \eOA up-or-search
36	36	--------> bind --preset $argv \eOB down-or-search
26	26	--------> bind --preset $argv \e\eOC nextd-or-forward-word
23	23	--------> bind --preset $argv \e\eOD prevd-or-backward-word
22	22	--------> bind --preset $argv \e\e\[C nextd-or-forward-word
22	22	--------> bind --preset $argv \e\e\[D prevd-or-backward-word
23	23	--------> bind --preset $argv \eO3C nextd-or-forward-word
23	23	--------> bind --preset $argv \eO3D prevd-or-backward-word
23	23	--------> bind --preset $argv \e\[3C nextd-or-forward-word
22	22	--------> bind --preset $argv \e\[3D prevd-or-backward-word
23	23	--------> bind --preset $argv \e\[1\;3C nextd-or-forward-word
25	25	--------> bind --preset $argv \e\[1\;3D prevd-or-backward-word
23	23	--------> bind --preset $argv \e\[1\;9C nextd-or-forward-word
23	23	--------> bind --preset $argv \e\[1\;9D prevd-or-backward-word
24	24	--------> bind --preset $argv \e\eOA history-token-search-backward
23	23	--------> bind --preset $argv \e\eOB history-token-search-forward
22	22	--------> bind --preset $argv \e\e\[A history-token-search-backward
23	23	--------> bind --preset $argv \e\e\[B history-token-search-forward
23	23	--------> bind --preset $argv \eO3A history-token-search-backward
23	23	--------> bind --preset $argv \eO3B history-token-search-forward
23	23	--------> bind --preset $argv \e\[3A history-token-search-backward
23	23	--------> bind --preset $argv \e\[3B history-token-search-forward
27	27	--------> bind --preset $argv \e\[1\;3A history-token-search-backward
24	24	--------> bind --preset $argv \e\[1\;3B history-token-search-forward
23	23	--------> bind --preset $argv \e\[1\;9A history-token-search-backward
24	24	--------> bind --preset $argv \e\[1\;9B history-token-search-forward
22	22	--------> bind --preset $argv \e. history-token-search-backward
22	22	--------> bind --preset $argv \el __fish_list_current_token
29	29	--------> bind --preset $argv \ew 'set tok (commandline -pt); if test $tok[1]; echo; whatis $tok[1]; commandline -f repaint; end'
53	53	--------> bind --preset $argv \cl 'echo -n (clear | string replace \e\[3J ""); commandline -f repaint'
33	33	--------> bind --preset $argv \cc __fish_cancel_commandline
24	24	--------> bind --preset $argv \cu backward-kill-line
24	24	--------> bind --preset $argv \cw backward-kill-path-component
26	26	--------> bind --preset $argv \e\[F end-of-line
25	25	--------> bind --preset $argv \e\[H beginning-of-line
30	30	--------> bind --preset $argv \ed 'set -l cmd (commandline); if test -z "$cmd"; echo; dirh; commandline -f repaint; else; commandline -f kill-word; end'
24	24	--------> bind --preset $argv \cd delete-or-exit
27	27	--------> bind --preset $argv -k f1 __fish_man_page
25	25	--------> bind --preset $argv \eh __fish_man_page
25	25	--------> bind --preset $argv \ep '__fish_paginate'
33	33	--------> bind --preset $argv \e\# __fish_toggle_comment_commandline
24	24	--------> bind --preset $argv \ee edit_command_buffer
24	24	--------> bind --preset $argv \ev edit_command_buffer
99	1023	--------> for mode in (bind --list-modes | string match -v paste)
        bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
    ...
824	824	---------> bind --list-modes | string match -v paste
67	67	---------> bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
33	33	---------> bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
25	25	--------> bind --preset -M paste \e\[201~ '__fish_stop_bracketed_paste'
20	20	--------> bind --preset -M paste "" self-insert
23	23	--------> bind --preset -M paste \r "commandline -i \n"
22	22	--------> bind --preset -M paste "'" "__fish_commandline_insert_escaped \' \$__fish_paste_quoted"
22	22	--------> bind --preset -M paste \\ "__fish_commandline_insert_escaped \\\ \$__fish_paste_quoted"
150	2833	-------> __fish_shared_key_bindings -M $mode
4	45	--------> if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    ...
22	22	---------> contains -- -h $argv
19	19	---------> contains -- --help $argv
23	23	--------> bind --preset $argv \cy yank
23	23	--------> bind --preset $argv \ey yank-pop
26	26	--------> bind --preset $argv -k right forward-char
25	25	--------> bind --preset $argv -k left backward-char
25	25	--------> bind --preset $argv \e\[C forward-char
24	24	--------> bind --preset $argv \e\[D backward-char
21	21	--------> bind --preset $argv \eOC forward-char
21	21	--------> bind --preset $argv \eOD backward-char
25	25	--------> bind --preset $argv -k ppage beginning-of-history
25	25	--------> bind --preset $argv -k npage end-of-history
22	22	--------> bind --preset $argv \cx fish_clipboard_copy
22	22	--------> bind --preset $argv \cv fish_clipboard_paste
26	26	--------> bind --preset $argv \e cancel
22	22	--------> bind --preset $argv \t complete
23	23	--------> bind --preset $argv \cs pager-toggle-search
25	25	--------> bind --preset $argv --key btab complete-and-search
25	25	--------> bind --preset $argv \e\n "commandline -i \n"
26	26	--------> bind --preset $argv \e\r "commandline -i \n"
24	24	--------> bind --preset $argv -k down down-or-search
26	26	--------> bind --preset $argv -k up up-or-search
24	24	--------> bind --preset $argv \e\[A up-or-search
25	25	--------> bind --preset $argv \e\[B down-or-search
20	20	--------> bind --preset $argv \eOA up-or-search
21	21	--------> bind --preset $argv \eOB down-or-search
24	24	--------> bind --preset $argv \e\eOC nextd-or-forward-word
24	24	--------> bind --preset $argv \e\eOD prevd-or-backward-word
25	25	--------> bind --preset $argv \e\e\[C nextd-or-forward-word
24	24	--------> bind --preset $argv \e\e\[D prevd-or-backward-word
24	24	--------> bind --preset $argv \eO3C nextd-or-forward-word
24	24	--------> bind --preset $argv \eO3D prevd-or-backward-word
24	24	--------> bind --preset $argv \e\[3C nextd-or-forward-word
23	23	--------> bind --preset $argv \e\[3D prevd-or-backward-word
28	28	--------> bind --preset $argv \e\[1\;3C nextd-or-forward-word
25	25	--------> bind --preset $argv \e\[1\;3D prevd-or-backward-word
26	26	--------> bind --preset $argv \e\[1\;9C nextd-or-forward-word
26	26	--------> bind --preset $argv \e\[1\;9D prevd-or-backward-word
24	24	--------> bind --preset $argv \e\eOA history-token-search-backward
24	24	--------> bind --preset $argv \e\eOB history-token-search-forward
25	25	--------> bind --preset $argv \e\e\[A history-token-search-backward
26	26	--------> bind --preset $argv \e\e\[B history-token-search-forward
26	26	--------> bind --preset $argv \eO3A history-token-search-backward
24	24	--------> bind --preset $argv \eO3B history-token-search-forward
24	24	--------> bind --preset $argv \e\[3A history-token-search-backward
25	25	--------> bind --preset $argv \e\[3B history-token-search-forward
25	25	--------> bind --preset $argv \e\[1\;3A history-token-search-backward
25	25	--------> bind --preset $argv \e\[1\;3B history-token-search-forward
26	26	--------> bind --preset $argv \e\[1\;9A history-token-search-backward
26	26	--------> bind --preset $argv \e\[1\;9B history-token-search-forward
24	24	--------> bind --preset $argv \e. history-token-search-backward
22	22	--------> bind --preset $argv \el __fish_list_current_token
25	25	--------> bind --preset $argv \ew 'set tok (commandline -pt); if test $tok[1]; echo; whatis $tok[1]; commandline -f repaint; end'
25	25	--------> bind --preset $argv \cl 'echo -n (clear | string replace \e\[3J ""); commandline -f repaint'
22	22	--------> bind --preset $argv \cc __fish_cancel_commandline
22	22	--------> bind --preset $argv \cu backward-kill-line
23	23	--------> bind --preset $argv \cw backward-kill-path-component
24	24	--------> bind --preset $argv \e\[F end-of-line
25	25	--------> bind --preset $argv \e\[H beginning-of-line
25	25	--------> bind --preset $argv \ed 'set -l cmd (commandline); if test -z "$cmd"; echo; dirh; commandline -f repaint; else; commandline -f kill-word; end'
22	22	--------> bind --preset $argv \cd delete-or-exit
24	24	--------> bind --preset $argv -k f1 __fish_man_page
23	23	--------> bind --preset $argv \eh __fish_man_page
24	24	--------> bind --preset $argv \ep '__fish_paginate'
23	23	--------> bind --preset $argv \e\# __fish_toggle_comment_commandline
23	23	--------> bind --preset $argv \ee edit_command_buffer
22	22	--------> bind --preset $argv \ev edit_command_buffer
101	967	--------> for mode in (bind --list-modes | string match -v paste)
        bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
    ...
788	788	---------> bind --list-modes | string match -v paste
49	49	---------> bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
29	29	---------> bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
22	22	--------> bind --preset -M paste \e\[201~ '__fish_stop_bracketed_paste'
20	20	--------> bind --preset -M paste "" self-insert
23	23	--------> bind --preset -M paste \r "commandline -i \n"
23	23	--------> bind --preset -M paste "'" "__fish_commandline_insert_escaped \' \$__fish_paste_quoted"
19	19	--------> bind --preset -M paste \\ "__fish_commandline_insert_escaped \\\ \$__fish_paste_quoted"
147	3345	-------> __fish_shared_key_bindings -M $mode
3	44	--------> if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    ...
23	23	---------> contains -- -h $argv
18	18	---------> contains -- --help $argv
23	23	--------> bind --preset $argv \cy yank
23	23	--------> bind --preset $argv \ey yank-pop
27	27	--------> bind --preset $argv -k right forward-char
26	26	--------> bind --preset $argv -k left backward-char
26	26	--------> bind --preset $argv \e\[C forward-char
24	24	--------> bind --preset $argv \e\[D backward-char
23	23	--------> bind --preset $argv \eOC forward-char
20	20	--------> bind --preset $argv \eOD backward-char
26	26	--------> bind --preset $argv -k ppage beginning-of-history
26	26	--------> bind --preset $argv -k npage end-of-history
23	23	--------> bind --preset $argv \cx fish_clipboard_copy
22	22	--------> bind --preset $argv \cv fish_clipboard_paste
23	23	--------> bind --preset $argv \e cancel
22	22	--------> bind --preset $argv \t complete
22	22	--------> bind --preset $argv \cs pager-toggle-search
27	27	--------> bind --preset $argv --key btab complete-and-search
25	25	--------> bind --preset $argv \e\n "commandline -i \n"
25	25	--------> bind --preset $argv \e\r "commandline -i \n"
25	25	--------> bind --preset $argv -k down down-or-search
25	25	--------> bind --preset $argv -k up up-or-search
24	24	--------> bind --preset $argv \e\[A up-or-search
24	24	--------> bind --preset $argv \e\[B down-or-search
21	21	--------> bind --preset $argv \eOA up-or-search
21	21	--------> bind --preset $argv \eOB down-or-search
25	25	--------> bind --preset $argv \e\eOC nextd-or-forward-word
26	26	--------> bind --preset $argv \e\eOD prevd-or-backward-word
25	25	--------> bind --preset $argv \e\e\[C nextd-or-forward-word
24	24	--------> bind --preset $argv \e\e\[D prevd-or-backward-word
25	25	--------> bind --preset $argv \eO3C nextd-or-forward-word
25	25	--------> bind --preset $argv \eO3D prevd-or-backward-word
25	25	--------> bind --preset $argv \e\[3C nextd-or-forward-word
25	25	--------> bind --preset $argv \e\[3D prevd-or-backward-word
35	35	--------> bind --preset $argv \e\[1\;3C nextd-or-forward-word
27	27	--------> bind --preset $argv \e\[1\;3D prevd-or-backward-word
27	27	--------> bind --preset $argv \e\[1\;9C nextd-or-forward-word
27	27	--------> bind --preset $argv \e\[1\;9D prevd-or-backward-word
26	26	--------> bind --preset $argv \e\eOA history-token-search-backward
25	25	--------> bind --preset $argv \e\eOB history-token-search-forward
25	25	--------> bind --preset $argv \e\e\[A history-token-search-backward
26	26	--------> bind --preset $argv \e\e\[B history-token-search-forward
25	25	--------> bind --preset $argv \eO3A history-token-search-backward
26	26	--------> bind --preset $argv \eO3B history-token-search-forward
26	26	--------> bind --preset $argv \e\[3A history-token-search-backward
26	26	--------> bind --preset $argv \e\[3B history-token-search-forward
28	28	--------> bind --preset $argv \e\[1\;3A history-token-search-backward
28	28	--------> bind --preset $argv \e\[1\;3B history-token-search-forward
28	28	--------> bind --preset $argv \e\[1\;9A history-token-search-backward
28	28	--------> bind --preset $argv \e\[1\;9B history-token-search-forward
24	24	--------> bind --preset $argv \e. history-token-search-backward
23	23	--------> bind --preset $argv \el __fish_list_current_token
29	29	--------> bind --preset $argv \ew 'set tok (commandline -pt); if test $tok[1]; echo; whatis $tok[1]; commandline -f repaint; end'
26	26	--------> bind --preset $argv \cl 'echo -n (clear | string replace \e\[3J ""); commandline -f repaint'
23	23	--------> bind --preset $argv \cc __fish_cancel_commandline
23	23	--------> bind --preset $argv \cu backward-kill-line
22	22	--------> bind --preset $argv \cw backward-kill-path-component
26	26	--------> bind --preset $argv \e\[F end-of-line
25	25	--------> bind --preset $argv \e\[H beginning-of-line
27	27	--------> bind --preset $argv \ed 'set -l cmd (commandline); if test -z "$cmd"; echo; dirh; commandline -f repaint; else; commandline -f kill-word; end'
23	23	--------> bind --preset $argv \cd delete-or-exit
26	26	--------> bind --preset $argv -k f1 __fish_man_page
25	25	--------> bind --preset $argv \eh __fish_man_page
25	25	--------> bind --preset $argv \ep '__fish_paginate'
24	24	--------> bind --preset $argv \e\# __fish_toggle_comment_commandline
23	23	--------> bind --preset $argv \ee edit_command_buffer
23	23	--------> bind --preset $argv \ev edit_command_buffer
122	1363	--------> for mode in (bind --list-modes | string match -v paste)
        bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
    ...
994	994	---------> bind --list-modes | string match -v paste
117	117	---------> bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
58	58	---------> bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
72	72	---------> bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
54	54	--------> bind --preset -M paste \e\[201~ '__fish_stop_bracketed_paste'
23	23	--------> bind --preset -M paste "" self-insert
24	24	--------> bind --preset -M paste \r "commandline -i \n"
27	27	--------> bind --preset -M paste "'" "__fish_commandline_insert_escaped \' \$__fish_paste_quoted"
40	40	--------> bind --preset -M paste \\ "__fish_commandline_insert_escaped \\\ \$__fish_paste_quoted"
29	29	------> bind -s --preset -M insert \r execute
49	49	------> bind -s --preset -M insert \n execute
56	56	------> bind -s --preset -M insert "" self-insert
78	78	------> bind -s --preset -M insert \cc __fish_cancel_commandline
72	72	------> bind -s --preset -M insert \e "if commandline -P; commandline -f cancel; else; set fish_bind_mode default; commandline -f backward-char force-repaint; end"
40	40	------> bind -s --preset :q exit
31	31	------> bind -s --preset -m insert \cc __fish_cancel_commandline
25	25	------> bind -s --preset -M default h backward-char
23	23	------> bind -s --preset -M default l forward-char
84	84	------> bind -s --preset -m insert \n execute
54	54	------> bind -s --preset -m insert \r execute
44	44	------> bind -s --preset -m insert i force-repaint
49	49	------> bind -s --preset -m insert I beginning-of-line force-repaint
49	49	------> bind -s --preset -m insert a forward-char force-repaint
45	45	------> bind -s --preset -m insert A end-of-line force-repaint
38	38	------> bind -s --preset -m visual v begin-selection force-repaint
28	28	------> bind -s --preset gg beginning-of-buffer
23	23	------> bind -s --preset G end-of-buffer
34	90	------> for key in $eol_keys
        bind -s --preset $key end-of-line
    ...
30	30	-------> bind -s --preset $key end-of-line
26	26	-------> bind -s --preset $key end-of-line
26	104	------> for key in $bol_keys
        bind -s --preset $key beginning-of-line
    ...
27	27	-------> bind -s --preset $key beginning-of-line
25	25	-------> bind -s --preset $key beginning-of-line
26	26	-------> bind -s --preset $key beginning-of-line
23	23	------> bind -s --preset u history-search-backward
26	26	------> bind -s --preset \cr history-search-forward
26	26	------> bind -s --preset [ history-token-search-backward
24	24	------> bind -s --preset ] history-token-search-forward
33	33	------> bind -s --preset k up-or-search
20	20	------> bind -s --preset j down-or-search
26	26	------> bind -s --preset b backward-word
29	29	------> bind -s --preset B backward-bigword
23	23	------> bind -s --preset ge backward-word
22	22	------> bind -s --preset gE backward-bigword
22	22	------> bind -s --preset w forward-word forward-char
22	22	------> bind -s --preset W forward-bigword forward-char
24	24	------> bind -s --preset e forward-char forward-word backward-char
22	22	------> bind -s --preset E forward-bigword backward-char
38	38	------> bind -s --preset -M insert -k home beginning-of-line 2>/dev/null
28	28	------> bind -s --preset -M default -k home beginning-of-line 2>/dev/null
42	42	------> bind -s --preset -M insert -k end end-of-line 2>/dev/null
40	40	------> bind -s --preset -M default -k end end-of-line 2>/dev/null
26	26	------> bind -s --preset -M default x delete-char forward-char backward-char
22	22	------> bind -s --preset -M default X backward-delete-char
46	46	------> bind -s --preset -M insert -k dc delete-char forward-char backward-char
42	42	------> bind -s --preset -M default -k dc delete-char forward-char backward-char
25	25	------> bind -s --preset -M insert -k backspace backward-delete-char
32	32	------> bind -s --preset -M default -k backspace backward-char
23	23	------> bind -s --preset -M insert \ch backward-delete-char
21	21	------> bind -s --preset -M default \ch backward-char
22	22	------> bind -s --preset -M insert \x7f backward-delete-char
35	35	------> bind -s --preset -M default \x7f backward-char
30	30	------> bind -s --preset -M insert \e\[3\;2~ backward-delete-char
30	30	------> bind -s --preset -M default \e\[3\;2~ backward-delete-char
22	22	------> bind -s --preset dd kill-whole-line
21	21	------> bind -s --preset D kill-line
23	23	------> bind -s --preset d\$ kill-line
23	23	------> bind -s --preset d\^ backward-kill-line
21	21	------> bind -s --preset dw kill-word
21	21	------> bind -s --preset dW kill-bigword
25	25	------> bind -s --preset diw forward-char forward-char backward-word kill-word
25	25	------> bind -s --preset diW forward-char forward-char backward-bigword kill-bigword
26	26	------> bind -s --preset daw forward-char forward-char backward-word kill-word
26	26	------> bind -s --preset daW forward-char forward-char backward-bigword kill-bigword
21	21	------> bind -s --preset de kill-word
21	21	------> bind -s --preset dE kill-bigword
22	22	------> bind -s --preset db backward-kill-word
21	21	------> bind -s --preset dB backward-kill-bigword
22	22	------> bind -s --preset dge backward-kill-word
32	32	------> bind -s --preset dgE backward-kill-bigword
24	24	------> bind -s --preset df begin-selection forward-jump kill-selection end-selection
25	25	------> bind -s --preset dt begin-selection forward-jump backward-char kill-selection end-selection
24	24	------> bind -s --preset dF begin-selection backward-jump kill-selection end-selection
25	25	------> bind -s --preset dT begin-selection backward-jump forward-char kill-selection end-selection
23	23	------> bind -s --preset -m insert s delete-char force-repaint
22	22	------> bind -s --preset -m insert S kill-whole-line force-repaint
23	23	------> bind -s --preset -m insert cc kill-whole-line force-repaint
23	23	------> bind -s --preset -m insert C kill-line force-repaint
25	25	------> bind -s --preset -m insert c\$ kill-line force-repaint
25	25	------> bind -s --preset -m insert c\^ backward-kill-line force-repaint
24	24	------> bind -s --preset -m insert cw kill-word force-repaint
23	23	------> bind -s --preset -m insert cW kill-bigword force-repaint
33	33	------> bind -s --preset -m insert ciw forward-char forward-char backward-word kill-word force-repaint
29	29	------> bind -s --preset -m insert ciW forward-char forward-char backward-bigword kill-bigword force-repaint
28	28	------> bind -s --preset -m insert caw forward-char forward-char backward-word kill-word force-repaint
28	28	------> bind -s --preset -m insert caW forward-char forward-char backward-bigword kill-bigword force-repaint
24	24	------> bind -s --preset -m insert ce kill-word force-repaint
23	23	------> bind -s --preset -m insert cE kill-bigword force-repaint
24	24	------> bind -s --preset -m insert cb backward-kill-word force-repaint
24	24	------> bind -s --preset -m insert cB backward-kill-bigword force-repaint
26	26	------> bind -s --preset -m insert cge backward-kill-word force-repaint
25	25	------> bind -s --preset -m insert cgE backward-kill-bigword force-repaint
22	22	------> bind -s --preset '~' capitalize-word
22	22	------> bind -s --preset gu downcase-word
22	22	------> bind -s --preset gU upcase-word
22	22	------> bind -s --preset J end-of-line delete-char
26	26	------> bind -s --preset K 'man (commandline -t) 2>/dev/null; or echo -n \a'
22	22	------> bind -s --preset yy kill-whole-line yank
21	21	------> bind -s --preset Y kill-whole-line yank
24	24	------> bind -s --preset y\$ kill-line yank
24	24	------> bind -s --preset y\^ backward-kill-line yank
23	23	------> bind -s --preset yw kill-word yank
22	22	------> bind -s --preset yW kill-bigword yank
27	27	------> bind -s --preset yiw forward-char forward-char backward-word kill-word yank
28	28	------> bind -s --preset yiW forward-char forward-char backward-bigword kill-bigword yank
27	27	------> bind -s --preset yaw forward-char forward-char backward-word kill-word yank
27	27	------> bind -s --preset yaW forward-char forward-char backward-bigword kill-bigword yank
23	23	------> bind -s --preset ye kill-word yank
23	23	------> bind -s --preset yE kill-bigword yank
23	23	------> bind -s --preset yb backward-kill-word yank
22	22	------> bind -s --preset yB backward-kill-bigword yank
24	24	------> bind -s --preset yge backward-kill-word yank
27	27	------> bind -s --preset ygE backward-kill-bigword yank
30	30	------> bind -s --preset f forward-jump
20	20	------> bind -s --preset F backward-jump
20	20	------> bind -s --preset t forward-jump-till
20	20	------> bind -s --preset T backward-jump-till
21	21	------> bind -s --preset ';' repeat-jump
19	19	------> bind -s --preset , repeat-jump-reverse
19	19	------> bind -s --preset p yank
20	20	------> bind -s --preset P backward-char yank
21	21	------> bind -s --preset gp yank-pop
27	27	------> bind -s --preset '"*p' "commandline -i ( xsel -p; echo )[1]"
30	30	------> bind -s --preset '"*P' backward-char "commandline -i ( xsel -p; echo )[1]"
21	21	------> bind -s --preset -m replace_one r force-repaint
24	24	------> bind -s --preset -M replace_one -m default '' delete-char self-insert backward-char force-repaint
24	24	------> bind -s --preset -M replace_one -m default \e cancel force-repaint
21	21	------> bind -s --preset -M visual h backward-char
21	21	------> bind -s --preset -M visual l forward-char
20	20	------> bind -s --preset -M visual k up-line
22	22	------> bind -s --preset -M visual j down-line
21	21	------> bind -s --preset -M visual b backward-word
23	23	------> bind -s --preset -M visual B backward-bigword
22	22	------> bind -s --preset -M visual ge backward-word
22	22	------> bind -s --preset -M visual gE backward-bigword
21	21	------> bind -s --preset -M visual w forward-word
21	21	------> bind -s --preset -M visual W forward-bigword
21	21	------> bind -s --preset -M visual e forward-word
21	21	------> bind -s --preset -M visual E forward-bigword
22	22	------> bind -s --preset -M visual o swap-selection-start-stop force-repaint
21	21	------> bind -s --preset -M visual f forward-jump
21	21	------> bind -s --preset -M visual t forward-jump-till
21	21	------> bind -s --preset -M visual F backward-jump
23	23	------> bind -s --preset -M visual T backward-jump-till
24	74	------> for key in $eol_keys
        bind -s --preset -M visual $key end-of-line
    ...
24	24	-------> bind -s --preset -M visual $key end-of-line
26	26	-------> bind -s --preset -M visual $key end-of-line
19	89	------> for key in $bol_keys
        bind -s --preset -M visual $key beginning-of-line
    ...
23	23	-------> bind -s --preset -M visual $key beginning-of-line
23	23	-------> bind -s --preset -M visual $key beginning-of-line
24	24	-------> bind -s --preset -M visual $key beginning-of-line
25	25	------> bind -s --preset -M visual -m insert c kill-selection end-selection force-repaint
24	24	------> bind -s --preset -M visual -m default d kill-selection end-selection force-repaint
24	24	------> bind -s --preset -M visual -m default x kill-selection end-selection force-repaint
24	24	------> bind -s --preset -M visual -m default X kill-whole-line end-selection force-repaint
26	26	------> bind -s --preset -M visual -m default y kill-selection yank end-selection force-repaint
33	33	------> bind -s --preset -M visual -m default '"*y' "commandline -s | xsel -p; commandline -f end-selection force-repaint"
22	22	------> bind -s --preset -M visual -m default \cc end-selection force-repaint
23	23	------> bind -s --preset -M visual -m default \e end-selection force-repaint
23	23	------> bind -s --preset -M default \# __fish_toggle_comment_commandline
22	22	------> bind -s --preset -M visual \# __fish_toggle_comment_commandline
23	88	------> fish_vi_cursor
10	65	-------> if set -q __last_fish_bind_mode
        and test $__last_fish_bind_mode = $fish_bind_mode
        return
    ...
16	16	--------> set -q __last_fish_bind_mode
27	27	--------> test $__last_fish_bind_mode = $fish_bind_mode
12	12	--------> return
41	118	------> set fish_bind_mode $init_mode
17	77	-------> fish_vi_cursor VARIABLE SET fish_bind_mode
10	60	--------> if set -q __last_fish_bind_mode
        and test $__last_fish_bind_mode = $fish_bind_mode
        return
    ...
15	15	---------> set -q __last_fish_bind_mode
24	24	---------> test $__last_fish_bind_mode = $fish_bind_mode
11	11	---------> return
8	98	--> if not set -q FISH_UNIT_TESTS_RUNNING
        # Enable bracketed paste before every prompt (see __fish_shared_bindings for the bindings).
        # Disable it for unit tests so we don't have to add the sequences to bind.expect
        function __fish_enable_bracketed_paste --on-event fish_prompt
            printf "\e[?2004h"
        end

        # Disable BP before every command because that might not support it.
        function __fish_disable_bracketed_paste --on-event fish_preexec --on-event fish_exit
            printf "\e[?2004l"
        end

        # Tell the terminal we support BP. Since we are in __f_c_i, the first fish_prompt
        # has already fired.
        __fish_enable_bracketed_paste
    ...
16	16	---> not set -q FISH_UNIT_TESTS_RUNNING
13	13	---> function __fish_enable_bracketed_paste --on-event fish_prompt
            printf "\e[?2004h"
        ...
12	12	---> function __fish_disable_bracketed_paste --on-event fish_preexec --on-event fish_exit
            printf "\e[?2004l"
        ...
20	49	---> __fish_enable_bracketed_paste
29	29	----> printf "\e[?2004h"
16	16	--> function __fish_winch_handler --on-signal WINCH -d "Repaint screen when window changes size"
        commandline -f repaint >/dev/null 2>/dev/null
    ...
17	17	--> set -q VTE_VERSION
17	17	--> set -l VTE_VERSION 0
14	14	--> set -q TERM_PROGRAM
2	33	--> if test "$VTE_VERSION" -ge 3405 -o "$TERM_PROGRAM" = "Apple_Terminal"
        function __update_cwd_osc --on-variable PWD --description 'Notify capable terminals when $PWD changes'
            if status --is-command-substitution
                or set -q INSIDE_EMACS
                return
            end
            printf \e\]7\;file://\%s\%s\a $hostname (string escape --style=url $PWD)
        end
        __update_cwd_osc # Run once because we might have already inherited a PWD from an old tab
    ...
31	31	---> test "$VTE_VERSION" -ge 3405 -o "$TERM_PROGRAM" = "Apple_Terminal"
15	3640	--> if not type -q __fish_command_not_found_handler
        # Read the OS/Distro from /etc/os-release.
        # This has a "ID=" line that defines the exact distribution,
        # and an "ID_LIKE=" line that defines what it is derived from or otherwise like.
        # For our purposes, we use both.
        set -l os
        if test -r /etc/os-release
            set os (string match -r '^ID(?:_LIKE)?\s*=.*' < /etc/os-release | \
            string replace -r '^ID(?:_LIKE)?\s*=(.*)' '$1' | string trim -c '\'"' | string split " ")
        end

        # First check if we are on OpenSUSE since SUSE's handler has no options
        # but the same name and path as Ubuntu's.
        if contains -- suse $os
            or contains -- sles $os
            and type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/bin/command-not-found $argv[1]
            end
            # Check for Fedora's handler
        else if test -f /usr/libexec/pk-command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/libexec/pk-command-not-found $argv[1]
            end
            # Check in /usr/lib, this is where modern Ubuntus place this command
        else if test -f /usr/lib/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/lib/command-not-found -- $argv[1]
            end
            # Check for NixOS handler
        else if test -f /run/current-system/sw/bin/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /run/current-system/sw/bin/command-not-found $argv
            end
            # Ubuntu Feisty places this command in the regular path instead
        else if type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                command-not-found -- $argv[1]
            end
            # pkgfile is an optional, but official, package on Arch Linux
            # it ships with example handlers for bash and zsh, so we'll follow that format
        else if type -p -q pkgfile
            function __fish_command_not_found_handler --on-event fish_command_not_found
                set -l __packages (pkgfile --binaries --verbose -- $argv[1] 2>/dev/null)
                if test $status -eq 0
                    printf "%s may be found in the following packages:\n" "$argv[1]"
                    printf "  %s\n" $__packages
                else
                    __fish_default_command_not_found_handler $argv[1]
                end
            end
            # Use standard fish command not found handler otherwise
        else
            function __fish_command_not_found_handler --on-event fish_command_not_found
                __fish_default_command_not_found_handler $argv[1]
            end
        end
    ...
146	1475	---> not type -q __fish_command_not_found_handler
400	412	----> source /usr/local/Cellar/fish/3.0.2/share/fish/functions/type.fish
12	12	-----> function type --description 'Print the type of a command'
    # For legacy reasons, no argument simply causes an unsuccessful return.
    set -q argv[1]
    or return 1

    set -l options 'h/help' 'a/all' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
    argparse -n type -x t,p,P $options -- $argv
    or return

    if set -q _flag_help
        __fish_print_help type
        return 0
    end

    set -l res 1
    set -l mode normal
    set -l multi no
    set -l selection all

    # Technically all four of these flags are mutually exclusive. However, we allow -q to be used
    # with the other three because old versions of this function explicitly allowed it by making
    # --quiet have precedence.
    if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    end

    set -q _flag_all
    and set multi yes

    set -q _flag_no_functions
    and set selection files

    # Check all possible types for the remaining arguments.
    for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function with definition\n') $i
                        if isatty stdout
                            functions $i | fish_indent --ansi
                        else
                            functions $i | fish_indent
                        end
                    case type
                        echo (_ 'function')
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    end

    return $res
...
22	22	----> set -q argv[1]
35	35	----> set -l options 'h/help' 'a/all' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
58	58	----> argparse -n type -x t,p,P $options -- $argv
1	18	----> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
17	17	-----> set -q _flag_help
15	15	----> set -l res 1
15	15	----> set -l mode normal
15	15	----> set -l multi no
16	16	----> set -l selection all
6	34	----> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
13	13	-----> set -q _flag_quiet
15	15	-----> set mode quiet
13	13	----> set -q _flag_all
12	12	----> set -q _flag_no_functions
21	648	----> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function with definition\n') $i
                        if isatty stdout
                            functions $i | fish_indent --ansi
                        else
                            functions $i | fish_indent
                        end
                    case type
                        echo (_ 'function')
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
16	16	-----> set -l found 0
9	254	-----> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function with definition\n') $i
                        if isatty stdout
                            functions $i | fish_indent --ansi
                        else
                            functions $i | fish_indent
                        end
                    case type
                        echo (_ 'function')
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
18	18	------> test $selection != files
2	66	------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function with definition\n') $i
                        if isatty stdout
                            functions $i | fish_indent --ansi
                        else
                            functions $i | fish_indent
                        end
                    case type
                        echo (_ 'function')
                end
                if test $multi != yes
                    continue
                end
            ...
64	64	-------> functions -q -- $i
1	161	------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
121	160	-------> contains -- $i (builtin -n)
39	39	--------> builtin -n
18	18	-----> set -l paths
7	288	-----> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
18	18	------> test $multi != yes
41	263	------> set paths (command -s -- $i)
222	222	-------> command -s -- $i
9	9	-----> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
5	42	-----> if test $found = 0
            and test $mode != quiet
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
19	19	------> test $found = 0
18	18	------> test $mode != quiet
16	16	----> return $res
15	15	---> set -l os
3	28	---> if test -r /etc/os-release
            set os (string match -r '^ID(?:_LIKE)?\s*=.*' < /etc/os-release | \
            string replace -r '^ID(?:_LIKE)?\s*=(.*)' '$1' | string trim -c '\'"' | string split " ")
        ...
25	25	----> test -r /etc/os-release
18	2107	---> if contains -- suse $os
            or contains -- sles $os
            and type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/bin/command-not-found $argv[1]
            end
            # Check for Fedora's handler
        else if test -f /usr/libexec/pk-command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/libexec/pk-command-not-found $argv[1]
            end
            # Check in /usr/lib, this is where modern Ubuntus place this command
        else if test -f /usr/lib/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/lib/command-not-found -- $argv[1]
            end
            # Check for NixOS handler
        else if test -f /run/current-system/sw/bin/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /run/current-system/sw/bin/command-not-found $argv
            end
            # Ubuntu Feisty places this command in the regular path instead
        else if type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                command-not-found -- $argv[1]
            end
            # pkgfile is an optional, but official, package on Arch Linux
            # it ships with example handlers for bash and zsh, so we'll follow that format
        else if type -p -q pkgfile
            function __fish_command_not_found_handler --on-event fish_command_not_found
                set -l __packages (pkgfile --binaries --verbose -- $argv[1] 2>/dev/null)
                if test $status -eq 0
                    printf "%s may be found in the following packages:\n" "$argv[1]"
                    printf "  %s\n" $__packages
                else
                    __fish_default_command_not_found_handler $argv[1]
                end
            end
            # Use standard fish command not found handler otherwise
        else
            function __fish_command_not_found_handler --on-event fish_command_not_found
                __fish_default_command_not_found_handler $argv[1]
            end
        ...
19	19	----> contains -- suse $os
16	16	----> contains -- sles $os
18	18	----> test -f /usr/libexec/pk-command-not-found
17	17	----> test -f /usr/lib/command-not-found
16	16	----> test -f /run/current-system/sw/bin/command-not-found
45	1051	----> type -q command-not-found
15	15	-----> set -q argv[1]
33	33	-----> set -l options 'h/help' 'a/all' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
53	53	-----> argparse -n type -x t,p,P $options -- $argv
2	17	-----> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
15	15	------> set -q _flag_help
14	14	-----> set -l res 1
14	14	-----> set -l mode normal
15	15	-----> set -l multi no
15	15	-----> set -l selection all
9	37	-----> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
14	14	------> set -q _flag_quiet
14	14	------> set mode quiet
13	13	-----> set -q _flag_all
12	12	-----> set -q _flag_no_functions
22	750	-----> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function with definition\n') $i
                        if isatty stdout
                            functions $i | fish_indent --ansi
                        else
                            functions $i | fish_indent
                        end
                    case type
                        echo (_ 'function')
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
15	15	------> set -l found 0
10	314	------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function with definition\n') $i
                        if isatty stdout
                            functions $i | fish_indent --ansi
                        else
                            functions $i | fish_indent
                        end
                    case type
                        echo (_ 'function')
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
18	18	-------> test $selection != files
2	62	-------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function with definition\n') $i
                        if isatty stdout
                            functions $i | fish_indent --ansi
                        else
                            functions $i | fish_indent
                        end
                    case type
                        echo (_ 'function')
                end
                if test $multi != yes
                    continue
                end
            ...
60	60	--------> functions -q -- $i
4	224	-------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
184	220	--------> contains -- $i (builtin -n)
36	36	---------> builtin -n
25	25	------> set -l paths
8	318	------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
51	51	-------> test $multi != yes
53	259	-------> set paths (command -s -- $i)
206	206	--------> command -s -- $i
11	11	------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
4	45	------> if test $found = 0
            and test $mode != quiet
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
21	21	-------> test $found = 0
20	20	-------> test $mode != quiet
18	18	-----> return $res
47	941	----> type -p -q pkgfile
17	17	-----> set -q argv[1]
35	35	-----> set -l options 'h/help' 'a/all' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
62	62	-----> argparse -n type -x t,p,P $options -- $argv
1	18	-----> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
17	17	------> set -q _flag_help
16	16	-----> set -l res 1
15	15	-----> set -l mode normal
16	16	-----> set -l multi no
16	16	-----> set -l selection all
7	36	-----> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
14	14	------> set -q _flag_quiet
15	15	------> set mode quiet
14	14	-----> set -q _flag_all
14	14	-----> set -q _flag_no_functions
20	618	-----> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function with definition\n') $i
                        if isatty stdout
                            functions $i | fish_indent --ansi
                        else
                            functions $i | fish_indent
                        end
                    case type
                        echo (_ 'function')
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
16	16	------> set -l found 0
11	262	------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function with definition\n') $i
                        if isatty stdout
                            functions $i | fish_indent --ansi
                        else
                            functions $i | fish_indent
                        end
                    case type
                        echo (_ 'function')
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
19	19	-------> test $selection != files
1	61	-------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function with definition\n') $i
                        if isatty stdout
                            functions $i | fish_indent --ansi
                        else
                            functions $i | fish_indent
                        end
                    case type
                        echo (_ 'function')
                end
                if test $multi != yes
                    continue
                end
            ...
60	60	--------> functions -q -- $i
1	171	-------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
129	170	--------> contains -- $i (builtin -n)
41	41	---------> builtin -n
19	19	------> set -l paths
8	241	------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
19	19	-------> test $multi != yes
43	214	-------> set paths (command -s -- $i)
171	171	--------> command -s -- $i
10	10	------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
4	50	------> if test $found = 0
            and test $mode != quiet
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
28	28	-------> test $found = 0
18	18	-------> test $mode != quiet
17	17	-----> return $res
11	11	----> function __fish_command_not_found_handler --on-event fish_command_not_found
                __fish_default_command_not_found_handler $argv[1]
            ...
22	22	-> functions -e __fish_on_interactive
43	8917	> fish_mode_prompt
26	26	-> set -l last_status $status
26	53	-> iterm2_status $last_status
27	27	--> printf "\033]133;D;%s\007" $argv
14	4861	-> if not functions iterm2_fish_prompt | grep iterm2_prompt_mark > /dev/null
       iterm2_prompt_mark
     ...
587	4775	--> not functions iterm2_fish_prompt | grep iterm2_prompt_mark > /dev/null
128	2472	---> source /usr/local/Cellar/fish/3.0.2/share/fish/functions/grep.fish
75	2344	----> if echo | command grep --color=auto "" >/dev/null 2>&1
    function grep
        command grep --color=auto $argv
    end
...
2256	2256	-----> echo | command grep --color=auto "" >/dev/null 2>&1
13	13	-----> function grep
        command grep --color=auto $argv
    ...
1716	1716	---> command grep --color=auto $argv
33	72	--> iterm2_prompt_mark
39	39	---> printf "\033]133;A\007"
3818	3818	-> sh -c "exit $last_status"
116	116	-> iterm2_fish_mode_prompt
29	47036	> fish_prompt
99	46957	-> printf "%b" (string join "\n" (iterm2_fish_prompt))
81	46858	--> string join "\n" (iterm2_fish_prompt)
32	46777	---> iterm2_fish_prompt
233	46745	----> echo -nes "\n" (_vim_mode) (_user_host_name) (_directory) (_git_status) (_node) (_ruby) '\n› '
103	416	-----> _vim_mode
20	313	------> if test "$fish_key_bindings" = "fish_vi_key_bindings"
    switch $fish_bind_mode
      case default
        set_color --bold red
        echo -n 🅽
      case insert
        set_color --bold green
        echo -n 🅸
      case replace_one
        set_color --bold green
        echo -n 🆁
      case visual
        set_color --bold brmagenta
        echo -n 🆅
    end
    echo " "
    set_color normal
  ...
68	68	-------> test "$fish_key_bindings" = "fish_vi_key_bindings"
21	176	-------> switch $fish_bind_mode
      case default
        set_color --bold red
        echo -n 🅽
      case insert
        set_color --bold green
        echo -n 🅸
      case replace_one
        set_color --bold green
        echo -n 🆁
      case visual
        set_color --bold brmagenta
        echo -n 🆅
    ...
130	130	--------> set_color --bold green
25	25	--------> echo -n 🅸
21	21	-------> echo " "
28	28	-------> set_color normal
73	129	-----> _user_host_name
3	56	------> if test -n "$SSH_TTY"
    switch "$USER"
      case root toor
        set user_color red
      case '*'
        set user_color yellow
    end
    echo -s (set_color --bold $user_color) $USER (set_color normal) ' at ' (set_color --bold blue) (prompt_hostname) (set_color normal) ' '
  ...
53	53	-------> test -n "$SSH_TTY"
65	997	-----> _directory
117	932	------> echo -s 'in ' (set_color --bold cyan) (prompt_pwd) (set_color normal)
36	36	-------> set_color --bold cyan
159	750	-------> prompt_pwd
211	229	--------> source /usr/local/Cellar/fish/3.0.2/share/fish/functions/prompt_pwd.fish
18	18	---------> function prompt_pwd --description "Print the current working directory, shortened to fit the prompt"
    set -l options 'h/help'
    argparse -n prompt_pwd --max-args=0 $options -- $argv
    or return

    if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    end

    # This allows overriding fish_prompt_pwd_dir_length from the outside (global or universal) without leaking it
    set -q fish_prompt_pwd_dir_length
    or set -l fish_prompt_pwd_dir_length 1

    # Replace $HOME with "~"
    set realhome ~
    set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)

    if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    end
...
29	29	--------> set -l options 'h/help'
32	32	--------> argparse -n prompt_pwd --max-args=0 $options -- $argv
2	20	--------> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
18	18	---------> set -q _flag_help
17	17	--------> set -q fish_prompt_pwd_dir_length
46	46	--------> set -l fish_prompt_pwd_dir_length 1
43	43	--------> set realhome ~
50	104	--------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
54	54	---------> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
6	71	--------> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
23	23	---------> [ $fish_prompt_pwd_dir_length -eq 0 ]
42	42	---------> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
29	29	-------> set_color normal
90	44768	-----> _git_status
155	31238	------> set -l branch_name (__fish_git_prompt "%s" | sed 's/ //')
2954	31083	-------> __fish_git_prompt "%s" | sed 's/ //'
2368	4297	--------> source /usr/local/Cellar/fish/3.0.2/share/fish/functions/__fish_git_prompt.fish
16	16	---------> function __fish_git_prompt_show_upstream --description "Helper function for __fish_git_prompt"
    set -q __fish_git_prompt_showupstream
    or set -l __fish_git_prompt_showupstream
    set -l show_upstream $__fish_git_prompt_showupstream
    set -l svn_prefix # For better SVN upstream information
    set -l informative

    set -l svn_url_pattern
    set -l count
    set -l upstream git
    set -l verbose
    set -l name

    # Default to informative if __fish_git_prompt_show_informative_status is set
    if set -q __fish_git_prompt_show_informative_status
        set informative 1
    end

    set -l svn_remote
    # get some config options from git-config
    command git config -z --get-regexp '^(svn-remote\..*\.url|bash\.showupstream)$' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showupstream
                set show_upstream $value
                test -n "$show_upstream"
                or return
            case svn-remote.'*'.url
                set svn_remote $svn_remote $value
                # Avoid adding \| to the beginning to avoid needing #?? later
                if test -n "$svn_url_pattern"
                    set svn_url_pattern $svn_url_pattern"|$value"
                else
                    set svn_url_pattern $value
                end
                set upstream svn+git # default upstream is SVN if available, else git

                # Save the config key (without .url) for later use
                set -l remote_prefix (string replace -r '\.url$' '' -- $key)
                set svn_prefix $svn_prefix $remote_prefix
        end
    end

    # parse configuration variables
    # and clear informative default when needed
    for option in $show_upstream
        switch $option
            case git svn
                set upstream $option
                set -e informative
            case verbose
                set verbose 1
                set -e informative
            case informative
                set informative 1
            case name
                set name 1
            case none
                return
        end
    end

    # Find our upstream
    switch $upstream
        case git
            set upstream '@{upstream}'
        case svn\*
            # get the upstream from the 'git-svn-id: …' in a commit message
            # (git-svn uses essentially the same procedure internally)
            set -l svn_upstream (git log --first-parent -1 --grep="^git-svn-id: \($svn_url_pattern\)" 2>/dev/null)
            if test (count $svn_upstream) -ne 0
                echo $svn_upstream[-1] | read -l __ svn_upstream __
                set svn_upstream (string replace -r '@.*' '' -- $svn_upstream)
                set -l cur_prefix
                for i in (seq (count $svn_remote))
                    set -l remote $svn_remote[$i]
                    set -l mod_upstream (string replace "$remote" "" -- $svn_upstream)
                    if test "$svn_upstream" != "$mod_upstream"
                        # we found a valid remote
                        set svn_upstream $mod_upstream
                        set cur_prefix $svn_prefix[$i]
                        break
                    end
                end

                if test -z "$svn_upstream"
                    # default branch name for checkouts with no layout:
                    if test -n "$GIT_SVN_ID"
                        set upstream $GIT_SVN_ID
                    else
                        set upstream git-svn
                    end
                else
                    set upstream (string replace '/branches' '' -- $svn_upstream | string replace -a '/' '')

                    # Use fetch config to fix upstream
                    set -l fetch_val (command git config "$cur_prefix".fetch)
                    if test -n "$fetch_val"
                        string split -m1 : -- "$fetch_val" | read -l trunk pattern
                        set upstream (string replace -r -- "/$trunk\$" '' $pattern) /$upstream
                    end
                end
            else if test $upstream = svn+git
                set upstream '@{upstream}'
            end
    end

    # Find how many commits we are ahead/behind our upstream
    set count (command git rev-list --count --left-right $upstream...HEAD 2>/dev/null)

    # calculate the result
    if test -n "$verbose"
        # Verbose has a space by default
        set -l prefix "$___fish_git_prompt_char_upstream_prefix"
        # Using two underscore version to check if user explicitly set to nothing
        if not set -q __fish_git_prompt_char_upstream_prefix
            set -l prefix " "
        end

        echo $count | read -l behind ahead
        switch "$count"
            case '' # no upstream
            case "0	0" # equal to upstream
                echo "$prefix$___fish_git_prompt_char_upstream_equal"
            case "0	*" # ahead of upstream
                echo "$prefix$___fish_git_prompt_char_upstream_ahead$ahead"
            case "*	0" # behind upstream
                echo "$prefix$___fish_git_prompt_char_upstream_behind$behind"
            case '*' # diverged from upstream
                echo "$prefix$___fish_git_prompt_char_upstream_diverged$ahead-$behind"
        end
        if test -n "$count" -a -n "$name"
            echo " "(command git rev-parse --abbrev-ref "$upstream" 2>/dev/null)
        end
    else if test -n "$informative"
        echo $count | read -l behind ahead
        switch "$count"
            case '' # no upstream
            case "0	0" # equal to upstream
            case "0	*" # ahead of upstream
                echo "$___fish_git_prompt_char_upstream_prefix$___fish_git_prompt_char_upstream_ahead$ahead"
            case "*	0" # behind upstream
                echo "$___fish_git_prompt_char_upstream_prefix$___fish_git_prompt_char_upstream_behind$behind"
            case '*' # diverged from upstream
                echo "$___fish_git_prompt_char_upstream_prefix$___fish_git_prompt_char_upstream_ahead$ahead$___fish_git_prompt_char_upstream_behind$behind"
        end
    else
        switch "$count"
            case '' # no upstream
            case "0	0" # equal to upstream
                echo "$___fish_git_prompt_char_upstream_prefix$___fish_git_prompt_char_upstream_equal"
            case "0	*" # ahead of upstream
                echo "$___fish_git_prompt_char_upstream_prefix$___fish_git_prompt_char_upstream_ahead"
            case "*	0" # behind upstream
                echo "$___fish_git_prompt_char_upstream_prefix$___fish_git_prompt_char_upstream_behind"
            case '*' # diverged from upstream
                echo "$___fish_git_prompt_char_upstream_prefix$___fish_git_prompt_char_upstream_diverged"
        end
    end
...
9	9	---------> function __fish_git_prompt --description "Prompt function for Git"
    # If git isn't installed, there's nothing we can do
    # Return 1 so the calling prompt can deal with it
    if not command -sq git
        return 1
    end
    set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
    test -n "$repo_info"
    or return

    set -l git_dir $repo_info[1]
    set -l inside_gitdir $repo_info[2]
    set -l bare_repo $repo_info[3]
    set -l inside_worktree $repo_info[4]
    set -q repo_info[5]
    and set -l sha $repo_info[5]

    set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
    set -l r $rbc[1] # current operation
    set -l b $rbc[2] # current branch
    set -l detached $rbc[3]
    set -l w #dirty working directory
    set -l i #staged changes
    set -l s #stashes
    set -l u #untracked
    set -l c $rbc[4] # bare repository
    set -l p #upstream
    set -l informative_status

    if not set -q ___fish_git_prompt_init
        # This takes a while, so it only needs to be done once,
        # and then whenever the configuration changes.
        __fish_git_prompt_validate_chars
        __fish_git_prompt_validate_colors
        set -g ___fish_git_prompt_init
    end

    set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"

    if test "true" = $inside_worktree
        if set -q __fish_git_prompt_show_informative_status
            set informative_status "$space"(__fish_git_prompt_informative_status)
        else
            if set -q __fish_git_prompt_showdirtystate
                set -l config (command git config --bool bash.showDirtyState)
                if test "$config" != "false"
                    set w (__fish_git_prompt_dirty)
                    set i (__fish_git_prompt_staged $sha)
                end
            end

            if set -q __fish_git_prompt_showstashstate
                and test -r $git_dir/refs/stash
                set s $___fish_git_prompt_char_stashstate
            end

            if set -q __fish_git_prompt_showuntrackedfiles
                set -l config (command git config --bool bash.showUntrackedFiles)
                if test "$config" != false
                    set u (__fish_git_prompt_untracked)
                end
            end
        end

        if set -q __fish_git_prompt_showupstream
            or set -q __fish_git_prompt_show_informative_status
            set p (__fish_git_prompt_show_upstream)
        end
    end

    set -l branch_color $___fish_git_prompt_color_branch
    set -l branch_done $___fish_git_prompt_color_branch_done
    if set -q __fish_git_prompt_showcolorhints
        if test $detached = yes
            set branch_color $___fish_git_prompt_color_branch_detached
            set branch_done $___fish_git_prompt_color_branch_detached_done
        end
    end

    if test -n "$w"
        set w "$___fish_git_prompt_color_dirtystate$w$___fish_git_prompt_color_dirtystate_done"
    end
    if test -n "$i"
        set i "$___fish_git_prompt_color_stagedstate$i$___fish_git_prompt_color_stagedstate_done"
    end
    if test -n "$s"
        set s "$___fish_git_prompt_color_stashstate$s$___fish_git_prompt_color_stashstate_done"
    end
    if test -n "$u"
        set u "$___fish_git_prompt_color_untrackedfiles$u$___fish_git_prompt_color_untrackedfiles_done"
    end

    set b (string replace refs/heads/ '' -- $b)
    set -q __fish_git_prompt_shorten_branch_char_suffix
    or set -l __fish_git_prompt_shorten_branch_char_suffix "…"
    if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"; and test (string length "$b") -gt $__fish_git_prompt_shorten_branch_len
        set b (string sub -l "$__fish_git_prompt_shorten_branch_len" "$b")"$__fish_git_prompt_shorten_branch_char_suffix"
    end
    if test -n "$b"
        set b "$branch_color$b$branch_done"
    end

    if test -n "$c"
        set c "$___fish_git_prompt_color_bare$c$___fish_git_prompt_color_bare_done"
    end
    if test -n "$r"
        set r "$___fish_git_prompt_color_merging$r$___fish_git_prompt_color_merging_done"
    end
    if test -n "$p"
        set p "$___fish_git_prompt_color_upstream$p$___fish_git_prompt_color_upstream_done"
    end

    # Formatting
    set -l f "$w$i$s$u"
    if test -n "$f"
        set f "$space$f"
    end
    set -l format $argv[1]
    if test -z "$format"
        set format " (%s)"
    end

    printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
...
10	10	---------> function __fish_git_prompt_staged --description "__fish_git_prompt helper, tells whether or not the current branch has staged files"
    set -l sha $argv[1]

    set -l staged

    if test -n "$sha"
        command git diff-index --cached --quiet HEAD -- 2>/dev/null
        or set staged $___fish_git_prompt_char_stagedstate
    else
        set staged $___fish_git_prompt_char_invalidstate
    end
    echo $staged
...
12	12	---------> function __fish_git_prompt_untracked --description "__fish_git_prompt helper, tells whether or not the current repository has untracked files"
    set -l untracked
    if command git ls-files --others --exclude-standard --directory --no-empty-directory --error-unmatch -- :/ >/dev/null 2>&1
        set untracked $___fish_git_prompt_char_untrackedfiles
    end
    echo $untracked
...
9	9	---------> function __fish_git_prompt_dirty --description "__fish_git_prompt helper, tells whether or not the current branch has tracked, modified files"
    set -l dirty

    set -l os
    command git diff --no-ext-diff --quiet --exit-code 2>/dev/null
    set os $status
    if test $os -ne 0
        set dirty $___fish_git_prompt_char_dirtystate
    end
    echo $dirty
...
35	35	---------> set -g ___fish_git_prompt_status_order stagedstate invalidstate dirtystate untrackedfiles
6	6	---------> function __fish_git_prompt_informative_status

    set -l changedFiles (command git diff --name-status 2>/dev/null | string match -r \\w)
    set -l stagedFiles (command git diff --staged --name-status | string match -r \\w)

    set -l x (count $changedFiles)
    set -l y (count (string match -r "U" -- $changedFiles))
    set -l dirtystate (math $x - $y)
    set -l x (count $stagedFiles)
    set -l invalidstate (count (string match -r "U" -- $stagedFiles))
    set -l stagedstate (math $x - $invalidstate)
    set -l untrackedfiles (command git ls-files --others --exclude-standard | wc -l | string trim)

    set -l info

    # If `math` fails for some reason, assume the state is clean - it's the simpler path
    set -l state (math $dirtystate + $invalidstate + $stagedstate + $untrackedfiles 2>/dev/null)
    if test -z "$state"
        or test "$state" = 0
        set info $___fish_git_prompt_color_cleanstate$___fish_git_prompt_char_cleanstate$___fish_git_prompt_color_cleanstate_done
    else
        for i in $___fish_git_prompt_status_order
            if [ $$i != "0" ]
                set -l color_var ___fish_git_prompt_color_$i
                set -l color_done_var ___fish_git_prompt_color_{$i}_done
                set -l symbol_var ___fish_git_prompt_char_$i

                set -l color $$color_var
                set -l color_done $$color_done_var
                set -l symbol $$symbol_var

                set -l count

                if not set -q __fish_git_prompt_hide_$i
                    set count $$i
                end

                set info "$info$color$symbol$count$color_done"
            end
        end
    end

    echo $info

...
10	10	---------> function __fish_git_prompt_operation_branch_bare --description "__fish_git_prompt helper, returns the current Git operation and branch"
    # This function is passed the full repo_info array
    set -l git_dir $argv[1]
    set -l inside_gitdir $argv[2]
    set -l bare_repo $argv[3]
    set -q argv[5]
    and set -l sha $argv[5]

    set -l branch
    set -l operation
    set -l detached no
    set -l bare
    set -l step
    set -l total
    set -l os

    if test -d $git_dir/rebase-merge
        set branch (cat $git_dir/rebase-merge/head-name 2>/dev/null)
        set step (cat $git_dir/rebase-merge/msgnum 2>/dev/null)
        set total (cat $git_dir/rebase-merge/end 2>/dev/null)
        if test -f $git_dir/rebase-merge/interactive
            set operation "|REBASE-i"
        else
            set operation "|REBASE-m"
        end
    else
        if test -d $git_dir/rebase-apply
            set step (cat $git_dir/rebase-apply/next 2>/dev/null)
            set total (cat $git_dir/rebase-apply/last 2>/dev/null)
            if test -f $git_dir/rebase-apply/rebasing
                set branch (cat $git_dir/rebase-apply/head-name 2>/dev/null)
                set operation "|REBASE"
            else if test -f $git_dir/rebase-apply/applying
                set operation "|AM"
            else
                set operation "|AM/REBASE"
            end
        else if test -f $git_dir/MERGE_HEAD
            set operation "|MERGING"
        else if test -f $git_dir/CHERRY_PICK_HEAD
            set operation "|CHERRY-PICKING"
        else if test -f $git_dir/REVERT_HEAD
            set operation "|REVERTING"
        else if test -f $git_dir/BISECT_LOG
            set operation "|BISECTING"
        end
    end

    if test -n "$step" -a -n "$total"
        set operation "$operation $step/$total"
    end

    if test -z "$branch"
        set branch (command git symbolic-ref HEAD 2>/dev/null; set os $status)
        if test $os -ne 0
            set detached yes
            set branch (switch "$__fish_git_prompt_describe_style"
						case contains
							command git describe --contains HEAD
						case branch
							command git describe --contains --all HEAD
						case describe
							command git describe HEAD
						case default '*'
							command git describe --tags --exact-match HEAD
						end 2>/dev/null; set os $status)
            if test $os -ne 0
                # Shorten the sha ourselves to 8 characters - this should be good for most repositories,
                # and even for large ones it should be good for most commits
                if set -q sha
                    set branch (string match -r '^.{8}' -- $sha)…
                else
                    set branch unknown
                end
            end
            set branch "($branch)"
        end
    end

    if test "true" = $inside_gitdir
        if test "true" = $bare_repo
            set bare "BARE:"
        else
            # Let user know they're inside the git dir of a non-bare repo
            set branch "GIT_DIR!"
        end
    end

    echo $operation
    echo $branch
    echo $detached
    echo $bare
...
5	5	---------> function __fish_git_prompt_set_char
    set -l user_variable_name "$argv[1]"
    set -l char $argv[2]
    set -l user_variable
    if set -q $user_variable_name
        set user_variable $$user_variable_name
    end

    if set -q argv[3]
        and set -q __fish_git_prompt_show_informative_status
        set char $argv[3]
    end

    set -l variable _$user_variable_name
    set -l variable_done "$variable"_done

    if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    end
...
10	10	---------> function __fish_git_prompt_validate_chars --description "__fish_git_prompt helper, checks char variables"

    __fish_git_prompt_set_char __fish_git_prompt_char_cleanstate '✔'
    __fish_git_prompt_set_char __fish_git_prompt_char_dirtystate '*' '✚'
    __fish_git_prompt_set_char __fish_git_prompt_char_invalidstate '#' '✖'
    __fish_git_prompt_set_char __fish_git_prompt_char_stagedstate '+' '●'
    __fish_git_prompt_set_char __fish_git_prompt_char_stashstate '$'
    __fish_git_prompt_set_char __fish_git_prompt_char_stateseparator ' ' '|'
    __fish_git_prompt_set_char __fish_git_prompt_char_untrackedfiles '%' '…'
    __fish_git_prompt_set_char __fish_git_prompt_char_upstream_ahead '>' '↑'
    __fish_git_prompt_set_char __fish_git_prompt_char_upstream_behind '<' '↓'
    __fish_git_prompt_set_char __fish_git_prompt_char_upstream_diverged '<>'
    __fish_git_prompt_set_char __fish_git_prompt_char_upstream_equal '='
    __fish_git_prompt_set_char __fish_git_prompt_char_upstream_prefix ''

...
4	4	---------> function __fish_git_prompt_set_color
    set -l user_variable_name "$argv[1]"
    set -l user_variable
    if set -q $user_variable_name
        set user_variable $$user_variable_name
    end
    set -l user_variable_bright

    set -l default default_done
    switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    end

    set -l variable _$user_variable_name
    set -l variable_done "$variable"_done

    if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    end

...
9	9	---------> function __fish_git_prompt_validate_colors --description "__fish_git_prompt helper, checks color variables"

    # Base color defaults to nothing (must be done first)
    __fish_git_prompt_set_color __fish_git_prompt_color '' ''

    # Normal colors
    __fish_git_prompt_set_color __fish_git_prompt_color_prefix
    __fish_git_prompt_set_color __fish_git_prompt_color_suffix
    __fish_git_prompt_set_color __fish_git_prompt_color_bare
    __fish_git_prompt_set_color __fish_git_prompt_color_merging
    __fish_git_prompt_set_color __fish_git_prompt_color_cleanstate
    __fish_git_prompt_set_color __fish_git_prompt_color_invalidstate
    __fish_git_prompt_set_color __fish_git_prompt_color_upstream

    # Colors with defaults with showcolorhints
    if set -q __fish_git_prompt_showcolorhints
        __fish_git_prompt_set_color __fish_git_prompt_color_flags (set_color --bold blue)
        __fish_git_prompt_set_color __fish_git_prompt_color_branch (set_color green)
        __fish_git_prompt_set_color __fish_git_prompt_color_dirtystate (set_color red)
        __fish_git_prompt_set_color __fish_git_prompt_color_stagedstate (set_color green)
    else
        __fish_git_prompt_set_color __fish_git_prompt_color_flags
        __fish_git_prompt_set_color __fish_git_prompt_color_branch
        __fish_git_prompt_set_color __fish_git_prompt_color_dirtystate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
        __fish_git_prompt_set_color __fish_git_prompt_color_stagedstate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
    end

    # Branch_detached has a default, but is only used with showcolorhints
    __fish_git_prompt_set_color __fish_git_prompt_color_branch_detached (set_color red)

    # Colors that depend on flags color
    __fish_git_prompt_set_color __fish_git_prompt_color_stashstate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
    __fish_git_prompt_set_color __fish_git_prompt_color_untrackedfiles $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done

...
22	22	---------> set -l varargs
61	258	---------> for var in repaint describe_style show_informative_status showdirtystate showstashstate showuntrackedfiles showupstream
    set -a varargs --on-variable __fish_git_prompt_$var
...
26	26	----------> set -a varargs --on-variable __fish_git_prompt_$var
25	25	----------> set -a varargs --on-variable __fish_git_prompt_$var
26	26	----------> set -a varargs --on-variable __fish_git_prompt_$var
29	29	----------> set -a varargs --on-variable __fish_git_prompt_$var
29	29	----------> set -a varargs --on-variable __fish_git_prompt_$var
30	30	----------> set -a varargs --on-variable __fish_git_prompt_$var
32	32	----------> set -a varargs --on-variable __fish_git_prompt_$var
50	50	---------> function __fish_git_prompt_repaint $varargs --description "Event handler, repaints prompt when functionality changes"
    if status --is-interactive
        if test $argv[3] = __fish_git_prompt_show_informative_status
            # Clear characters that have different defaults with/without informative status
            for name in cleanstate dirtystate invalidstate stagedstate stateseparator untrackedfiles upstream_ahead upstream_behind
                set -e ___fish_git_prompt_char_$name
            end
        end

        commandline -f repaint 2>/dev/null
    end
...
23	23	---------> set -l varargs
70	710	---------> for var in '' _prefix _suffix _bare _merging _cleanstate _invalidstate _upstream _flags _branch _dirtystate _stagedstate _branch_detached _stashstate _untrackedfiles
    set -a varargs --on-variable __fish_git_prompt_color$var
...
22	22	----------> set -a varargs --on-variable __fish_git_prompt_color$var
24	24	----------> set -a varargs --on-variable __fish_git_prompt_color$var
25	25	----------> set -a varargs --on-variable __fish_git_prompt_color$var
26	26	----------> set -a varargs --on-variable __fish_git_prompt_color$var
28	28	----------> set -a varargs --on-variable __fish_git_prompt_color$var
30	30	----------> set -a varargs --on-variable __fish_git_prompt_color$var
31	31	----------> set -a varargs --on-variable __fish_git_prompt_color$var
34	34	----------> set -a varargs --on-variable __fish_git_prompt_color$var
37	37	----------> set -a varargs --on-variable __fish_git_prompt_color$var
39	39	----------> set -a varargs --on-variable __fish_git_prompt_color$var
39	39	----------> set -a varargs --on-variable __fish_git_prompt_color$var
39	39	----------> set -a varargs --on-variable __fish_git_prompt_color$var
72	72	----------> set -a varargs --on-variable __fish_git_prompt_color$var
106	106	----------> set -a varargs --on-variable __fish_git_prompt_color$var
88	88	----------> set -a varargs --on-variable __fish_git_prompt_color$var
56	56	---------> set -a varargs --on-variable __fish_git_prompt_showcolorhints
99	99	---------> function __fish_git_prompt_repaint_color $varargs --description "Event handler, repaints prompt when any color changes"
    if status --is-interactive
        set -e ___fish_git_prompt_init
        set -l var $argv[3]
        set -e _$var
        set -e _{$var}_done
        if test $var = __fish_git_prompt_color -o $var = __fish_git_prompt_color_flags -o $var = __fish_git_prompt_showcolorhints
            # reset all the other colors too
            for name in prefix suffix bare merging branch dirtystate stagedstate invalidstate stashstate untrackedfiles upstream flags
                set -e ___fish_git_prompt_color_$name
                set -e ___fish_git_prompt_color_{$name}_done
            end
        end
        commandline -f repaint 2>/dev/null
    end
...
32	32	---------> set -l varargs
65	465	---------> for var in cleanstate dirtystate invalidstate stagedstate stashstate stateseparator untrackedfiles upstream_ahead upstream_behind upstream_diverged upstream_equal upstream_prefix
    set -a varargs --on-variable __fish_git_prompt_char_$var
...
27	27	----------> set -a varargs --on-variable __fish_git_prompt_char_$var
27	27	----------> set -a varargs --on-variable __fish_git_prompt_char_$var
28	28	----------> set -a varargs --on-variable __fish_git_prompt_char_$var
29	29	----------> set -a varargs --on-variable __fish_git_prompt_char_$var
30	30	----------> set -a varargs --on-variable __fish_git_prompt_char_$var
32	32	----------> set -a varargs --on-variable __fish_git_prompt_char_$var
34	34	----------> set -a varargs --on-variable __fish_git_prompt_char_$var
35	35	----------> set -a varargs --on-variable __fish_git_prompt_char_$var
37	37	----------> set -a varargs --on-variable __fish_git_prompt_char_$var
39	39	----------> set -a varargs --on-variable __fish_git_prompt_char_$var
40	40	----------> set -a varargs --on-variable __fish_git_prompt_char_$var
42	42	----------> set -a varargs --on-variable __fish_git_prompt_char_$var
79	79	---------> function __fish_git_prompt_repaint_char $varargs --description "Event handler, repaints prompt when any char changes"
    if status --is-interactive
        set -e ___fish_git_prompt_init
        set -e _$argv[3]
        commandline -f repaint 2>/dev/null
    end
...
4	73	--------> if not command -sq git
        return 1
    ...
69	69	---------> not command -sq git
117	4184	--------> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
4067	4067	---------> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
29	29	--------> test -n "$repo_info"
25	25	--------> set -l git_dir $repo_info[1]
23	23	--------> set -l inside_gitdir $repo_info[2]
22	22	--------> set -l bare_repo $repo_info[3]
22	22	--------> set -l inside_worktree $repo_info[4]
18	18	--------> set -q repo_info[5]
22	22	--------> set -l sha $repo_info[5]
68	5129	--------> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
141	5061	---------> __fish_git_prompt_operation_branch_bare $repo_info
25	25	----------> set -l git_dir $argv[1]
22	22	----------> set -l inside_gitdir $argv[2]
21	21	----------> set -l bare_repo $argv[3]
17	17	----------> set -q argv[5]
20	20	----------> set -l sha $argv[5]
16	16	----------> set -l branch
16	16	----------> set -l operation
17	17	----------> set -l detached no
16	16	----------> set -l bare
15	15	----------> set -l step
16	16	----------> set -l total
15	15	----------> set -l os
40	177	----------> if test -d $git_dir/rebase-merge
        set branch (cat $git_dir/rebase-merge/head-name 2>/dev/null)
        set step (cat $git_dir/rebase-merge/msgnum 2>/dev/null)
        set total (cat $git_dir/rebase-merge/end 2>/dev/null)
        if test -f $git_dir/rebase-merge/interactive
            set operation "|REBASE-i"
        else
            set operation "|REBASE-m"
        end
    else
        if test -d $git_dir/rebase-apply
            set step (cat $git_dir/rebase-apply/next 2>/dev/null)
            set total (cat $git_dir/rebase-apply/last 2>/dev/null)
            if test -f $git_dir/rebase-apply/rebasing
                set branch (cat $git_dir/rebase-apply/head-name 2>/dev/null)
                set operation "|REBASE"
            else if test -f $git_dir/rebase-apply/applying
                set operation "|AM"
            else
                set operation "|AM/REBASE"
            end
        else if test -f $git_dir/MERGE_HEAD
            set operation "|MERGING"
        else if test -f $git_dir/CHERRY_PICK_HEAD
            set operation "|CHERRY-PICKING"
        else if test -f $git_dir/REVERT_HEAD
            set operation "|REVERTING"
        else if test -f $git_dir/BISECT_LOG
            set operation "|BISECTING"
        end
    ...
24	24	-----------> test -d $git_dir/rebase-merge
10	113	-----------> if test -d $git_dir/rebase-apply
            set step (cat $git_dir/rebase-apply/next 2>/dev/null)
            set total (cat $git_dir/rebase-apply/last 2>/dev/null)
            if test -f $git_dir/rebase-apply/rebasing
                set branch (cat $git_dir/rebase-apply/head-name 2>/dev/null)
                set operation "|REBASE"
            else if test -f $git_dir/rebase-apply/applying
                set operation "|AM"
            else
                set operation "|AM/REBASE"
            end
        else if test -f $git_dir/MERGE_HEAD
            set operation "|MERGING"
        else if test -f $git_dir/CHERRY_PICK_HEAD
            set operation "|CHERRY-PICKING"
        else if test -f $git_dir/REVERT_HEAD
            set operation "|REVERTING"
        else if test -f $git_dir/BISECT_LOG
            set operation "|BISECTING"
        ...
22	22	------------> test -d $git_dir/rebase-apply
21	21	------------> test -f $git_dir/MERGE_HEAD
20	20	------------> test -f $git_dir/CHERRY_PICK_HEAD
20	20	------------> test -f $git_dir/REVERT_HEAD
20	20	------------> test -f $git_dir/BISECT_LOG
3	27	----------> if test -n "$step" -a -n "$total"
        set operation "$operation $step/$total"
    ...
24	24	-----------> test -n "$step" -a -n "$total"
21	4391	----------> if test -z "$branch"
        set branch (command git symbolic-ref HEAD 2>/dev/null; set os $status)
        if test $os -ne 0
            set detached yes
            set branch (switch "$__fish_git_prompt_describe_style"
						case contains
							command git describe --contains HEAD
						case branch
							command git describe --contains --all HEAD
						case describe
							command git describe HEAD
						case default '*'
							command git describe --tags --exact-match HEAD
						end 2>/dev/null; set os $status)
            if test $os -ne 0
                # Shorten the sha ourselves to 8 characters - this should be good for most repositories,
                # and even for large ones it should be good for most commits
                if set -q sha
                    set branch (string match -r '^.{8}' -- $sha)…
                else
                    set branch unknown
                end
            end
            set branch "($branch)"
        end
    ...
17	17	-----------> test -z "$branch"
82	4326	-----------> set branch (command git symbolic-ref HEAD 2>/dev/null; set os $status)
4201	4201	------------> command git symbolic-ref HEAD 2>/dev/null
43	43	------------> set os $status
3	27	-----------> if test $os -ne 0
            set detached yes
            set branch (switch "$__fish_git_prompt_describe_style"
						case contains
							command git describe --contains HEAD
						case branch
							command git describe --contains --all HEAD
						case describe
							command git describe HEAD
						case default '*'
							command git describe --tags --exact-match HEAD
						end 2>/dev/null; set os $status)
            if test $os -ne 0
                # Shorten the sha ourselves to 8 characters - this should be good for most repositories,
                # and even for large ones it should be good for most commits
                if set -q sha
                    set branch (string match -r '^.{8}' -- $sha)…
                else
                    set branch unknown
                end
            end
            set branch "($branch)"
        ...
24	24	------------> test $os -ne 0
3	28	----------> if test "true" = $inside_gitdir
        if test "true" = $bare_repo
            set bare "BARE:"
        else
            # Let user know they're inside the git dir of a non-bare repo
            set branch "GIT_DIR!"
        end
    ...
25	25	-----------> test "true" = $inside_gitdir
22	22	----------> echo $operation
22	22	----------> echo $branch
19	19	----------> echo $detached
18	18	----------> echo $bare
24	24	--------> set -l r $rbc[1]
22	22	--------> set -l b $rbc[2]
23	23	--------> set -l detached $rbc[3]
17	17	--------> set -l w
16	16	--------> set -l i
16	16	--------> set -l s
16	16	--------> set -l u
20	20	--------> set -l c $rbc[4]
15	15	--------> set -l p
18	18	--------> set -l informative_status
20	13170	--------> if not set -q ___fish_git_prompt_init
        # This takes a while, so it only needs to be done once,
        # and then whenever the configuration changes.
        __fish_git_prompt_validate_chars
        __fish_git_prompt_validate_colors
        set -g ___fish_git_prompt_init
    ...
34	34	---------> not set -q ___fish_git_prompt_init
109	5032	---------> __fish_git_prompt_validate_chars
122	495	----------> __fish_git_prompt_set_char __fish_git_prompt_char_cleanstate '✔'
30	30	-----------> set -l user_variable_name "$argv[1]"
23	23	-----------> set -l char $argv[2]
18	18	-----------> set -l user_variable
2	23	-----------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
21	21	------------> set -q $user_variable_name
3	20	-----------> if set -q argv[3]
        and set -q __fish_git_prompt_show_informative_status
        set char $argv[3]
    ...
17	17	------------> set -q argv[3]
23	23	-----------> set -l variable _$user_variable_name
38	38	-----------> set -l variable_done "$variable"_done
41	198	-----------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
26	26	------------> not set -q $variable
85	131	------------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
24	24	-------------> set -q $user_variable_name
22	22	-------------> echo $char
70	511	----------> __fish_git_prompt_set_char __fish_git_prompt_char_dirtystate '*' '✚'
25	25	-----------> set -l user_variable_name "$argv[1]"
33	33	-----------> set -l char $argv[2]
42	42	-----------> set -l user_variable
4	61	-----------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
57	57	------------> set -q $user_variable_name
4	43	-----------> if set -q argv[3]
        and set -q __fish_git_prompt_show_informative_status
        set char $argv[3]
    ...
23	23	------------> set -q argv[3]
16	16	------------> set -q __fish_git_prompt_show_informative_status
27	27	-----------> set -l variable _$user_variable_name
28	28	-----------> set -l variable_done "$variable"_done
42	182	-----------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
19	19	------------> not set -q $variable
79	121	------------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
21	21	-------------> set -q $user_variable_name
21	21	-------------> echo $char
63	397	----------> __fish_git_prompt_set_char __fish_git_prompt_char_invalidstate '#' '✖'
26	26	-----------> set -l user_variable_name "$argv[1]"
21	21	-----------> set -l char $argv[2]
18	18	-----------> set -l user_variable
3	22	-----------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
19	19	------------> set -q $user_variable_name
4	35	-----------> if set -q argv[3]
        and set -q __fish_git_prompt_show_informative_status
        set char $argv[3]
    ...
17	17	------------> set -q argv[3]
14	14	------------> set -q __fish_git_prompt_show_informative_status
23	23	-----------> set -l variable _$user_variable_name
23	23	-----------> set -l variable_done "$variable"_done
39	166	-----------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
19	19	------------> not set -q $variable
68	108	------------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
20	20	-------------> set -q $user_variable_name
20	20	-------------> echo $char
60	400	----------> __fish_git_prompt_set_char __fish_git_prompt_char_stagedstate '+' '●'
24	24	-----------> set -l user_variable_name "$argv[1]"
21	21	-----------> set -l char $argv[2]
17	17	-----------> set -l user_variable
2	21	-----------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
19	19	------------> set -q $user_variable_name
4	35	-----------> if set -q argv[3]
        and set -q __fish_git_prompt_show_informative_status
        set char $argv[3]
    ...
16	16	------------> set -q argv[3]
15	15	------------> set -q __fish_git_prompt_show_informative_status
22	22	-----------> set -l variable _$user_variable_name
23	23	-----------> set -l variable_done "$variable"_done
41	177	-----------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
18	18	------------> not set -q $variable
75	118	------------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
22	22	-------------> set -q $user_variable_name
21	21	-------------> echo $char
67	414	----------> __fish_git_prompt_set_char __fish_git_prompt_char_stashstate '$'
28	28	-----------> set -l user_variable_name "$argv[1]"
23	23	-----------> set -l char $argv[2]
18	18	-----------> set -l user_variable
1	23	-----------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
22	22	------------> set -q $user_variable_name
3	21	-----------> if set -q argv[3]
        and set -q __fish_git_prompt_show_informative_status
        set char $argv[3]
    ...
18	18	------------> set -q argv[3]
26	26	-----------> set -l variable _$user_variable_name
25	25	-----------> set -l variable_done "$variable"_done
41	183	-----------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
22	22	------------> not set -q $variable
72	120	------------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
25	25	-------------> set -q $user_variable_name
23	23	-------------> echo $char
71	446	----------> __fish_git_prompt_set_char __fish_git_prompt_char_stateseparator ' ' '|'
29	29	-----------> set -l user_variable_name "$argv[1]"
24	24	-----------> set -l char $argv[2]
19	19	-----------> set -l user_variable
3	23	-----------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
20	20	------------> set -q $user_variable_name
6	41	-----------> if set -q argv[3]
        and set -q __fish_git_prompt_show_informative_status
        set char $argv[3]
    ...
18	18	------------> set -q argv[3]
17	17	------------> set -q __fish_git_prompt_show_informative_status
24	24	-----------> set -l variable _$user_variable_name
25	25	-----------> set -l variable_done "$variable"_done
63	190	-----------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
20	20	------------> not set -q $variable
68	107	------------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
20	20	-------------> set -q $user_variable_name
19	19	-------------> echo $char
60	389	----------> __fish_git_prompt_set_char __fish_git_prompt_char_untrackedfiles '%' '…'
25	25	-----------> set -l user_variable_name "$argv[1]"
21	21	-----------> set -l char $argv[2]
17	17	-----------> set -l user_variable
2	21	-----------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
19	19	------------> set -q $user_variable_name
5	35	-----------> if set -q argv[3]
        and set -q __fish_git_prompt_show_informative_status
        set char $argv[3]
    ...
16	16	------------> set -q argv[3]
14	14	------------> set -q __fish_git_prompt_show_informative_status
21	21	-----------> set -l variable _$user_variable_name
25	25	-----------> set -l variable_done "$variable"_done
41	164	-----------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
19	19	------------> not set -q $variable
63	104	------------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
22	22	-------------> set -q $user_variable_name
19	19	-------------> echo $char
60	385	----------> __fish_git_prompt_set_char __fish_git_prompt_char_upstream_ahead '>' '↑'
25	25	-----------> set -l user_variable_name "$argv[1]"
21	21	-----------> set -l char $argv[2]
17	17	-----------> set -l user_variable
2	21	-----------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
19	19	------------> set -q $user_variable_name
4	34	-----------> if set -q argv[3]
        and set -q __fish_git_prompt_show_informative_status
        set char $argv[3]
    ...
16	16	------------> set -q argv[3]
14	14	------------> set -q __fish_git_prompt_show_informative_status
21	21	-----------> set -l variable _$user_variable_name
22	22	-----------> set -l variable_done "$variable"_done
40	164	-----------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
19	19	------------> not set -q $variable
66	105	------------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
20	20	-------------> set -q $user_variable_name
19	19	-------------> echo $char
61	383	----------> __fish_git_prompt_set_char __fish_git_prompt_char_upstream_behind '<' '↓'
24	24	-----------> set -l user_variable_name "$argv[1]"
20	20	-----------> set -l char $argv[2]
17	17	-----------> set -l user_variable
2	21	-----------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
19	19	------------> set -q $user_variable_name
4	34	-----------> if set -q argv[3]
        and set -q __fish_git_prompt_show_informative_status
        set char $argv[3]
    ...
16	16	------------> set -q argv[3]
14	14	------------> set -q __fish_git_prompt_show_informative_status
21	21	-----------> set -l variable _$user_variable_name
22	22	-----------> set -l variable_done "$variable"_done
38	163	-----------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
19	19	------------> not set -q $variable
67	106	------------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
20	20	-------------> set -q $user_variable_name
19	19	-------------> echo $char
58	372	----------> __fish_git_prompt_set_char __fish_git_prompt_char_upstream_diverged '<>'
24	24	-----------> set -l user_variable_name "$argv[1]"
20	20	-----------> set -l char $argv[2]
16	16	-----------> set -l user_variable
3	22	-----------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
19	19	------------> set -q $user_variable_name
3	19	-----------> if set -q argv[3]
        and set -q __fish_git_prompt_show_informative_status
        set char $argv[3]
    ...
16	16	------------> set -q argv[3]
22	22	-----------> set -l variable _$user_variable_name
26	26	-----------> set -l variable_done "$variable"_done
40	165	-----------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
19	19	------------> not set -q $variable
64	106	------------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
23	23	-------------> set -q $user_variable_name
19	19	-------------> echo $char
56	365	----------> __fish_git_prompt_set_char __fish_git_prompt_char_upstream_equal '='
25	25	-----------> set -l user_variable_name "$argv[1]"
20	20	-----------> set -l char $argv[2]
17	17	-----------> set -l user_variable
2	21	-----------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
19	19	------------> set -q $user_variable_name
2	18	-----------> if set -q argv[3]
        and set -q __fish_git_prompt_show_informative_status
        set char $argv[3]
    ...
16	16	------------> set -q argv[3]
22	22	-----------> set -l variable _$user_variable_name
23	23	-----------> set -l variable_done "$variable"_done
41	163	-----------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
18	18	------------> not set -q $variable
65	104	------------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
19	19	-------------> set -q $user_variable_name
20	20	-------------> echo $char
58	366	----------> __fish_git_prompt_set_char __fish_git_prompt_char_upstream_prefix ''
24	24	-----------> set -l user_variable_name "$argv[1]"
21	21	-----------> set -l char $argv[2]
17	17	-----------> set -l user_variable
2	21	-----------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
19	19	------------> set -q $user_variable_name
1	18	-----------> if set -q argv[3]
        and set -q __fish_git_prompt_show_informative_status
        set char $argv[3]
    ...
17	17	------------> set -q argv[3]
22	22	-----------> set -l variable _$user_variable_name
23	23	-----------> set -l variable_done "$variable"_done
39	162	-----------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
19	19	------------> not set -q $variable
67	104	------------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
19	19	-------------> set -q $user_variable_name
18	18	-------------> echo $char
115	8066	---------> __fish_git_prompt_validate_colors
170	790	----------> __fish_git_prompt_set_color __fish_git_prompt_color '' ''
68	68	-----------> set -l user_variable_name "$argv[1]"
38	38	-----------> set -l user_variable
3	29	-----------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
26	26	------------> set -q $user_variable_name
19	19	-----------> set -l user_variable_bright
21	21	-----------> set -l default default_done
111	244	-----------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
81	81	------------> count $argv
28	28	------------> set default "$argv[2]"
24	24	------------> set default_done "$argv[3]"
25	25	-----------> set -l variable _$user_variable_name
33	33	-----------> set -l variable_done "$variable"_done
23	143	-----------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
21	21	------------> not set -q $variable
26	99	------------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
21	21	-------------> test -n "$user_variable"
27	27	-------------> set -g $variable $default
25	25	-------------> set -g $variable_done $default_done
74	540	----------> __fish_git_prompt_set_color __fish_git_prompt_color_prefix
26	26	-----------> set -l user_variable_name "$argv[1]"
18	18	-----------> set -l user_variable
2	22	-----------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
20	20	------------> set -q $user_variable_name
17	17	-----------> set -l user_variable_bright
18	18	-----------> set -l default default_done
93	167	-----------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
26	26	------------> count $argv
25	25	------------> set default $___fish_git_prompt_color
23	23	------------> set default_done $___fish_git_prompt_color_done
32	32	-----------> set -l variable _$user_variable_name
29	29	-----------> set -l variable_done "$variable"_done
22	137	-----------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
20	20	------------> not set -q $variable
24	95	------------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
20	20	-------------> test -n "$user_variable"
26	26	-------------> set -g $variable $default
25	25	-------------> set -g $variable_done $default_done
71	561	----------> __fish_git_prompt_set_color __fish_git_prompt_color_suffix
26	26	-----------> set -l user_variable_name "$argv[1]"
18	18	-----------> set -l user_variable
2	22	-----------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
20	20	------------> set -q $user_variable_name
17	17	-----------> set -l user_variable_bright
18	18	-----------> set -l default default_done
110	195	-----------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
27	27	------------> count $argv
29	29	------------> set default $___fish_git_prompt_color
29	29	------------> set default_done $___fish_git_prompt_color_done
26	26	-----------> set -l variable _$user_variable_name
25	25	-----------> set -l variable_done "$variable"_done
23	143	-----------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
21	21	------------> not set -q $variable
24	99	------------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
21	21	-------------> test -n "$user_variable"
27	27	-------------> set -g $variable $default
27	27	-------------> set -g $variable_done $default_done
67	538	----------> __fish_git_prompt_set_color __fish_git_prompt_color_bare
27	27	-----------> set -l user_variable_name "$argv[1]"
19	19	-----------> set -l user_variable
3	24	-----------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
21	21	------------> set -q $user_variable_name
19	19	-----------> set -l user_variable_bright
20	20	-----------> set -l default default_done
92	168	-----------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
27	27	------------> count $argv
26	26	------------> set default $___fish_git_prompt_color
23	23	------------> set default_done $___fish_git_prompt_color_done
25	25	-----------> set -l variable _$user_variable_name
25	25	-----------> set -l variable_done "$variable"_done
22	144	-----------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
21	21	------------> not set -q $variable
21	101	------------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
21	21	-------------> test -n "$user_variable"
28	28	-------------> set -g $variable $default
31	31	-------------> set -g $variable_done $default_done
69	497	----------> __fish_git_prompt_set_color __fish_git_prompt_color_merging
26	26	-----------> set -l user_variable_name "$argv[1]"
19	19	-----------> set -l user_variable
2	30	-----------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
28	28	------------> set -q $user_variable_name
17	17	-----------> set -l user_variable_bright
18	18	-----------> set -l default default_done
80	147	-----------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
23	23	------------> count $argv
23	23	------------> set default $___fish_git_prompt_color
21	21	------------> set default_done $___fish_git_prompt_color_done
23	23	-----------> set -l variable _$user_variable_name
22	22	-----------> set -l variable_done "$variable"_done
17	126	-----------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
19	19	------------> not set -q $variable
20	90	------------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
19	19	-------------> test -n "$user_variable"
27	27	-------------> set -g $variable $default
24	24	-------------> set -g $variable_done $default_done
60	475	----------> __fish_git_prompt_set_color __fish_git_prompt_color_cleanstate
24	24	-----------> set -l user_variable_name "$argv[1]"
17	17	-----------> set -l user_variable
2	21	-----------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
19	19	------------> set -q $user_variable_name
17	17	-----------> set -l user_variable_bright
17	17	-----------> set -l default default_done
81	148	-----------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
23	23	------------> count $argv
23	23	------------> set default $___fish_git_prompt_color
21	21	------------> set default_done $___fish_git_prompt_color_done
22	22	-----------> set -l variable _$user_variable_name
26	26	-----------> set -l variable_done "$variable"_done
17	123	-----------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
20	20	------------> not set -q $variable
20	86	------------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
19	19	-------------> test -n "$user_variable"
24	24	-------------> set -g $variable $default
23	23	-------------> set -g $variable_done $default_done
61	476	----------> __fish_git_prompt_set_color __fish_git_prompt_color_invalidstate
24	24	-----------> set -l user_variable_name "$argv[1]"
16	16	-----------> set -l user_variable
2	21	-----------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
19	19	------------> set -q $user_variable_name
16	16	-----------> set -l user_variable_bright
17	17	-----------> set -l default default_done
78	149	-----------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
27	27	------------> count $argv
23	23	------------> set default $___fish_git_prompt_color
21	21	------------> set default_done $___fish_git_prompt_color_done
22	22	-----------> set -l variable _$user_variable_name
22	22	-----------> set -l variable_done "$variable"_done
19	128	-----------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
19	19	------------> not set -q $variable
20	90	------------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
18	18	-------------> test -n "$user_variable"
25	25	-------------> set -g $variable $default
27	27	-------------> set -g $variable_done $default_done
65	486	----------> __fish_git_prompt_set_color __fish_git_prompt_color_upstream
23	23	-----------> set -l user_variable_name "$argv[1]"
17	17	-----------> set -l user_variable
2	21	-----------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
19	19	------------> set -q $user_variable_name
16	16	-----------> set -l user_variable_bright
17	17	-----------> set -l default default_done
83	150	-----------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
24	24	------------> count $argv
22	22	------------> set default $___fish_git_prompt_color
21	21	------------> set default_done $___fish_git_prompt_color_done
23	23	-----------> set -l variable _$user_variable_name
22	22	-----------> set -l variable_done "$variable"_done
18	132	-----------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
19	19	------------> not set -q $variable
22	95	------------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
18	18	-------------> test -n "$user_variable"
30	30	-------------> set -g $variable $default
25	25	-------------> set -g $variable_done $default_done
25	1982	----------> if set -q __fish_git_prompt_showcolorhints
        __fish_git_prompt_set_color __fish_git_prompt_color_flags (set_color --bold blue)
        __fish_git_prompt_set_color __fish_git_prompt_color_branch (set_color green)
        __fish_git_prompt_set_color __fish_git_prompt_color_dirtystate (set_color red)
        __fish_git_prompt_set_color __fish_git_prompt_color_stagedstate (set_color green)
    else
        __fish_git_prompt_set_color __fish_git_prompt_color_flags
        __fish_git_prompt_set_color __fish_git_prompt_color_branch
        __fish_git_prompt_set_color __fish_git_prompt_color_dirtystate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
        __fish_git_prompt_set_color __fish_git_prompt_color_stagedstate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
    ...
16	16	-----------> set -q __fish_git_prompt_showcolorhints
64	480	-----------> __fish_git_prompt_set_color __fish_git_prompt_color_flags
25	25	------------> set -l user_variable_name "$argv[1]"
17	17	------------> set -l user_variable
3	21	------------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
18	18	-------------> set -q $user_variable_name
16	16	------------> set -l user_variable_bright
17	17	------------> set -l default default_done
80	150	------------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
27	27	-------------> count $argv
22	22	-------------> set default $___fish_git_prompt_color
21	21	-------------> set default_done $___fish_git_prompt_color_done
23	23	------------> set -l variable _$user_variable_name
22	22	------------> set -l variable_done "$variable"_done
19	125	------------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
19	19	-------------> not set -q $variable
20	87	-------------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
18	18	--------------> test -n "$user_variable"
25	25	--------------> set -g $variable $default
24	24	--------------> set -g $variable_done $default_done
64	475	-----------> __fish_git_prompt_set_color __fish_git_prompt_color_branch
24	24	------------> set -l user_variable_name "$argv[1]"
17	17	------------> set -l user_variable
3	21	------------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
18	18	-------------> set -q $user_variable_name
16	16	------------> set -l user_variable_bright
17	17	------------> set -l default default_done
79	145	------------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
23	23	-------------> count $argv
22	22	-------------> set default $___fish_git_prompt_color
21	21	-------------> set default_done $___fish_git_prompt_color_done
23	23	------------> set -l variable _$user_variable_name
22	22	------------> set -l variable_done "$variable"_done
18	126	------------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
19	19	-------------> not set -q $variable
21	89	-------------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
18	18	--------------> test -n "$user_variable"
24	24	--------------> set -g $variable $default
26	26	--------------> set -g $variable_done $default_done
69	490	-----------> __fish_git_prompt_set_color __fish_git_prompt_color_dirtystate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
24	24	------------> set -l user_variable_name "$argv[1]"
17	17	------------> set -l user_variable
3	21	------------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
18	18	-------------> set -q $user_variable_name
17	17	------------> set -l user_variable_bright
17	17	------------> set -l default default_done
85	154	------------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
25	25	-------------> count $argv
23	23	-------------> set default "$argv[2]"
21	21	-------------> set default_done "$argv[3]"
22	22	------------> set -l variable _$user_variable_name
22	22	------------> set -l variable_done "$variable"_done
18	127	------------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
19	19	-------------> not set -q $variable
22	90	-------------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
21	21	--------------> test -n "$user_variable"
24	24	--------------> set -g $variable $default
23	23	--------------> set -g $variable_done $default_done
74	496	-----------> __fish_git_prompt_set_color __fish_git_prompt_color_stagedstate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
24	24	------------> set -l user_variable_name "$argv[1]"
17	17	------------> set -l user_variable
1	20	------------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
19	19	-------------> set -q $user_variable_name
17	17	------------> set -l user_variable_bright
17	17	------------> set -l default default_done
83	154	------------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
25	25	-------------> count $argv
24	24	-------------> set default "$argv[2]"
22	22	-------------> set default_done "$argv[3]"
24	24	------------> set -l variable _$user_variable_name
23	23	------------> set -l variable_done "$variable"_done
20	126	------------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
19	19	-------------> not set -q $variable
21	87	-------------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
18	18	--------------> test -n "$user_variable"
24	24	--------------> set -g $variable $default
24	24	--------------> set -g $variable_done $default_done
106	622	----------> __fish_git_prompt_set_color __fish_git_prompt_color_branch_detached (set_color red)
30	30	-----------> set_color red
27	27	-----------> set -l user_variable_name "$argv[1]"
17	17	-----------> set -l user_variable
3	22	-----------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
19	19	------------> set -q $user_variable_name
16	16	-----------> set -l user_variable_bright
17	17	-----------> set -l default default_done
80	212	-----------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
25	25	------------> count $argv
24	24	------------> set default "$argv[2]"
58	83	------------> set default_done (set_color normal)
25	25	-------------> set_color normal
24	24	-----------> set -l variable _$user_variable_name
22	22	-----------> set -l variable_done "$variable"_done
17	129	-----------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
19	19	------------> not set -q $variable
22	93	------------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
19	19	-------------> test -n "$user_variable"
25	25	-------------> set -g $variable $default
27	27	-------------> set -g $variable_done $default_done
73	493	----------> __fish_git_prompt_set_color __fish_git_prompt_color_stashstate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
24	24	-----------> set -l user_variable_name "$argv[1]"
16	16	-----------> set -l user_variable
2	21	-----------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
19	19	------------> set -q $user_variable_name
17	17	-----------> set -l user_variable_bright
17	17	-----------> set -l default default_done
82	152	-----------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
26	26	------------> count $argv
23	23	------------> set default "$argv[2]"
21	21	------------> set default_done "$argv[3]"
24	24	-----------> set -l variable _$user_variable_name
22	22	-----------> set -l variable_done "$variable"_done
18	127	-----------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
18	18	------------> not set -q $variable
21	91	------------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
18	18	-------------> test -n "$user_variable"
28	28	-------------> set -g $variable $default
24	24	-------------> set -g $variable_done $default_done
71	491	----------> __fish_git_prompt_set_color __fish_git_prompt_color_untrackedfiles $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
23	23	-----------> set -l user_variable_name "$argv[1]"
17	17	-----------> set -l user_variable
2	21	-----------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
19	19	------------> set -q $user_variable_name
17	17	-----------> set -l user_variable_bright
17	17	-----------> set -l default default_done
81	154	-----------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
28	28	------------> count $argv
23	23	------------> set default "$argv[2]"
22	22	------------> set default_done "$argv[3]"
23	23	-----------> set -l variable _$user_variable_name
22	22	-----------> set -l variable_done "$variable"_done
20	126	-----------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
19	19	------------> not set -q $variable
20	87	------------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
19	19	-------------> test -n "$user_variable"
25	25	-------------> set -g $variable $default
23	23	-------------> set -g $variable_done $default_done
18	18	---------> set -g ___fish_git_prompt_init
27	27	--------> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
20	246	--------> if test "true" = $inside_worktree
        if set -q __fish_git_prompt_show_informative_status
            set informative_status "$space"(__fish_git_prompt_informative_status)
        else
            if set -q __fish_git_prompt_showdirtystate
                set -l config (command git config --bool bash.showDirtyState)
                if test "$config" != "false"
                    set w (__fish_git_prompt_dirty)
                    set i (__fish_git_prompt_staged $sha)
                end
            end

            if set -q __fish_git_prompt_showstashstate
                and test -r $git_dir/refs/stash
                set s $___fish_git_prompt_char_stashstate
            end

            if set -q __fish_git_prompt_showuntrackedfiles
                set -l config (command git config --bool bash.showUntrackedFiles)
                if test "$config" != false
                    set u (__fish_git_prompt_untracked)
                end
            end
        end

        if set -q __fish_git_prompt_showupstream
            or set -q __fish_git_prompt_show_informative_status
            set p (__fish_git_prompt_show_upstream)
        end
    ...
30	30	---------> test "true" = $inside_worktree
32	156	---------> if set -q __fish_git_prompt_show_informative_status
            set informative_status "$space"(__fish_git_prompt_informative_status)
        else
            if set -q __fish_git_prompt_showdirtystate
                set -l config (command git config --bool bash.showDirtyState)
                if test "$config" != "false"
                    set w (__fish_git_prompt_dirty)
                    set i (__fish_git_prompt_staged $sha)
                end
            end

            if set -q __fish_git_prompt_showstashstate
                and test -r $git_dir/refs/stash
                set s $___fish_git_prompt_char_stashstate
            end

            if set -q __fish_git_prompt_showuntrackedfiles
                set -l config (command git config --bool bash.showUntrackedFiles)
                if test "$config" != false
                    set u (__fish_git_prompt_untracked)
                end
            end
        ...
17	17	----------> set -q __fish_git_prompt_show_informative_status
4	56	----------> if set -q __fish_git_prompt_showdirtystate
                set -l config (command git config --bool bash.showDirtyState)
                if test "$config" != "false"
                    set w (__fish_git_prompt_dirty)
                    set i (__fish_git_prompt_staged $sha)
                end
            ...
52	52	-----------> set -q __fish_git_prompt_showdirtystate
3	30	----------> if set -q __fish_git_prompt_showstashstate
                and test -r $git_dir/refs/stash
                set s $___fish_git_prompt_char_stashstate
            ...
27	27	-----------> set -q __fish_git_prompt_showstashstate
2	21	----------> if set -q __fish_git_prompt_showuntrackedfiles
                set -l config (command git config --bool bash.showUntrackedFiles)
                if test "$config" != false
                    set u (__fish_git_prompt_untracked)
                end
            ...
19	19	-----------> set -q __fish_git_prompt_showuntrackedfiles
5	40	---------> if set -q __fish_git_prompt_showupstream
            or set -q __fish_git_prompt_show_informative_status
            set p (__fish_git_prompt_show_upstream)
        ...
18	18	----------> set -q __fish_git_prompt_showupstream
17	17	----------> set -q __fish_git_prompt_show_informative_status
46	46	--------> set -l branch_color $___fish_git_prompt_color_branch
45	45	--------> set -l branch_done $___fish_git_prompt_color_branch_done
3	23	--------> if set -q __fish_git_prompt_showcolorhints
        if test $detached = yes
            set branch_color $___fish_git_prompt_color_branch_detached
            set branch_done $___fish_git_prompt_color_branch_detached_done
        end
    ...
20	20	---------> set -q __fish_git_prompt_showcolorhints
3	24	--------> if test -n "$w"
        set w "$___fish_git_prompt_color_dirtystate$w$___fish_git_prompt_color_dirtystate_done"
    ...
21	21	---------> test -n "$w"
3	29	--------> if test -n "$i"
        set i "$___fish_git_prompt_color_stagedstate$i$___fish_git_prompt_color_stagedstate_done"
    ...
26	26	---------> test -n "$i"
2	19	--------> if test -n "$s"
        set s "$___fish_git_prompt_color_stashstate$s$___fish_git_prompt_color_stashstate_done"
    ...
17	17	---------> test -n "$s"
1	18	--------> if test -n "$u"
        set u "$___fish_git_prompt_color_untrackedfiles$u$___fish_git_prompt_color_untrackedfiles_done"
    ...
17	17	---------> test -n "$u"
66	99	--------> set b (string replace refs/heads/ '' -- $b)
33	33	---------> string replace refs/heads/ '' -- $b
17	17	--------> set -q __fish_git_prompt_shorten_branch_char_suffix
21	21	--------> set -l __fish_git_prompt_shorten_branch_char_suffix "…"
4	45	--------> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"; and test (string length "$b") -gt $__fish_git_prompt_shorten_branch_len
        set b (string sub -l "$__fish_git_prompt_shorten_branch_len" "$b")"$__fish_git_prompt_shorten_branch_char_suffix"
    ...
41	41	---------> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
18	66	--------> if test -n "$b"
        set b "$branch_color$b$branch_done"
    ...
22	22	---------> test -n "$b"
26	26	---------> set b "$branch_color$b$branch_done"
2	20	--------> if test -n "$c"
        set c "$___fish_git_prompt_color_bare$c$___fish_git_prompt_color_bare_done"
    ...
18	18	---------> test -n "$c"
3	20	--------> if test -n "$r"
        set r "$___fish_git_prompt_color_merging$r$___fish_git_prompt_color_merging_done"
    ...
17	17	---------> test -n "$r"
1	18	--------> if test -n "$p"
        set p "$___fish_git_prompt_color_upstream$p$___fish_git_prompt_color_upstream_done"
    ...
17	17	---------> test -n "$p"
26	26	--------> set -l f "$w$i$s$u"
3	20	--------> if test -n "$f"
        set f "$space$f"
    ...
17	17	---------> test -n "$f"
23	23	--------> set -l format $argv[1]
2	22	--------> if test -z "$format"
        set format " (%s)"
    ...
20	20	---------> test -z "$format"
54	54	--------> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
3	38	------> if test -z $branch_name
    return
  ...
35	35	-------> test -z $branch_name
109	176	------> echo -s (set_color normal) " on "
67	67	-------> set_color normal
130	7809	------> set -l dirty (command git status --porcelain ^/dev/null)
7679	7679	-------> command git status --porcelain ^/dev/null
13	81	------> if test -z "$dirty"
    set_color --bold green
  else
    set_color --bold red
  ...
34	34	-------> test -z "$dirty"
34	34	-------> set_color --bold red
63	89	------> echo -s "$branch_name" (set_color normal)
26	26	-------> set_color normal
103	5180	------> set -l unpushed_changes (git cherry -v ^/dev/null)
5077	5077	-------> git cherry -v ^/dev/null
12	67	------> if test -z "$unpushed_changes"
    return
  ...
37	37	-------> test -z "$unpushed_changes"
18	18	-------> return
91	120	-----> _node
3	29	------> if test -f ./package.json
    echo -s (set_color --bold green) ' ⬢ ' (node -v) (set_color normal)
  ...
26	26	-------> test -f ./package.json
57	82	-----> _ruby
1	25	------> if test -f Gemfile # -o -f Rakefile -o (count *.rb) -gt 0
    echo -s (set_color --bold red) ' 💎 ' (rbenv version-name) (set_color normal)
  ...
24	24	-------> test -f Gemfile
29	50	-> iterm2_prompt_end
21	21	--> printf "\033]133;B\007"
18	148	> fish_title
72	130	-> echo (status current-command) (__fish_pwd)
20	20	--> status current-command
18	38	--> __fish_pwd
20	20	---> pwd
83	150	> __fish_disable_bracketed_paste exit
67	67	-> printf "\e[?2004l"
55	237	> underscore_change VARIABLE SET _
38	182	-> if [ x$_ = xfish ]
      iterm2_precmd
    else
      iterm2_preexec
    ...
57	57	--> [ x$_ = xfish ]
33	87	--> iterm2_preexec
54	54	---> printf "\033]133;C;\007"
70	372	> fish_title exit
151	302	-> echo (status current-command) (__fish_pwd)
66	66	--> status current-command
54	85	--> __fish_pwd
31	31	---> pwd
154	154	> exit
61	163	> __fish_disable_bracketed_paste
102	102	-> printf "\e[?2004l"
