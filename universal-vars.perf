Time	Sum	Command
1185	10424	> builtin source /usr/local/Cellar/fish/3.1.2/share/fish/config.fish
69	69	-> set -g IFS \n\ \t
30	30	-> set -qg __fish_added_user_paths
29	29	-> set -g __fish_added_user_paths
6	32	-> if not set -q __fish_initialized
    set -U __fish_initialized 0
    if set -q __fish_init_2_39_8
        set __fish_initialized 2398
    else if set -q __fish_init_2_3_0
        set __fish_initialized 2300
    end
...
26	26	--> not set -q __fish_initialized
15	15	-> function __fish_default_command_not_found_handler
    printf "fish: Unknown command: %s\n" (string escape -- $argv[1]) >&2
...
9	402	-> if status --is-interactive
    # Enable truecolor/24-bit support for select terminals
    # Ignore Screen and emacs' ansi-term as they swallow the sequences, rendering the text white.
    if not set -q STY
        and not string match -q -- 'eterm*' $TERM
        and begin
            set -q KONSOLE_PROFILE_NAME # KDE's konsole
            or string match -q -- "*:*" $ITERM_SESSION_ID # Supporting versions of iTerm2 will include a colon here
            or string match -q -- "st-*" $TERM # suckless' st
            or test -n "$VTE_VERSION" -a "$VTE_VERSION" -ge 3600 # Should be all gtk3-vte-based terms after version 3.6.0.0
            or test "$COLORTERM" = truecolor -o "$COLORTERM" = 24bit # slang expects this
        end
        # Only set it if it isn't to allow override by setting to 0
        set -q fish_term24bit
        or set -g fish_term24bit 1
    end
else
    # Hook up the default as the principal command_not_found handler
    # in case we are not interactive
    function __fish_command_not_found_handler --on-event fish_command_not_found
        __fish_default_command_not_found_handler $argv
    end
...
30	30	--> status --is-interactive
15	363	--> if not set -q STY
        and not string match -q -- 'eterm*' $TERM
        and begin
            set -q KONSOLE_PROFILE_NAME # KDE's konsole
            or string match -q -- "*:*" $ITERM_SESSION_ID # Supporting versions of iTerm2 will include a colon here
            or string match -q -- "st-*" $TERM # suckless' st
            or test -n "$VTE_VERSION" -a "$VTE_VERSION" -ge 3600 # Should be all gtk3-vte-based terms after version 3.6.0.0
            or test "$COLORTERM" = truecolor -o "$COLORTERM" = 24bit # slang expects this
        end
        # Only set it if it isn't to allow override by setting to 0
        set -q fish_term24bit
        or set -g fish_term24bit 1
    ...
26	26	---> not set -q STY
59	59	---> not string match -q -- 'eterm*' $TERM
20	208	---> begin
            set -q KONSOLE_PROFILE_NAME # KDE's konsole
            or string match -q -- "*:*" $ITERM_SESSION_ID # Supporting versions of iTerm2 will include a colon here
            or string match -q -- "st-*" $TERM # suckless' st
            or test -n "$VTE_VERSION" -a "$VTE_VERSION" -ge 3600 # Should be all gtk3-vte-based terms after version 3.6.0.0
            or test "$COLORTERM" = truecolor -o "$COLORTERM" = 24bit # slang expects this
        ...
26	26	----> set -q KONSOLE_PROFILE_NAME
44	44	----> string match -q -- "*:*" $ITERM_SESSION_ID
31	31	----> string match -q -- "st-*" $TERM
48	48	----> test -n "$VTE_VERSION" -a "$VTE_VERSION" -ge 3600
39	39	----> test "$COLORTERM" = truecolor -o "$COLORTERM" = 24bit
24	24	---> set -q fish_term24bit
31	31	---> set -g fish_term24bit 1
26	26	-> set -l __extra_completionsdir
25	25	-> set -l __extra_functionsdir
25	25	-> set -l __extra_confdir
12	262	-> if test -f $__fish_data_dir/__fish_build_paths.fish
    source $__fish_data_dir/__fish_build_paths.fish
...
47	47	--> test -f $__fish_data_dir/__fish_build_paths.fish
116	203	--> source $__fish_data_dir/__fish_build_paths.fish
34	34	---> set __extra_completionsdir /usr/local/share/fish/vendor_completions.d
27	27	---> set __extra_functionsdir /usr/local/share/fish/vendor_functions.d
26	26	---> set __extra_confdir /usr/local/share/fish/vendor_conf.d
27	27	-> set -l xdg_data_dirs
10	64	-> if set -q XDG_DATA_DIRS
    set --path xdg_data_dirs $XDG_DATA_DIRS
    set xdg_data_dirs (string replace -r '([^/])/$' '$1' -- $xdg_data_dirs)/fish
else
    set xdg_data_dirs $__fish_data_dir
...
23	23	--> set -q XDG_DATA_DIRS
31	31	--> set xdg_data_dirs $__fish_data_dir
32	32	-> set -l vendor_completionsdirs $xdg_data_dirs/vendor_completions.d
30	30	-> set -l vendor_functionsdirs $xdg_data_dirs/vendor_functions.d
30	30	-> set -l vendor_confdirs $xdg_data_dirs/vendor_conf.d
10	80	-> if not contains -- $__extra_completionsdir $vendor_completionsdirs
    set -a vendor_completionsdirs $__extra_completionsdir
...
38	38	--> not contains -- $__extra_completionsdir $vendor_completionsdirs
32	32	--> set -a vendor_completionsdirs $__extra_completionsdir
8	74	-> if not contains -- $__extra_functionsdir $vendor_functionsdirs
    set -a vendor_functionsdirs $__extra_functionsdir
...
32	32	--> not contains -- $__extra_functionsdir $vendor_functionsdirs
34	34	--> set -a vendor_functionsdirs $__extra_functionsdir
7	71	-> if not contains -- $__extra_confdir $vendor_confdirs
    set -a vendor_confdirs $__extra_confdir
...
32	32	--> not contains -- $__extra_confdir $vendor_confdirs
32	32	--> set -a vendor_confdirs $__extra_confdir
8	82	-> if not set -q fish_function_path
    set fish_function_path $__fish_config_dir/functions $__fish_sysconf_dir/functions $vendor_functionsdirs $__fish_data_dir/functions
else if not contains -- $__fish_data_dir/functions $fish_function_path
    set -a fish_function_path $__fish_data_dir/functions
...
23	23	--> not set -q fish_function_path
51	51	--> set fish_function_path $__fish_config_dir/functions $__fish_sysconf_dir/functions $vendor_functionsdirs $__fish_data_dir/functions
10	89	-> if not set -q fish_complete_path
    set fish_complete_path $__fish_config_dir/completions $__fish_sysconf_dir/completions $vendor_completionsdirs $__fish_data_dir/completions $__fish_user_data_dir/generated_completions
else if not contains -- $__fish_data_dir/completions $fish_complete_path
    set -a fish_complete_path $__fish_data_dir/completions
...
23	23	--> not set -q fish_complete_path
56	56	--> set fish_complete_path $__fish_config_dir/completions $__fish_sysconf_dir/completions $vendor_completionsdirs $__fish_data_dir/completions $__fish_user_data_dir/generated_completions
10	10	-> function : -d "no-op function"
    # for compatibility with sh, bash, and others.
    # Often used to insert a comment into a chain of commands without having
    # it eat up the remainder of the line, handy in Makefiles.
    # This command always succeeds
    true
...
3	64	-> if begin; not set -q FISH_UNIT_TESTS_RUNNING; and test -d /usr/xpg4/bin; end
    not contains -- /usr/xpg4/bin $PATH
    and set PATH /usr/xpg4/bin $PATH
...
10	61	--> begin; not set -q FISH_UNIT_TESTS_RUNNING; and test -d /usr/xpg4/bin; ...
25	25	---> not set -q FISH_UNIT_TESTS_RUNNING
26	26	---> test -d /usr/xpg4/bin
14	14	-> function __fish_reconstruct_path -d "Update PATH when fish_user_paths changes" --on-variable fish_user_paths
    set -l local_path $PATH

    for x in $__fish_added_user_paths
        set -l idx (contains --index -- $x $local_path)
        and set -e local_path[$idx]
    end

    set -g __fish_added_user_paths
    if set -q fish_user_paths
        # Explicitly split on ":" because $fish_user_paths might not be a path variable,
        # but $PATH definitely is.
        for x in (string split ":" -- $fish_user_paths[-1..1])
            if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
            end
            set -p local_path $x
        end
    end

    set -xg PATH $local_path
...
26	26	-> function fish_sigtrap_handler --on-signal TRAP --no-scope-shadowing --description "Signal handler for the TRAP signal. Launches a debug prompt."
    breakpoint
...
9	9	-> function __fish_on_interactive --on-event fish_prompt
    __fish_config_interactive
    functions -e __fish_on_interactive
...
268	903	-> __fish_set_locale
417	426	--> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/__fish_set_locale.fish
9	9	---> function __fish_set_locale
    set -l LOCALE_VARS
    set -a LOCALE_VARS LANG LANGUAGE LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE
    set -a LOCALE_VARS LC_MONETARY LC_MESSAGES LC_PAPER LC_NAME LC_ADDRESS
    set -a LOCALE_VARS LC_TELEPHONE LC_MEASUREMENT LC_IDENTIFICATION

    # We check LC_ALL to figure out if we have a locale but we don't set it later. That is because
    # locale.conf doesn't allow it so we should not set it.
    for locale_var in $LOCALE_VARS LC_ALL
        if set -q $locale_var
            return 0
        end
    end

    # Try to extract the locale from the kernel boot commandline. The splitting here is a bit weird,
    # but we operate under the assumption that the locale can't include whitespace. Other whitespace
    # shouldn't concern us, but a quoted "locale.LANG=SOMETHING" as a value to something else might.
    # Here the last definition of a variable takes precedence.
    if test -r /proc/cmdline
        for var in (string match -ra 'locale.[^=]+=\S+' < /proc/cmdline)
            set -l kv (string replace 'locale.' '' -- $var | string split '=')
            # Only set locale variables, not other stuff contained in these files - this also
            # automatically ignores comments.
            if contains -- $kv[1] $LOCALE_VARS
                and set -q kv[2]
                set -gx $kv[1] (string trim -c '\'"' -- $kv[2])
            end
        end
    end

    # Now read the config files we know are used by various OS distros.
    #
    # /etc/sysconfig/i18n is for old Red Hat derivatives (and possibly of no use anymore).
    #
    # /etc/env.d/02locale is from OpenRC.
    #
    # The rest are systemd inventions but also used elsewhere (e.g. Void Linux). systemd's
    # documentation is a bit unclear on this. We merge all the config files (and the commandline),
    # which seems to be what systemd itself does. (I.e. the value for a variable will be taken from
    # the highest-precedence source) We read the systemd files first since they are a newer
    # invention and therefore the rest are likely to be accumulated cruft.
    #
    # NOTE: Slackware puts the locale in /etc/profile.d/lang.sh, which we can't use because it's a
    # full POSIX-shell script.
    set -l user_cfg_dir (set -q XDG_CONFIG_HOME; and echo $XDG_CONFIG_HOME; or echo ~/.config)
    for f in $user_cfg_dir/locale.conf /etc/locale.conf /etc/env.d/02locale /etc/sysconfig/i18n
        if test -r $f
            while read -l kv
                set kv (string split '=' -- $kv)
                if contains -- $kv[1] $LOCALE_VARS
                    and set -q kv[2]
                    # Do not set already set variables again - this makes the merging happen.
                    if not set -q $kv[1]
                        set -gx $kv[1] (string trim -c '\'"' -- $kv[2])
                    end
                end
            end <$f
        end
    end

    # If we really cannot get anything, at least set character encoding to UTF-8.
    for locale_var in $LOCALE_VARS LC_ALL
        if set -q $locale_var
            return 0
        end
    end
    set -gx LC_CTYPE en_US.UTF-8
...
30	30	--> set -l LOCALE_VARS
31	31	--> set -a LOCALE_VARS LANG LANGUAGE LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE
32	32	--> set -a LOCALE_VARS LC_MONETARY LC_MESSAGES LC_PAPER LC_NAME LC_ADDRESS
32	32	--> set -a LOCALE_VARS LC_TELEPHONE LC_MEASUREMENT LC_IDENTIFICATION
28	84	--> for locale_var in $LOCALE_VARS LC_ALL
        if set -q $locale_var
            return 0
        end
    ...
8	56	---> if set -q $locale_var
            return 0
        ...
26	26	----> set -q $locale_var
22	22	----> return 0
14	14	-> function . -d 'Evaluate a file (deprecated, use "source")' --no-scope-shadowing --wraps source
    if [ (count $argv) -eq 0 ] && isatty 0
        echo "source: using source via '.' is deprecated, and stdin doesn't work."\n"Did you mean 'source' or './'?" >&2
        return 1
    else
        source $argv
    end
...
6	45	-> if test $__fish_initialized -lt 2300
    if set -q fish_user_abbreviations
        set -l fab
        for abbr in $fish_user_abbreviations
            set -a fab (string replace -r '^([^ =]+)=(.*)$' '$1 $2' -- $abbr)
        end
        set fish_user_abbreviations $fab
    end
...
39	39	--> test $__fish_initialized -lt 2300
5	28	-> if status --is-login
    if command -sq /usr/libexec/path_helper
        # Adapt construct_path from the macOS /usr/libexec/path_helper
        # executable for fish; see
        # https://opensource.apple.com/source/shell_cmds/shell_cmds-203/path_helper/path_helper.c.auto.html .
        function __fish_macos_set_env -d "set an environment variable like path_helper does (macOS only)"
            set -l result

            # Populate path according to config files
            for path_file in $argv[2] $argv[3]/*
                if [ -f $path_file ]
                    while read -l entry
                        if not contains -- $entry $result
                            test -n "$entry"
                            and set -a result $entry
                        end
                    end <$path_file
                end
            end

            # Merge in any existing path elements
            for existing_entry in $$argv[1]
                if not contains -- $existing_entry $result
                    set -a result $existing_entry
                end
            end

            set -xg $argv[1] $result
        end

        __fish_macos_set_env 'PATH' '/etc/paths' '/etc/paths.d'
        if [ -n "$MANPATH" ]
            __fish_macos_set_env 'MANPATH' '/etc/manpaths' '/etc/manpaths.d'
        end
        functions -e __fish_macos_set_env
    end

    #
    # Put linux consoles in unicode mode.
    #
    if test "$TERM" = linux
        and string match -qir '\.UTF' -- $LANG
        and command -sq unicode_start
        unicode_start
    end
...
23	23	--> status --is-login
38	4116	-> __fish_reconstruct_path
45	45	--> set -l local_path $PATH
15	15	--> for x in $__fish_added_user_paths
        set -l idx (contains --index -- $x $local_path)
        and set -e local_path[$idx]
    ...
26	26	--> set -g __fish_added_user_paths
6	3912	--> if set -q fish_user_paths
        # Explicitly split on ":" because $fish_user_paths might not be a path variable,
        # but $PATH definitely is.
        for x in (string split ":" -- $fish_user_paths[-1..1])
            if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
            end
            set -p local_path $x
        end
    ...
22	22	---> set -q fish_user_paths
276	3884	---> for x in (string split ":" -- $fish_user_paths[-1..1])
            if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
            end
            set -p local_path $x
        ...
128	128	----> string split ":" -- $fish_user_paths[-1..1]
13	288	----> if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
            ...
120	239	-----> set -l idx (contains --index -- $x $local_path)
119	119	------> contains --index -- $x $local_path
36	36	-----> set -ga __fish_added_user_paths $x
37	37	----> set -p local_path $x
13	223	----> if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
            ...
114	172	-----> set -l idx (contains --index -- $x $local_path)
58	58	------> contains --index -- $x $local_path
38	38	-----> set -ga __fish_added_user_paths $x
38	38	----> set -p local_path $x
13	223	----> if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
            ...
115	173	-----> set -l idx (contains --index -- $x $local_path)
58	58	------> contains --index -- $x $local_path
37	37	-----> set -ga __fish_added_user_paths $x
38	38	----> set -p local_path $x
13	227	----> if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
            ...
120	175	-----> set -l idx (contains --index -- $x $local_path)
55	55	------> contains --index -- $x $local_path
39	39	-----> set -ga __fish_added_user_paths $x
38	38	----> set -p local_path $x
14	322	----> if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
            ...
151	257	-----> set -l idx (contains --index -- $x $local_path)
106	106	------> contains --index -- $x $local_path
51	51	-----> set -ga __fish_added_user_paths $x
67	67	----> set -p local_path $x
11	261	----> if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
            ...
129	203	-----> set -l idx (contains --index -- $x $local_path)
74	74	------> contains --index -- $x $local_path
47	47	-----> set -ga __fish_added_user_paths $x
42	42	----> set -p local_path $x
15	223	----> if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
            ...
101	164	-----> set -l idx (contains --index -- $x $local_path)
63	63	------> contains --index -- $x $local_path
44	44	-----> set -ga __fish_added_user_paths $x
44	44	----> set -p local_path $x
14	240	----> if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
            ...
107	181	-----> set -l idx (contains --index -- $x $local_path)
74	74	------> contains --index -- $x $local_path
45	45	-----> set -ga __fish_added_user_paths $x
44	44	----> set -p local_path $x
14	290	----> if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
            ...
148	228	-----> set -l idx (contains --index -- $x $local_path)
80	80	------> contains --index -- $x $local_path
48	48	-----> set -ga __fish_added_user_paths $x
50	50	----> set -p local_path $x
14	239	----> if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
            ...
107	179	-----> set -l idx (contains --index -- $x $local_path)
72	72	------> contains --index -- $x $local_path
46	46	-----> set -ga __fish_added_user_paths $x
46	46	----> set -p local_path $x
11	207	----> if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
            ...
85	155	-----> set -l idx (contains --index -- $x $local_path)
70	70	------> contains --index -- $x $local_path
41	41	-----> set -ga __fish_added_user_paths $x
44	44	----> set -p local_path $x
11	204	----> if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
            ...
83	150	-----> set -l idx (contains --index -- $x $local_path)
67	67	------> contains --index -- $x $local_path
43	43	-----> set -ga __fish_added_user_paths $x
45	45	----> set -p local_path $x
80	80	--> set -xg PATH $local_path
7	7	-> function __fish_expand_pid_args
    for arg in $argv
        if string match -qr '^%\d+$' -- $arg
            # set newargv $newargv (jobs -p $arg)
            jobs -p $arg
            if not test $status -eq 0
                return 1
            end
        else
            printf "%s\n" $arg
        end
    end
...
22	72	-> for jobbltn in bg fg wait disown
    function $jobbltn -V jobbltn
        builtin $jobbltn (__fish_expand_pid_args $argv)
    end
...
11	11	--> function $jobbltn -V jobbltn
        builtin $jobbltn (__fish_expand_pid_args $argv)
    ...
9	9	--> function $jobbltn -V jobbltn
        builtin $jobbltn (__fish_expand_pid_args $argv)
    ...
8	8	--> function $jobbltn -V jobbltn
        builtin $jobbltn (__fish_expand_pid_args $argv)
    ...
22	22	--> function $jobbltn -V jobbltn
        builtin $jobbltn (__fish_expand_pid_args $argv)
    ...
4	4	-> function kill
    command kill (__fish_expand_pid_args $argv)
...
45	45	-> set -l sourcelist
496	2388	-> for file in $__fish_config_dir/conf.d/*.fish $__fish_sysconf_dir/conf.d/*.fish $vendor_confdirs/*.fish
    set -l basename (string replace -r '^.*/' '' -- $file)
    contains -- $basename $sourcelist
    and continue
    set sourcelist $sourcelist $basename
    # Also skip non-files or unreadable files.
    # This allows one to use e.g. symlinks to /dev/null to "mask" something (like in systemd).
    [ -f $file -a -r $file ]
    and source $file
...
134	237	--> set -l basename (string replace -r '^.*/' '' -- $file)
103	103	---> string replace -r '^.*/' '' -- $file
39	39	--> contains -- $basename $sourcelist
32	32	--> set sourcelist $sourcelist $basename
65	65	--> [ -f $file -a -r $file ]
166	353	--> source $file
31	31	---> set -q FZF_TMUX_HEIGHT
22	22	---> set -q FZF_DEFAULT_OPTS
52	52	---> set -q FZF_LEGACY_KEYBINDINGS
22	22	---> set -q FZF_DISABLE_KEYBINDINGS
21	21	---> set -q FZF_PREVIEW_FILE_CMD
21	21	---> set -q FZF_PREVIEW_DIR_CMD
18	18	---> function fzf_uninstall -e fzf_uninstall
    # disabled until we figure out a sensible way to ensure user overrides
    # are not erased
    # set -l _vars (set | command grep -E "^FZF.*\$" | command awk '{print $1;}')
    # for var in $_vars
    #     eval (set -e $var)
    # end
...
91	141	--> set -l basename (string replace -r '^.*/' '' -- $file)
50	50	---> string replace -r '^.*/' '' -- $file
37	37	--> contains -- $basename $sourcelist
32	32	--> set sourcelist $sourcelist $basename
60	60	--> [ -f $file -a -r $file ]
240	896	--> source $file
13	645	---> if test "$FZF_DISABLE_KEYBINDINGS" -ne 1
    if test "$FZF_LEGACY_KEYBINDINGS" -eq 1
        bind \ct '__fzf_find_file'
        bind \cr '__fzf_reverse_isearch'
        bind \ec '__fzf_cd'
        bind \eC '__fzf_cd --hidden'
        bind \cg '__fzf_open'
        bind \co '__fzf_open --editor'

        if bind -M insert >/dev/null 2>/dev/null
            bind -M insert \ct '__fzf_find_file'
            bind -M insert \cr '__fzf_reverse_isearch'
            bind -M insert \ec '__fzf_cd'
            bind -M insert \eC '__fzf_cd --hidden'
            bind -M insert \cg '__fzf_open'
            bind -M insert \co '__fzf_open --editor'
        end
    else
        bind \co '__fzf_find_file'
        bind \cr '__fzf_reverse_isearch'
        bind \ec '__fzf_cd'
        bind \eC '__fzf_cd --hidden'
        bind \eO '__fzf_open'
        bind \eo '__fzf_open --editor'

        if bind -M insert >/dev/null 2>/dev/null
            bind -M insert \co '__fzf_find_file'
            bind -M insert \cr '__fzf_reverse_isearch'
            bind -M insert \ec '__fzf_cd'
            bind -M insert \eC '__fzf_cd --hidden'
            bind -M insert \eO '__fzf_open'
            bind -M insert \eo '__fzf_open --editor'
        end
    end

    if set -q FZF_COMPLETE
        bind \t '__fzf_complete'
        if bind -M insert >/dev/null 2>/dev/null
            bind -M insert \t '__fzf_complete'
        end
    end
...
36	36	----> test "$FZF_DISABLE_KEYBINDINGS" -ne 1
23	567	----> if test "$FZF_LEGACY_KEYBINDINGS" -eq 1
        bind \ct '__fzf_find_file'
        bind \cr '__fzf_reverse_isearch'
        bind \ec '__fzf_cd'
        bind \eC '__fzf_cd --hidden'
        bind \cg '__fzf_open'
        bind \co '__fzf_open --editor'

        if bind -M insert >/dev/null 2>/dev/null
            bind -M insert \ct '__fzf_find_file'
            bind -M insert \cr '__fzf_reverse_isearch'
            bind -M insert \ec '__fzf_cd'
            bind -M insert \eC '__fzf_cd --hidden'
            bind -M insert \cg '__fzf_open'
            bind -M insert \co '__fzf_open --editor'
        end
    else
        bind \co '__fzf_find_file'
        bind \cr '__fzf_reverse_isearch'
        bind \ec '__fzf_cd'
        bind \eC '__fzf_cd --hidden'
        bind \eO '__fzf_open'
        bind \eo '__fzf_open --editor'

        if bind -M insert >/dev/null 2>/dev/null
            bind -M insert \co '__fzf_find_file'
            bind -M insert \cr '__fzf_reverse_isearch'
            bind -M insert \ec '__fzf_cd'
            bind -M insert \eC '__fzf_cd --hidden'
            bind -M insert \eO '__fzf_open'
            bind -M insert \eo '__fzf_open --editor'
        end
    ...
27	27	-----> test "$FZF_LEGACY_KEYBINDINGS" -eq 1
87	87	-----> bind \ct '__fzf_find_file'
33	33	-----> bind \cr '__fzf_reverse_isearch'
30	30	-----> bind \ec '__fzf_cd'
28	28	-----> bind \eC '__fzf_cd --hidden'
28	28	-----> bind \cg '__fzf_open'
28	28	-----> bind \co '__fzf_open --editor'
24	283	-----> if bind -M insert >/dev/null 2>/dev/null
            bind -M insert \ct '__fzf_find_file'
            bind -M insert \cr '__fzf_reverse_isearch'
            bind -M insert \ec '__fzf_cd'
            bind -M insert \eC '__fzf_cd --hidden'
            bind -M insert \cg '__fzf_open'
            bind -M insert \co '__fzf_open --editor'
        ...
83	83	------> bind -M insert >/dev/null 2>/dev/null
32	32	------> bind -M insert \ct '__fzf_find_file'
29	29	------> bind -M insert \cr '__fzf_reverse_isearch'
30	30	------> bind -M insert \ec '__fzf_cd'
29	29	------> bind -M insert \eC '__fzf_cd --hidden'
28	28	------> bind -M insert \cg '__fzf_open'
28	28	------> bind -M insert \co '__fzf_open --editor'
5	29	----> if set -q FZF_COMPLETE
        bind \t '__fzf_complete'
        if bind -M insert >/dev/null 2>/dev/null
            bind -M insert \t '__fzf_complete'
        end
    ...
24	24	-----> set -q FZF_COMPLETE
11	11	---> function fzf_key_bindings_uninstall -e fzf_key_bindings_uninstall
    # disabled until we figure out a sensible way to ensure user overrides
    # are not erased
    # set -l _bindings (bind -a | sed -En "s/(')?__fzf.*\$//p" | sed 's/bind/bind -e/')
    # for binding in $_bindings
    #     eval $binding
    # end
...
76	76	> builtin source /usr/local/Cellar/fish/3.1.2/etc/fish/config.fish
137	137	> builtin source /Users/nathan/.config/fish/config.fish
86	95	> source /Users/nathan/.config/fish/functions/fish_title.fish
9	9	-> function fish_title
  echo (status current-command)
...
49	272	> fish_title
185	223	-> echo (status current-command)
38	38	--> status current-command
361	415	> source /Users/nathan/.config/fish/functions/fish_prompt.fish
22	22	-> function _user_host_name -d "Displays the user and host name if connected via SSH"
  if test -n "$SSH_TTY"
    switch "$USER"
      case root toor
        set user_color red
      case '*'
        set user_color yellow
    end
    echo -s (set_color --bold $user_color) $USER (set_color normal) ' at ' (set_color --bold blue) (prompt_hostname) (set_color normal) ' '
  end
...
8	8	-> function _directory -d "Writes the colorized present working directory"
  echo -s 'in ' (set_color --bold cyan) (prompt_pwd) (set_color normal)
...
8	8	-> function _node -d "Writes the node version if there is a package.json"
  if test -f ./package.json
    echo -s (set_color --bold green) ' ⬢ ' (node -v) (set_color normal)
  end
...
8	8	-> function _git_status -d "Writes the current git status, if there is one."
  set -l branch_name (__fish_git_prompt "%s" | sed 's/ //')
  if test -z $branch_name
    return
  end

  echo -s (set_color normal) " on "
  set -l dirty (command git status --porcelain ^/dev/null)
  if test -z "$dirty"
    set_color --bold green
  else
    set_color --bold red
  end
  echo -s "$branch_name" (set_color normal)

  set -l unpushed_changes (git cherry -v ^/dev/null)
  if test -z "$unpushed_changes"
    return
  end

  echo -s " with " (set_color --bold magenta) "unpushed" (set_color normal)

...
8	8	-> function fish_prompt -d "Write out the prompt"
  echo -nes "\n" (_user_host_name) (_directory) (_git_status) (_node) '\n› '
...
49	16555	> __fish_on_interactive
237	16469	-> __fish_config_interactive
1148	1161	--> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/__fish_config_interactive.fish
13	13	---> function __fish_config_interactive -d "Initializations that should be performed when entering interactive mode"
    if test $__fish_initialized -lt 3000
        # Perform transitions relevant to going from fish 2.x to 3.x.

        # Migrate old universal abbreviations to the new scheme.
        __fish_abbr_old | source
    end

    # Make sure this function is only run once.
    if set -q __fish_config_interactive_done
        return
    end

    set -g __fish_config_interactive_done
    set -g __fish_active_key_bindings

    if not set -q fish_greeting
        set -l line1 (_ 'Welcome to fish, the friendly interactive shell')
        set -l line2 ''
        if test $__fish_initialized -lt 2300
            set line2 \n(_ 'Type `help` for instructions on how to use fish')
        end
        set -U fish_greeting "$line1$line2"
    end

    if set -q fish_private_mode; and string length -q -- $fish_greeting
        set -l line (_ "fish is running in private mode, history will not be persisted.")
        set -g fish_greeting $fish_greeting.\n$line
    end

    # usage: __init_uvar VARIABLE VALUES...
    function __init_uvar -d "Sets a universal variable if it's not already set"
        if not set --query $argv[1]
            set --universal $argv
        end
    end

    #
    # If we are starting up for the first time, set various defaults.
    if test $__fish_initialized -lt 3100

        # Regular syntax highlighting colors
        __init_uvar fish_color_normal normal
        __init_uvar fish_color_command 005fd7
        __init_uvar fish_color_param 00afff
        __init_uvar fish_color_redirection 00afff
        __init_uvar fish_color_comment 990000
        __init_uvar fish_color_error ff0000
        __init_uvar fish_color_escape 00a6b2
        __init_uvar fish_color_operator 00a6b2
        __init_uvar fish_color_end 009900
        __init_uvar fish_color_quote 999900
        __init_uvar fish_color_autosuggestion 555 brblack
        __init_uvar fish_color_user brgreen
        __init_uvar fish_color_host normal
        __init_uvar fish_color_host_remote yellow
        __init_uvar fish_color_valid_path --underline
        __init_uvar fish_color_status red

        __init_uvar fish_color_cwd green
        __init_uvar fish_color_cwd_root red

        # Background color for matching quotes and parenthesis
        __init_uvar fish_color_match --background=brblue

        # Background color for search matches
        __init_uvar fish_color_search_match bryellow --background=brblack

        # Background color for selections
        __init_uvar fish_color_selection white --bold --background=brblack

        # XXX fish_color_cancel was added in 2.6, but this was added to post-2.3 initialization
        # when 2.4 and 2.5 were already released
        __init_uvar fish_color_cancel -r

        # Pager colors
        __init_uvar fish_pager_color_prefix white --bold --underline
        __init_uvar fish_pager_color_completion
        __init_uvar fish_pager_color_description B3A06D yellow
        __init_uvar fish_pager_color_progress brwhite --background=cyan

        #
        # Directory history colors
        #
        __init_uvar fish_color_history_current --bold
    end

    #
    # Generate man page completions if not present.
    #
    # Don't do this if we're being invoked as part of running unit tests.
    if not set -q FISH_UNIT_TESTS_RUNNING
        if not test -d $__fish_user_data_dir/generated_completions
            # Generating completions from man pages needs python (see issue #3588).

            # We cannot simply do `fish_update_completions &` because it is a function.
            # We cannot do `eval` since it is a function.
            # We don't want to call `fish -c` since that is unnecessary and sources config.fish again.
            # Hence we'll call python directly.
            # c_m_p.py should work with any python version.
            set -l update_args -B $__fish_data_dir/tools/create_manpage_completions.py --manpath --cleanup-in '~/.config/fish/completions' --cleanup-in '~/.config/fish/generated_completions'
            for py in python{3,2,}
                if command -sq $py
                    set -l c $py $update_args
                    # Run python directly in the background and swallow all output
                    $c (: fish_update_completions: generating completions from man pages) >/dev/null 2>&1 &
                    # Then disown the job so that it continues to run in case of an early exit (#6269)
                    disown 2>&1 >/dev/null
                    break
                end
            end
        end
    end

    #
    # Print a greeting.
    # fish_greeting can be a function (preferred) or a variable.
    #
    if status --is-interactive
        if functions -q fish_greeting
            fish_greeting
        else
            # The greeting used to be skipped when fish_greeting was empty (not just undefined)
            # Keep it that way to not print superfluous newlines on old configuration
            test -n "$fish_greeting"
            and echo $fish_greeting
        end
    end

    #
    # This event handler makes sure the prompt is repainted when
    # fish_color_cwd{,_root} changes value. Like all event handlers, it can't be
    # autoloaded.
    #
    set -l varargs --on-variable fish_key_bindings
    for var in user host cwd{,_root} status
        set -a varargs --on-variable fish_color_$var
    end
    function __fish_repaint $varargs -d "Event handler, repaints the prompt when fish_color_cwd* changes"
        if status --is-interactive
            set -e __fish_prompt_cwd
            commandline -f repaint 2>/dev/null
        end
    end

    #
    # Completions for SysV startup scripts. These aren't bound to any
    # specific command, so they can't be autoloaded.
    #
    if test -d /etc/init.d
        complete -x -p "/etc/init.d/*" -a start --description 'Start service'
        complete -x -p "/etc/init.d/*" -a stop --description 'Stop service'
        complete -x -p "/etc/init.d/*" -a status --description 'Print service status'
        complete -x -p "/etc/init.d/*" -a restart --description 'Stop and then start service'
        complete -x -p "/etc/init.d/*" -a reload --description 'Reload service configuration'
    end

    #
    # We want to show our completions for the [ (test) builtin, but
    # we don't want to create a [.fish. test.fish will not be loaded until
    # the user tries [ interactively.
    #
    complete -c [ --wraps test
    complete -c ! --wraps not

    #
    # Only a few builtins take filenames; initialize the rest with no file completions
    #
    complete -c(builtin -n | string match -rv '(source|cd|exec|realpath|set|\\[|test|for)') --no-files

    # Reload key bindings when binding variable change
    function __fish_reload_key_bindings -d "Reload key bindings when binding variable change" --on-variable fish_key_bindings
        # Make sure some key bindings are set
        __init_uvar fish_key_bindings fish_default_key_bindings

        # Do nothing if the key bindings didn't actually change.
        # This could be because the variable was set to the existing value
        # or because it was a local variable.
        # If fish_key_bindings is empty on the first run, we still need to set the defaults.
        if test "$fish_key_bindings" = "$__fish_active_key_bindings" -a -n "$fish_key_bindings"
            return
        end
        # Check if fish_key_bindings is a valid function.
        # If not, either keep the previous bindings (if any) or revert to default.
        # Also print an error so the user knows.
        if not functions -q "$fish_key_bindings"
            echo "There is no fish_key_bindings function called: '$fish_key_bindings'" >&2
            # We need to see if this is a defined function, otherwise we'd be in an endless loop.
            if functions -q $__fish_active_key_bindings
                echo "Keeping $__fish_active_key_bindings" >&2
                # Set the variable to the old value so this error doesn't happen again.
                set fish_key_bindings $__fish_active_key_bindings
                return 1
            else if functions -q fish_default_key_bindings
                echo "Reverting to default bindings" >&2
                set fish_key_bindings fish_default_key_bindings
                # Return because we are called again
                return 0
            else
                # If we can't even find the default bindings, something is broken.
                # Without it, we would eventually run into the stack size limit, but that'd print hundreds of duplicate lines
                # so we should give up earlier.
                echo "Cannot find fish_default_key_bindings, falling back to very simple bindings." >&2
                echo "Most likely something is wrong with your installation." >&2
                return 0
            end
        end
        set -g __fish_active_key_bindings "$fish_key_bindings"
        set -g fish_bind_mode default
        if test "$fish_key_bindings" = fish_default_key_bindings
            # Redirect stderr per #1155
            fish_default_key_bindings 2>/dev/null
        else
            $fish_key_bindings 2>/dev/null
        end
        # Load user key bindings if they are defined
        if functions --query fish_user_key_bindings >/dev/null
            fish_user_key_bindings 2>/dev/null
        end
    end

    # Load key bindings
    __fish_reload_key_bindings

    if not set -q FISH_UNIT_TESTS_RUNNING
        # Enable bracketed paste before every prompt (see __fish_shared_bindings for the bindings).
        # Disable it for unit tests so we don't have to add the sequences to bind.expect
        function __fish_enable_bracketed_paste --on-event fish_prompt
            printf "\e[?2004h"
        end

        # Disable BP before every command because that might not support it.
        function __fish_disable_bracketed_paste --on-event fish_preexec --on-event fish_exit
            printf "\e[?2004l"
        end

        # Tell the terminal we support BP. Since we are in __f_c_i, the first fish_prompt
        # has already fired.
        __fish_enable_bracketed_paste
    end

    # Similarly, enable TMUX's focus reporting when in tmux.
    # This will be handled by
    # - The keybindings (reading the sequence and triggering an event)
    # - Any listeners (like the vi-cursor)
    if set -q TMUX
        and not set -q FISH_UNIT_TESTS_RUNNING
        function __fish_enable_focus --on-event fish_postexec
            echo -n \e\[\?1004h
        end
        function __fish_disable_focus --on-event fish_preexec
            echo -n \e\[\?1004l
        end
        # Note: Don't call this initially because, even though we're in a fish_prompt event,
        # tmux reacts sooo quickly that we'll still get a sequence before we're prepared for it.
        # So this means that we won't get focus events until you've run at least one command, but that's preferable
        # to always seeing `^[[I` when starting fish.
        # __fish_enable_focus
    end

    function __fish_winch_handler --on-signal WINCH -d "Repaint screen when window changes size"
        commandline -f repaint >/dev/null 2>/dev/null
    end

    # Notify terminals when $PWD changes (issue #906).
    # VTE based terminals, Terminal.app, and iTerm.app (TODO) support this.
    if test 0"$VTE_VERSION" -ge 3405 -o "$TERM_PROGRAM" = "Apple_Terminal" -a (string match -r '\d+' 0"$TERM_PROGRAM_VERSION") -ge 309
        function __update_cwd_osc --on-variable PWD --description 'Notify capable terminals when $PWD changes'
            if status --is-command-substitution || set -q INSIDE_EMACS
                return
            end
            printf \e\]7\;file://%s%s\a $hostname (string escape --style=url $PWD)
        end
        __update_cwd_osc # Run once because we might have already inherited a PWD from an old tab
    end

    ### Command-not-found handlers
    # This can be overridden by defining a new __fish_command_not_found_handler function
    if not type -q __fish_command_not_found_handler
        # Read the OS/Distro from /etc/os-release.
        # This has a "ID=" line that defines the exact distribution,
        # and an "ID_LIKE=" line that defines what it is derived from or otherwise like.
        # For our purposes, we use both.
        set -l os
        if test -r /etc/os-release
            set os (string match -r '^ID(?:_LIKE)?\s*=.*' < /etc/os-release | \
            string replace -r '^ID(?:_LIKE)?\s*=(.*)' '$1' | string trim -c '\'"' | string split " ")
        end

        # First check if we are on OpenSUSE since SUSE's handler has no options
        # but the same name and path as Ubuntu's.
        if contains -- suse $os || contains -- sles $os && type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/bin/command-not-found $argv[1]
            end
            # Check for Fedora's handler
        else if test -f /usr/libexec/pk-command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/libexec/pk-command-not-found $argv[1]
            end
            # Check in /usr/lib, this is where modern Ubuntus place this command
        else if test -f /usr/lib/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/lib/command-not-found -- $argv[1]
            end
            # Check for NixOS handler
        else if test -f /run/current-system/sw/bin/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /run/current-system/sw/bin/command-not-found $argv
            end
            # Ubuntu Feisty places this command in the regular path instead
        else if type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                command-not-found -- $argv[1]
            end
            # pkgfile is an optional, but official, package on Arch Linux
            # it ships with example handlers for bash and zsh, so we'll follow that format
        else if type -p -q pkgfile
            function __fish_command_not_found_handler --on-event fish_command_not_found
                set -l __packages (pkgfile --binaries --verbose -- $argv[1] 2>/dev/null)
                if test $status -eq 0
                    printf "%s may be found in the following packages:\n" "$argv[1]"
                    printf "  %s\n" $__packages
                else
                    __fish_default_command_not_found_handler $argv[1]
                end
            end
            # Use standard fish command not found handler otherwise
        else
            function __fish_command_not_found_handler --on-event fish_command_not_found
                __fish_default_command_not_found_handler $argv[1]
            end
        end
    end

    # Bump this whenever some code below needs to run once when upgrading to a new version.
    # The universal variable __fish_initialized is initialized in share/config.fish.
    set __fish_initialized 3100
...
4	38	--> if test $__fish_initialized -lt 3000
        # Perform transitions relevant to going from fish 2.x to 3.x.

        # Migrate old universal abbreviations to the new scheme.
        __fish_abbr_old | source
    ...
34	34	---> test $__fish_initialized -lt 3000
3	27	--> if set -q __fish_config_interactive_done
        return
    ...
24	24	---> set -q __fish_config_interactive_done
25	25	--> set -g __fish_config_interactive_done
23	23	--> set -g __fish_active_key_bindings
2	23	--> if not set -q fish_greeting
        set -l line1 (_ 'Welcome to fish, the friendly interactive shell')
        set -l line2 ''
        if test $__fish_initialized -lt 2300
            set line2 \n(_ 'Type `help` for instructions on how to use fish')
        end
        set -U fish_greeting "$line1$line2"
    ...
21	21	---> not set -q fish_greeting
3	23	--> if set -q fish_private_mode; and string length -q -- $fish_greeting
        set -l line (_ "fish is running in private mode, history will not be persisted.")
        set -g fish_greeting $fish_greeting.\n$line
    ...
20	20	---> set -q fish_private_mode
10	10	--> function __init_uvar -d "Sets a universal variable if it's not already set"
        if not set --query $argv[1]
            set --universal $argv
        end
    ...
3	28	--> if test $__fish_initialized -lt 3100

        # Regular syntax highlighting colors
        __init_uvar fish_color_normal normal
        __init_uvar fish_color_command 005fd7
        __init_uvar fish_color_param 00afff
        __init_uvar fish_color_redirection 00afff
        __init_uvar fish_color_comment 990000
        __init_uvar fish_color_error ff0000
        __init_uvar fish_color_escape 00a6b2
        __init_uvar fish_color_operator 00a6b2
        __init_uvar fish_color_end 009900
        __init_uvar fish_color_quote 999900
        __init_uvar fish_color_autosuggestion 555 brblack
        __init_uvar fish_color_user brgreen
        __init_uvar fish_color_host normal
        __init_uvar fish_color_host_remote yellow
        __init_uvar fish_color_valid_path --underline
        __init_uvar fish_color_status red

        __init_uvar fish_color_cwd green
        __init_uvar fish_color_cwd_root red

        # Background color for matching quotes and parenthesis
        __init_uvar fish_color_match --background=brblue

        # Background color for search matches
        __init_uvar fish_color_search_match bryellow --background=brblack

        # Background color for selections
        __init_uvar fish_color_selection white --bold --background=brblack

        # XXX fish_color_cancel was added in 2.6, but this was added to post-2.3 initialization
        # when 2.4 and 2.5 were already released
        __init_uvar fish_color_cancel -r

        # Pager colors
        __init_uvar fish_pager_color_prefix white --bold --underline
        __init_uvar fish_pager_color_completion
        __init_uvar fish_pager_color_description B3A06D yellow
        __init_uvar fish_pager_color_progress brwhite --background=cyan

        #
        # Directory history colors
        #
        __init_uvar fish_color_history_current --bold
    ...
25	25	---> test $__fish_initialized -lt 3100
14	80	--> if not set -q FISH_UNIT_TESTS_RUNNING
        if not test -d $__fish_user_data_dir/generated_completions
            # Generating completions from man pages needs python (see issue #3588).

            # We cannot simply do `fish_update_completions &` because it is a function.
            # We cannot do `eval` since it is a function.
            # We don't want to call `fish -c` since that is unnecessary and sources config.fish again.
            # Hence we'll call python directly.
            # c_m_p.py should work with any python version.
            set -l update_args -B $__fish_data_dir/tools/create_manpage_completions.py --manpath --cleanup-in '~/.config/fish/completions' --cleanup-in '~/.config/fish/generated_completions'
            for py in python{3,2,}
                if command -sq $py
                    set -l c $py $update_args
                    # Run python directly in the background and swallow all output
                    $c (: fish_update_completions: generating completions from man pages) >/dev/null 2>&1 &
                    # Then disown the job so that it continues to run in case of an early exit (#6269)
                    disown 2>&1 >/dev/null
                    break
                end
            end
        end
    ...
22	22	---> not set -q FISH_UNIT_TESTS_RUNNING
3	44	---> if not test -d $__fish_user_data_dir/generated_completions
            # Generating completions from man pages needs python (see issue #3588).

            # We cannot simply do `fish_update_completions &` because it is a function.
            # We cannot do `eval` since it is a function.
            # We don't want to call `fish -c` since that is unnecessary and sources config.fish again.
            # Hence we'll call python directly.
            # c_m_p.py should work with any python version.
            set -l update_args -B $__fish_data_dir/tools/create_manpage_completions.py --manpath --cleanup-in '~/.config/fish/completions' --cleanup-in '~/.config/fish/generated_completions'
            for py in python{3,2,}
                if command -sq $py
                    set -l c $py $update_args
                    # Run python directly in the background and swallow all output
                    $c (: fish_update_completions: generating completions from man pages) >/dev/null 2>&1 &
                    # Then disown the job so that it continues to run in case of an early exit (#6269)
                    disown 2>&1 >/dev/null
                    break
                end
            end
        ...
41	41	----> not test -d $__fish_user_data_dir/generated_completions
5	187	--> if status --is-interactive
        if functions -q fish_greeting
            fish_greeting
        else
            # The greeting used to be skipped when fish_greeting was empty (not just undefined)
            # Keep it that way to not print superfluous newlines on old configuration
            test -n "$fish_greeting"
            and echo $fish_greeting
        end
    ...
27	27	---> status --is-interactive
7	155	---> if functions -q fish_greeting
            fish_greeting
        else
            # The greeting used to be skipped when fish_greeting was empty (not just undefined)
            # Keep it that way to not print superfluous newlines on old configuration
            test -n "$fish_greeting"
            and echo $fish_greeting
        ...
119	119	----> functions -q fish_greeting
29	29	----> test -n "$fish_greeting"
28	28	--> set -l varargs --on-variable fish_key_bindings
34	196	--> for var in user host cwd{,_root} status
        set -a varargs --on-variable fish_color_$var
    ...
32	32	---> set -a varargs --on-variable fish_color_$var
31	31	---> set -a varargs --on-variable fish_color_$var
31	31	---> set -a varargs --on-variable fish_color_$var
32	32	---> set -a varargs --on-variable fish_color_$var
36	36	---> set -a varargs --on-variable fish_color_$var
36	36	--> function __fish_repaint $varargs -d "Event handler, repaints the prompt when fish_color_cwd* changes"
        if status --is-interactive
            set -e __fish_prompt_cwd
            commandline -f repaint 2>/dev/null
        end
    ...
4	40	--> if test -d /etc/init.d
        complete -x -p "/etc/init.d/*" -a start --description 'Start service'
        complete -x -p "/etc/init.d/*" -a stop --description 'Stop service'
        complete -x -p "/etc/init.d/*" -a status --description 'Print service status'
        complete -x -p "/etc/init.d/*" -a restart --description 'Stop and then start service'
        complete -x -p "/etc/init.d/*" -a reload --description 'Reload service configuration'
    ...
36	36	---> test -d /etc/init.d
82	82	--> complete -c [ --wraps test
29	29	--> complete -c ! --wraps not
209	441	--> complete -c(builtin -n | string match -rv '(source|cd|exec|realpath|set|\\[|test|for)') --no-files
232	232	---> builtin -n | string match -rv '(source|cd|exec|realpath|set|\\[|test|for)'
14	14	--> function __fish_reload_key_bindings -d "Reload key bindings when binding variable change" --on-variable fish_key_bindings
        # Make sure some key bindings are set
        __init_uvar fish_key_bindings fish_default_key_bindings

        # Do nothing if the key bindings didn't actually change.
        # This could be because the variable was set to the existing value
        # or because it was a local variable.
        # If fish_key_bindings is empty on the first run, we still need to set the defaults.
        if test "$fish_key_bindings" = "$__fish_active_key_bindings" -a -n "$fish_key_bindings"
            return
        end
        # Check if fish_key_bindings is a valid function.
        # If not, either keep the previous bindings (if any) or revert to default.
        # Also print an error so the user knows.
        if not functions -q "$fish_key_bindings"
            echo "There is no fish_key_bindings function called: '$fish_key_bindings'" >&2
            # We need to see if this is a defined function, otherwise we'd be in an endless loop.
            if functions -q $__fish_active_key_bindings
                echo "Keeping $__fish_active_key_bindings" >&2
                # Set the variable to the old value so this error doesn't happen again.
                set fish_key_bindings $__fish_active_key_bindings
                return 1
            else if functions -q fish_default_key_bindings
                echo "Reverting to default bindings" >&2
                set fish_key_bindings fish_default_key_bindings
                # Return because we are called again
                return 0
            else
                # If we can't even find the default bindings, something is broken.
                # Without it, we would eventually run into the stack size limit, but that'd print hundreds of duplicate lines
                # so we should give up earlier.
                echo "Cannot find fish_default_key_bindings, falling back to very simple bindings." >&2
                echo "Most likely something is wrong with your installation." >&2
                return 0
            end
        end
        set -g __fish_active_key_bindings "$fish_key_bindings"
        set -g fish_bind_mode default
        if test "$fish_key_bindings" = fish_default_key_bindings
            # Redirect stderr per #1155
            fish_default_key_bindings 2>/dev/null
        else
            $fish_key_bindings 2>/dev/null
        end
        # Load user key bindings if they are defined
        if functions --query fish_user_key_bindings >/dev/null
            fish_user_key_bindings 2>/dev/null
        end
    ...
48	7135	--> __fish_reload_key_bindings
37	81	---> __init_uvar fish_key_bindings fish_default_key_bindings
3	44	----> if not set --query $argv[1]
            set --universal $argv
        ...
41	41	-----> not set --query $argv[1]
4	47	---> if test "$fish_key_bindings" = "$__fish_active_key_bindings" -a -n "$fish_key_bindings"
            return
        ...
43	43	----> test "$fish_key_bindings" = "$__fish_active_key_bindings" -a -n "$fish_key_bindings"
5	735	---> if not functions -q "$fish_key_bindings"
            echo "There is no fish_key_bindings function called: '$fish_key_bindings'" >&2
            # We need to see if this is a defined function, otherwise we'd be in an endless loop.
            if functions -q $__fish_active_key_bindings
                echo "Keeping $__fish_active_key_bindings" >&2
                # Set the variable to the old value so this error doesn't happen again.
                set fish_key_bindings $__fish_active_key_bindings
                return 1
            else if functions -q fish_default_key_bindings
                echo "Reverting to default bindings" >&2
                set fish_key_bindings fish_default_key_bindings
                # Return because we are called again
                return 0
            else
                # If we can't even find the default bindings, something is broken.
                # Without it, we would eventually run into the stack size limit, but that'd print hundreds of duplicate lines
                # so we should give up earlier.
                echo "Cannot find fish_default_key_bindings, falling back to very simple bindings." >&2
                echo "Most likely something is wrong with your installation." >&2
                return 0
            end
        ...
183	730	----> not functions -q "$fish_key_bindings"
532	547	-----> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/fish_default_key_bindings.fish
15	15	------> function fish_default_key_bindings -d "Default (Emacs-like) key bindings for fish"
    if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    end

    if not set -q argv[1]
        bind --erase --all --preset # clear earlier bindings, if any
        if test "$fish_key_bindings" != "fish_default_key_bindings"
            # Allow the user to set the variable universally
            set -q fish_key_bindings
            or set -g fish_key_bindings
            # This triggers the handler, which calls us again and ensures the user_key_bindings
            # are executed.
            set fish_key_bindings fish_default_key_bindings
            return
        end
    end

    # Silence warnings about unavailable keys. See #4431, 4188
    if not contains -- -s $argv
        set argv "-s" $argv
    end

    # These are shell-specific bindings that we share with vi mode.
    __fish_shared_key_bindings $argv
    or return # protect against invalid $argv

    # This is the default binding, i.e. the one used if no other binding matches
    bind --preset $argv "" self-insert
    or exit # protect against invalid $argv

    # Space expands abbrs _and_ inserts itself.
    bind --preset $argv " " self-insert expand-abbr

    bind --preset $argv \n execute
    bind --preset $argv \r execute

    bind --preset $argv \ck kill-line

    bind --preset $argv \eOC forward-char
    bind --preset $argv \eOD backward-char
    bind --preset $argv \e\[C forward-char
    bind --preset $argv \e\[D backward-char
    bind --preset $argv -k right forward-char
    bind --preset $argv -k left backward-char

    bind --preset $argv -k dc delete-char
    bind --preset $argv -k backspace backward-delete-char
    bind --preset $argv \x7f backward-delete-char

    # for PuTTY
    # https://github.com/fish-shell/fish-shell/issues/180
    bind --preset $argv \e\[1~ beginning-of-line
    bind --preset $argv \e\[3~ delete-char
    bind --preset $argv \e\[4~ end-of-line

    # OS X SnowLeopard doesn't have these keys. Don't show an annoying error message.
    bind --preset $argv -k home beginning-of-line 2>/dev/null
    bind --preset $argv -k end end-of-line 2>/dev/null
    bind --preset $argv \e\[3\;2~ backward-delete-char # Mavericks Terminal.app shift-ctrl-delete

    bind --preset $argv \ca beginning-of-line
    bind --preset $argv \ce end-of-line
    bind --preset $argv \ch backward-delete-char
    bind --preset $argv \cp up-or-search
    bind --preset $argv \cn down-or-search
    bind --preset $argv \cf forward-char
    bind --preset $argv \cb backward-char
    bind --preset $argv \ct transpose-chars
    bind --preset $argv \et transpose-words
    bind --preset $argv \eu upcase-word

    # This clashes with __fish_list_current_token
    # bind --preset $argv \el downcase-word
    bind --preset $argv \ec capitalize-word
    # One of these is alt+backspace.
    bind --preset $argv \e\x7f backward-kill-word
    bind --preset $argv \e\b backward-kill-word
    bind --preset $argv \eb backward-word
    bind --preset $argv \ef forward-word
    bind --preset $argv \e\[1\;5C forward-word
    bind --preset $argv \e\[1\;5D backward-word
    bind --preset $argv \e\< beginning-of-buffer
    bind --preset $argv \e\> end-of-buffer

    bind --preset $argv \ed kill-word

    # term-specific special bindings
    switch "$TERM"
        case 'rxvt*'
            bind --preset $argv \e\[8~ end-of-line
            bind --preset $argv \eOc forward-word
            bind --preset $argv \eOd backward-word
        case 'xterm-256color'
            # Microsoft's conemu uses xterm-256color plus
            # the following to tell a console to paste:
            bind --preset $argv \e\x20ep fish_clipboard_paste
    end
...
61	61	---> set -g __fish_active_key_bindings "$fish_key_bindings"
31	31	---> set -g fish_bind_mode default
8	6018	---> if test "$fish_key_bindings" = fish_default_key_bindings
            # Redirect stderr per #1155
            fish_default_key_bindings 2>/dev/null
        else
            $fish_key_bindings 2>/dev/null
        ...
33	33	----> test "$fish_key_bindings" = fish_default_key_bindings
140	5977	----> fish_default_key_bindings 2>/dev/null
7	71	-----> if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    ...
35	35	------> contains -- -h $argv
29	29	------> contains -- --help $argv
12	111	-----> if not set -q argv[1]
        bind --erase --all --preset # clear earlier bindings, if any
        if test "$fish_key_bindings" != "fish_default_key_bindings"
            # Allow the user to set the variable universally
            set -q fish_key_bindings
            or set -g fish_key_bindings
            # This triggers the handler, which calls us again and ensures the user_key_bindings
            # are executed.
            set fish_key_bindings fish_default_key_bindings
            return
        end
    ...
24	24	------> not set -q argv[1]
38	38	------> bind --erase --all --preset
3	37	------> if test "$fish_key_bindings" != "fish_default_key_bindings"
            # Allow the user to set the variable universally
            set -q fish_key_bindings
            or set -g fish_key_bindings
            # This triggers the handler, which calls us again and ensures the user_key_bindings
            # are executed.
            set fish_key_bindings fish_default_key_bindings
            return
        ...
34	34	-------> test "$fish_key_bindings" != "fish_default_key_bindings"
8	67	-----> if not contains -- -s $argv
        set argv "-s" $argv
    ...
30	30	------> not contains -- -s $argv
29	29	------> set argv "-s" $argv
330	4350	-----> __fish_shared_key_bindings $argv
788	816	------> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/__fish_shared_key_bindings.fish
11	11	-------> function __fish_shared_key_bindings -d "Bindings shared between emacs and vi mode"
    # These are some bindings that are supposed to be shared between vi mode and default mode.
    # They are supposed to be unrelated to text-editing (or movement).
    # This takes $argv so the vi-bindings can pass the mode they are valid in.

    if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    end

    bind --preset $argv \cy yank
    or return # protect against invalid $argv
    bind --preset $argv \ey yank-pop

    # Left/Right arrow
    bind --preset $argv -k right forward-char
    bind --preset $argv -k left backward-char
    bind --preset $argv \e\[C forward-char
    bind --preset $argv \e\[D backward-char
    # Some terminals output these when they're in in keypad mode.
    bind --preset $argv \eOC forward-char
    bind --preset $argv \eOD backward-char

    bind --preset $argv -k ppage beginning-of-history
    bind --preset $argv -k npage end-of-history

    # Interaction with the system clipboard.
    bind --preset $argv \cx fish_clipboard_copy
    bind --preset $argv \cv fish_clipboard_paste

    bind --preset $argv \e cancel
    bind --preset $argv \t complete
    bind --preset $argv \cs pager-toggle-search
    # shift-tab does a tab complete followed by a search.
    bind --preset $argv --key btab complete-and-search

    bind --preset $argv \e\n "commandline -i \n"
    bind --preset $argv \e\r "commandline -i \n"

    bind --preset $argv -k down down-or-search
    bind --preset $argv -k up up-or-search
    bind --preset $argv \e\[A up-or-search
    bind --preset $argv \e\[B down-or-search
    bind --preset $argv \eOA up-or-search
    bind --preset $argv \eOB down-or-search

    bind --preset $argv -k sright forward-bigword
    bind --preset $argv -k sleft backward-bigword

    # Alt-left/Alt-right
    bind --preset $argv \e\eOC nextd-or-forward-word
    bind --preset $argv \e\eOD prevd-or-backward-word
    bind --preset $argv \e\e\[C nextd-or-forward-word
    bind --preset $argv \e\e\[D prevd-or-backward-word
    bind --preset $argv \eO3C nextd-or-forward-word
    bind --preset $argv \eO3D prevd-or-backward-word
    bind --preset $argv \e\[3C nextd-or-forward-word
    bind --preset $argv \e\[3D prevd-or-backward-word
    bind --preset $argv \e\[1\;3C nextd-or-forward-word
    bind --preset $argv \e\[1\;3D prevd-or-backward-word
    bind --preset $argv \e\[1\;9C nextd-or-forward-word #iTerm2
    bind --preset $argv \e\[1\;9D prevd-or-backward-word #iTerm2

    # Alt-up/Alt-down
    bind --preset $argv \e\eOA history-token-search-backward
    bind --preset $argv \e\eOB history-token-search-forward
    bind --preset $argv \e\e\[A history-token-search-backward
    bind --preset $argv \e\e\[B history-token-search-forward
    bind --preset $argv \eO3A history-token-search-backward
    bind --preset $argv \eO3B history-token-search-forward
    bind --preset $argv \e\[3A history-token-search-backward
    bind --preset $argv \e\[3B history-token-search-forward
    bind --preset $argv \e\[1\;3A history-token-search-backward
    bind --preset $argv \e\[1\;3B history-token-search-forward
    bind --preset $argv \e\[1\;9A history-token-search-backward # iTerm2
    bind --preset $argv \e\[1\;9B history-token-search-forward # iTerm2
    # Bash compatibility
    # https://github.com/fish-shell/fish-shell/issues/89
    bind --preset $argv \e. history-token-search-backward

    bind --preset $argv \el __fish_list_current_token
    bind --preset $argv \ew __fish_whatis_current_token
    # ncurses > 6.0 sends a "delete scrollback" sequence along with clear.
    # This string replace removes it.
    bind --preset $argv \cl 'echo -n (clear | string replace \e\[3J ""); commandline -f repaint'
    bind --preset $argv \cc __fish_cancel_commandline
    bind --preset $argv \cu backward-kill-line
    bind --preset $argv \cw backward-kill-path-component
    bind --preset $argv \e\[F end-of-line
    bind --preset $argv \e\[H beginning-of-line

    bind --preset $argv \ed 'set -l cmd (commandline); if test -z "$cmd"; echo; dirh; commandline -f repaint; else; commandline -f kill-word; end'
    bind --preset $argv \cd delete-or-exit

    # Prepend 'sudo ' to the current commandline
    bind --preset $argv \es __fish_prepend_sudo

    # Allow reading manpages by pressing F1 (many GUI applications) or Alt+h (like in zsh).
    bind --preset $argv -k f1 __fish_man_page
    bind --preset $argv \eh __fish_man_page

    # This will make sure the output of the current command is paged using the default pager when
    # you press Meta-p.
    # If none is set, less will be used.
    bind --preset $argv \ep '__fish_paginate'

    # Make it easy to turn an unexecuted command into a comment in the shell history. Also,
    # remove the commenting chars so the command can be further edited then executed.
    bind --preset $argv \e\# __fish_toggle_comment_commandline

    # The [meta-e] and [meta-v] keystrokes invoke an external editor on the command buffer.
    bind --preset $argv \ee edit_command_buffer
    bind --preset $argv \ev edit_command_buffer

    # Tmux' focus events.
    # Exclude paste mode because that should get _everything_ literally.
    for mode in (bind --list-modes | string match -v paste)
        # We only need the in-focus event currently (to redraw the vi-cursor).
        bind --preset -M $mode \e\[I 'emit fish_focus_in'
        bind --preset -M $mode \e\[O false
        bind --preset -M $mode \e\[\?1004h false
    end

    # Support for "bracketed paste"
    # The way it works is that we acknowledge our support by printing
    # \e\[?2004h
    # then the terminal will "bracket" every paste in
    # \e\[200~ and \e\[201~
    # Every character in between those two will be part of the paste and should not cause a binding to execute (like \n executing commands).
    #
    # We enable it after every command and disable it before (in __fish_config_interactive.fish)
    #
    # Support for this seems to be ubiquitous - emacs enables it unconditionally (!) since 25.1
    # (though it only supports it since then, it seems to be the last term to gain support).
    #
    # NOTE: This is more of a "security" measure than a proper feature.
    # The better way to paste remains the `fish_clipboard_paste` function (bound to \cv by default).
    # We don't disable highlighting here, so it will be redone after every character (which can be slow),
    # and it doesn't handle "paste-stop" sequences in the paste (which the terminal needs to strip).
    #
    # See http://thejh.net/misc/website-terminal-copy-paste.

    # Bind the starting sequence in every bind mode, even user-defined ones.
    # Exclude paste mode or there'll be an additional binding after switching between emacs and vi
    for mode in (bind --list-modes | string match -v paste)
        bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
    end
    # This sequence ends paste-mode and returns to the previous mode we have saved before.
    bind --preset -M paste \e\[201~ '__fish_stop_bracketed_paste'
    # In paste-mode, everything self-inserts except for the sequence to get out of it
    bind --preset -M paste "" self-insert
    # Without this, a \r will overwrite the other text, rendering it invisible - which makes the exercise kinda pointless.
    bind --preset -M paste \r "commandline -i \n"

    # We usually just pass the text through as-is to facilitate pasting code,
    # but when the current token contains an unbalanced single-quote (`'`),
    # we escape all single-quotes and backslashes, effectively turning the paste
    # into one literal token, to facilitate pasting non-code (e.g. markdown or git commitishes)
    bind --preset -M paste "'" "__fish_commandline_insert_escaped \' \$__fish_paste_quoted"
    bind --preset -M paste \\ "__fish_commandline_insert_escaped \\\ \$__fish_paste_quoted"
    # Only insert spaces if we're either quoted or not at the beginning of the commandline
    # - this strips leading spaces if they would trigger histignore.
    bind --preset -M paste " " self-insert-notfirst
...
10	10	-------> function __fish_commandline_insert_escaped --description 'Insert the first arg escaped if a second arg is given'
    if set -q argv[2]
        commandline -i \\$argv[1]
    else
        commandline -i $argv[1]
    end
...
4	4	-------> function __fish_start_bracketed_paste
    # Save the last bind mode so we can restore it.
    set -g __fish_last_bind_mode $fish_bind_mode
    # If the token is currently single-quoted,
    # we escape single-quotes (and backslashes).
    __fish_commandline_is_singlequoted
    and set -g __fish_paste_quoted 1
...
3	3	-------> function __fish_stop_bracketed_paste
    # Restore the last bind mode.
    set fish_bind_mode $__fish_last_bind_mode
    set -e __fish_paste_quoted
    commandline -f force-repaint
...
7	69	------> if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    ...
34	34	-------> contains -- -h $argv
28	28	-------> contains -- --help $argv
31	31	------> bind --preset $argv \cy yank
30	30	------> bind --preset $argv \ey yank-pop
35	35	------> bind --preset $argv -k right forward-char
32	32	------> bind --preset $argv -k left backward-char
30	30	------> bind --preset $argv \e\[C forward-char
30	30	------> bind --preset $argv \e\[D backward-char
29	29	------> bind --preset $argv \eOC forward-char
28	28	------> bind --preset $argv \eOD backward-char
30	30	------> bind --preset $argv -k ppage beginning-of-history
30	30	------> bind --preset $argv -k npage end-of-history
29	29	------> bind --preset $argv \cx fish_clipboard_copy
28	28	------> bind --preset $argv \cv fish_clipboard_paste
29	29	------> bind --preset $argv \e cancel
29	29	------> bind --preset $argv \t complete
28	28	------> bind --preset $argv \cs pager-toggle-search
29	29	------> bind --preset $argv --key btab complete-and-search
31	31	------> bind --preset $argv \e\n "commandline -i \n"
34	34	------> bind --preset $argv \e\r "commandline -i \n"
30	30	------> bind --preset $argv -k down down-or-search
32	32	------> bind --preset $argv -k up up-or-search
30	30	------> bind --preset $argv \e\[A up-or-search
29	29	------> bind --preset $argv \e\[B down-or-search
28	28	------> bind --preset $argv \eOA up-or-search
28	28	------> bind --preset $argv \eOB down-or-search
31	31	------> bind --preset $argv -k sright forward-bigword
31	31	------> bind --preset $argv -k sleft backward-bigword
30	30	------> bind --preset $argv \e\eOC nextd-or-forward-word
30	30	------> bind --preset $argv \e\eOD prevd-or-backward-word
33	33	------> bind --preset $argv \e\e\[C nextd-or-forward-word
30	30	------> bind --preset $argv \e\e\[D prevd-or-backward-word
29	29	------> bind --preset $argv \eO3C nextd-or-forward-word
29	29	------> bind --preset $argv \eO3D prevd-or-backward-word
29	29	------> bind --preset $argv \e\[3C nextd-or-forward-word
29	29	------> bind --preset $argv \e\[3D prevd-or-backward-word
30	30	------> bind --preset $argv \e\[1\;3C nextd-or-forward-word
30	30	------> bind --preset $argv \e\[1\;3D prevd-or-backward-word
31	31	------> bind --preset $argv \e\[1\;9C nextd-or-forward-word
30	30	------> bind --preset $argv \e\[1\;9D prevd-or-backward-word
32	32	------> bind --preset $argv \e\eOA history-token-search-backward
30	30	------> bind --preset $argv \e\eOB history-token-search-forward
30	30	------> bind --preset $argv \e\e\[A history-token-search-backward
29	29	------> bind --preset $argv \e\e\[B history-token-search-forward
29	29	------> bind --preset $argv \eO3A history-token-search-backward
29	29	------> bind --preset $argv \eO3B history-token-search-forward
29	29	------> bind --preset $argv \e\[3A history-token-search-backward
29	29	------> bind --preset $argv \e\[3B history-token-search-forward
33	33	------> bind --preset $argv \e\[1\;3A history-token-search-backward
50	50	------> bind --preset $argv \e\[1\;3B history-token-search-forward
30	30	------> bind --preset $argv \e\[1\;9A history-token-search-backward
30	30	------> bind --preset $argv \e\[1\;9B history-token-search-forward
29	29	------> bind --preset $argv \e. history-token-search-backward
29	29	------> bind --preset $argv \el __fish_list_current_token
29	29	------> bind --preset $argv \ew __fish_whatis_current_token
34	34	------> bind --preset $argv \cl 'echo -n (clear | string replace \e\[3J ""); commandline -f repaint'
30	30	------> bind --preset $argv \cc __fish_cancel_commandline
29	29	------> bind --preset $argv \cu backward-kill-line
29	29	------> bind --preset $argv \cw backward-kill-path-component
29	29	------> bind --preset $argv \e\[F end-of-line
30	30	------> bind --preset $argv \e\[H beginning-of-line
32	32	------> bind --preset $argv \ed 'set -l cmd (commandline); if test -z "$cmd"; echo; dirh; commandline -f repaint; else; commandline -f kill-word; end'
30	30	------> bind --preset $argv \cd delete-or-exit
29	29	------> bind --preset $argv \es __fish_prepend_sudo
30	30	------> bind --preset $argv -k f1 __fish_man_page
30	30	------> bind --preset $argv \eh __fish_man_page
31	31	------> bind --preset $argv \ep '__fish_paginate'
30	30	------> bind --preset $argv \e\# __fish_toggle_comment_commandline
29	29	------> bind --preset $argv \ee edit_command_buffer
28	28	------> bind --preset $argv \ev edit_command_buffer
126	546	------> for mode in (bind --list-modes | string match -v paste)
        # We only need the in-focus event currently (to redraw the vi-cursor).
        bind --preset -M $mode \e\[I 'emit fish_focus_in'
        bind --preset -M $mode \e\[O false
        bind --preset -M $mode \e\[\?1004h false
    ...
209	209	-------> bind --list-modes | string match -v paste
47	47	-------> bind --preset -M $mode \e\[I 'emit fish_focus_in'
34	34	-------> bind --preset -M $mode \e\[O false
33	33	-------> bind --preset -M $mode \e\[\?1004h false
34	34	-------> bind --preset -M $mode \e\[I 'emit fish_focus_in'
31	31	-------> bind --preset -M $mode \e\[O false
32	32	-------> bind --preset -M $mode \e\[\?1004h false
86	352	------> for mode in (bind --list-modes | string match -v paste)
        bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
    ...
182	182	-------> bind --list-modes | string match -v paste
47	47	-------> bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
37	37	-------> bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
32	32	------> bind --preset -M paste \e\[201~ '__fish_stop_bracketed_paste'
29	29	------> bind --preset -M paste "" self-insert
30	30	------> bind --preset -M paste \r "commandline -i \n"
30	30	------> bind --preset -M paste "'" "__fish_commandline_insert_escaped \' \$__fish_paste_quoted"
30	30	------> bind --preset -M paste \\ "__fish_commandline_insert_escaped \\\ \$__fish_paste_quoted"
28	28	------> bind --preset -M paste " " self-insert-notfirst
31	31	-----> bind --preset $argv "" self-insert
31	31	-----> bind --preset $argv " " self-insert expand-abbr
29	29	-----> bind --preset $argv \n execute
29	29	-----> bind --preset $argv \r execute
28	28	-----> bind --preset $argv \ck kill-line
29	29	-----> bind --preset $argv \eOC forward-char
28	28	-----> bind --preset $argv \eOD backward-char
29	29	-----> bind --preset $argv \e\[C forward-char
28	28	-----> bind --preset $argv \e\[D backward-char
30	30	-----> bind --preset $argv -k right forward-char
29	29	-----> bind --preset $argv -k left backward-char
30	30	-----> bind --preset $argv -k dc delete-char
30	30	-----> bind --preset $argv -k backspace backward-delete-char
29	29	-----> bind --preset $argv \x7f backward-delete-char
31	31	-----> bind --preset $argv \e\[1~ beginning-of-line
29	29	-----> bind --preset $argv \e\[3~ delete-char
30	30	-----> bind --preset $argv \e\[4~ end-of-line
54	54	-----> bind --preset $argv -k home beginning-of-line 2>/dev/null
51	51	-----> bind --preset $argv -k end end-of-line 2>/dev/null
33	33	-----> bind --preset $argv \e\[3\;2~ backward-delete-char
29	29	-----> bind --preset $argv \ca beginning-of-line
29	29	-----> bind --preset $argv \ce end-of-line
29	29	-----> bind --preset $argv \ch backward-delete-char
29	29	-----> bind --preset $argv \cp up-or-search
29	29	-----> bind --preset $argv \cn down-or-search
29	29	-----> bind --preset $argv \cf forward-char
29	29	-----> bind --preset $argv \cb backward-char
29	29	-----> bind --preset $argv \ct transpose-chars
29	29	-----> bind --preset $argv \et transpose-words
28	28	-----> bind --preset $argv \eu upcase-word
29	29	-----> bind --preset $argv \ec capitalize-word
29	29	-----> bind --preset $argv \e\x7f backward-kill-word
29	29	-----> bind --preset $argv \e\b backward-kill-word
29	29	-----> bind --preset $argv \eb backward-word
28	28	-----> bind --preset $argv \ef forward-word
31	31	-----> bind --preset $argv \e\[1\;5C forward-word
32	32	-----> bind --preset $argv \e\[1\;5D backward-word
29	29	-----> bind --preset $argv \e\< beginning-of-buffer
29	29	-----> bind --preset $argv \e\> end-of-buffer
29	29	-----> bind --preset $argv \ed kill-word
17	17	-----> switch "$TERM"
        case 'rxvt*'
            bind --preset $argv \e\[8~ end-of-line
            bind --preset $argv \eOc forward-word
            bind --preset $argv \eOd backward-word
        case 'xterm-256color'
            # Microsoft's conemu uses xterm-256color plus
            # the following to tell a console to paste:
            bind --preset $argv \e\x20ep fish_clipboard_paste
    ...
4	114	---> if functions --query fish_user_key_bindings >/dev/null
            fish_user_key_bindings 2>/dev/null
        ...
110	110	----> functions --query fish_user_key_bindings >/dev/null
11	255	--> if not set -q FISH_UNIT_TESTS_RUNNING
        # Enable bracketed paste before every prompt (see __fish_shared_bindings for the bindings).
        # Disable it for unit tests so we don't have to add the sequences to bind.expect
        function __fish_enable_bracketed_paste --on-event fish_prompt
            printf "\e[?2004h"
        end

        # Disable BP before every command because that might not support it.
        function __fish_disable_bracketed_paste --on-event fish_preexec --on-event fish_exit
            printf "\e[?2004l"
        end

        # Tell the terminal we support BP. Since we are in __f_c_i, the first fish_prompt
        # has already fired.
        __fish_enable_bracketed_paste
    ...
64	64	---> not set -q FISH_UNIT_TESTS_RUNNING
11	11	---> function __fish_enable_bracketed_paste --on-event fish_prompt
            printf "\e[?2004h"
        ...
9	9	---> function __fish_disable_bracketed_paste --on-event fish_preexec --on-event fish_exit
            printf "\e[?2004l"
        ...
46	160	---> __fish_enable_bracketed_paste
114	114	----> printf "\e[?2004h"
4	33	--> if set -q TMUX
        and not set -q FISH_UNIT_TESTS_RUNNING
        function __fish_enable_focus --on-event fish_postexec
            echo -n \e\[\?1004h
        end
        function __fish_disable_focus --on-event fish_preexec
            echo -n \e\[\?1004l
        end
        # Note: Don't call this initially because, even though we're in a fish_prompt event,
        # tmux reacts sooo quickly that we'll still get a sequence before we're prepared for it.
        # So this means that we won't get focus events until you've run at least one command, but that's preferable
        # to always seeing `^[[I` when starting fish.
        # __fish_enable_focus
    ...
29	29	---> set -q TMUX
17	17	--> function __fish_winch_handler --on-signal WINCH -d "Repaint screen when window changes size"
        commandline -f repaint >/dev/null 2>/dev/null
    ...
5	234	--> if test 0"$VTE_VERSION" -ge 3405 -o "$TERM_PROGRAM" = "Apple_Terminal" -a (string match -r '\d+' 0"$TERM_PROGRAM_VERSION") -ge 309
        function __update_cwd_osc --on-variable PWD --description 'Notify capable terminals when $PWD changes'
            if status --is-command-substitution || set -q INSIDE_EMACS
                return
            end
            printf \e\]7\;file://%s%s\a $hostname (string escape --style=url $PWD)
        end
        __update_cwd_osc # Run once because we might have already inherited a PWD from an old tab
    ...
167	229	---> test 0"$VTE_VERSION" -ge 3405 -o "$TERM_PROGRAM" = "Apple_Terminal" -a (string match -r '\d+' 0"$TERM_PROGRAM_VERSION") -ge 309
62	62	----> string match -r '\d+' 0"$TERM_PROGRAM_VERSION"
16	6014	--> if not type -q __fish_command_not_found_handler
        # Read the OS/Distro from /etc/os-release.
        # This has a "ID=" line that defines the exact distribution,
        # and an "ID_LIKE=" line that defines what it is derived from or otherwise like.
        # For our purposes, we use both.
        set -l os
        if test -r /etc/os-release
            set os (string match -r '^ID(?:_LIKE)?\s*=.*' < /etc/os-release | \
            string replace -r '^ID(?:_LIKE)?\s*=(.*)' '$1' | string trim -c '\'"' | string split " ")
        end

        # First check if we are on OpenSUSE since SUSE's handler has no options
        # but the same name and path as Ubuntu's.
        if contains -- suse $os || contains -- sles $os && type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/bin/command-not-found $argv[1]
            end
            # Check for Fedora's handler
        else if test -f /usr/libexec/pk-command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/libexec/pk-command-not-found $argv[1]
            end
            # Check in /usr/lib, this is where modern Ubuntus place this command
        else if test -f /usr/lib/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/lib/command-not-found -- $argv[1]
            end
            # Check for NixOS handler
        else if test -f /run/current-system/sw/bin/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /run/current-system/sw/bin/command-not-found $argv
            end
            # Ubuntu Feisty places this command in the regular path instead
        else if type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                command-not-found -- $argv[1]
            end
            # pkgfile is an optional, but official, package on Arch Linux
            # it ships with example handlers for bash and zsh, so we'll follow that format
        else if type -p -q pkgfile
            function __fish_command_not_found_handler --on-event fish_command_not_found
                set -l __packages (pkgfile --binaries --verbose -- $argv[1] 2>/dev/null)
                if test $status -eq 0
                    printf "%s may be found in the following packages:\n" "$argv[1]"
                    printf "  %s\n" $__packages
                else
                    __fish_default_command_not_found_handler $argv[1]
                end
            end
            # Use standard fish command not found handler otherwise
        else
            function __fish_command_not_found_handler --on-event fish_command_not_found
                __fish_default_command_not_found_handler $argv[1]
            end
        end
    ...
273	2462	---> not type -q __fish_command_not_found_handler
506	519	----> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/type.fish
13	13	-----> function type --description 'Print the type of a command'
    # For legacy reasons, no argument simply causes an unsuccessful return.
    set -q argv[1]
    or return 1

    set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
    argparse -n type -x t,p,P $options -- $argv
    or return

    if set -q _flag_help
        __fish_print_help type
        return 0
    end

    set -l res 1
    set -l mode normal
    set -l multi no
    set -l selection all
    set -l short no

    # Technically all four of these flags are mutually exclusive. However, we allow -q to be used
    # with the other three because old versions of this function explicitly allowed it by making
    # --quiet have precedence.
    if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    end

    set -q _flag_all
    and set multi yes

    set -q _flag_short
    and set short yes

    set -q _flag_no_functions
    and set selection files

    # Check all possible types for the remaining arguments.
    for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    end

    return $res
...
48	48	----> set -q argv[1]
59	59	----> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
100	100	----> argparse -n type -x t,p,P $options -- $argv
5	36	----> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
31	31	-----> set -q _flag_help
29	29	----> set -l res 1
28	28	----> set -l mode normal
29	29	----> set -l multi no
28	28	----> set -l selection all
27	27	----> set -l short no
11	63	----> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
25	25	-----> set -q _flag_quiet
27	27	-----> set mode quiet
27	27	----> set -q _flag_all
25	25	----> set -q _flag_short
23	23	----> set -q _flag_no_functions
54	1120	----> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
35	35	-----> set -l found 0
15	461	-----> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
42	42	------> test $selection != files
3	144	------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
141	141	-------> functions -q -- $i
4	260	------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
196	256	-------> contains -- $i (builtin -n)
60	60	--------> builtin -n
31	31	-----> set -l paths
9	449	-----> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
28	28	------> test $multi != yes
115	412	------> set paths (command -s -- $i)
297	297	-------> command -s -- $i
12	12	-----> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
5	78	-----> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
46	46	------> test $found = 0
27	27	------> test $mode != quiet
28	28	----> return $res
26	26	---> set -l os
4	43	---> if test -r /etc/os-release
            set os (string match -r '^ID(?:_LIKE)?\s*=.*' < /etc/os-release | \
            string replace -r '^ID(?:_LIKE)?\s*=(.*)' '$1' | string trim -c '\'"' | string split " ")
        ...
39	39	----> test -r /etc/os-release
21	3467	---> if contains -- suse $os || contains -- sles $os && type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/bin/command-not-found $argv[1]
            end
            # Check for Fedora's handler
        else if test -f /usr/libexec/pk-command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/libexec/pk-command-not-found $argv[1]
            end
            # Check in /usr/lib, this is where modern Ubuntus place this command
        else if test -f /usr/lib/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/lib/command-not-found -- $argv[1]
            end
            # Check for NixOS handler
        else if test -f /run/current-system/sw/bin/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /run/current-system/sw/bin/command-not-found $argv
            end
            # Ubuntu Feisty places this command in the regular path instead
        else if type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                command-not-found -- $argv[1]
            end
            # pkgfile is an optional, but official, package on Arch Linux
            # it ships with example handlers for bash and zsh, so we'll follow that format
        else if type -p -q pkgfile
            function __fish_command_not_found_handler --on-event fish_command_not_found
                set -l __packages (pkgfile --binaries --verbose -- $argv[1] 2>/dev/null)
                if test $status -eq 0
                    printf "%s may be found in the following packages:\n" "$argv[1]"
                    printf "  %s\n" $__packages
                else
                    __fish_default_command_not_found_handler $argv[1]
                end
            end
            # Use standard fish command not found handler otherwise
        else
            function __fish_command_not_found_handler --on-event fish_command_not_found
                __fish_default_command_not_found_handler $argv[1]
            end
        ...
34	34	----> contains -- suse $os
37	37	----> contains -- sles $os
38	38	----> test -f /usr/libexec/pk-command-not-found
24	24	----> test -f /usr/lib/command-not-found
67	67	----> test -f /run/current-system/sw/bin/command-not-found
88	1581	----> type -q command-not-found
23	23	-----> set -q argv[1]
43	43	-----> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
62	62	-----> argparse -n type -x t,p,P $options -- $argv
4	76	-----> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
72	72	------> set -q _flag_help
31	31	-----> set -l res 1
26	26	-----> set -l mode normal
25	25	-----> set -l multi no
36	36	-----> set -l selection all
25	25	-----> set -l short no
8	56	-----> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
23	23	------> set -q _flag_quiet
25	25	------> set mode quiet
25	25	-----> set -q _flag_all
22	22	-----> set -q _flag_short
21	21	-----> set -q _flag_no_functions
26	994	-----> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
27	27	------> set -l found 0
10	372	------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
28	28	-------> test $selection != files
3	98	-------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
95	95	--------> functions -q -- $i
4	236	-------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
176	232	--------> contains -- $i (builtin -n)
56	56	---------> builtin -n
30	30	------> set -l paths
9	459	------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
28	28	-------> test $multi != yes
97	422	-------> set paths (command -s -- $i)
325	325	--------> command -s -- $i
14	14	------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
5	66	------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
32	32	-------> test $found = 0
29	29	-------> test $mode != quiet
28	28	-----> return $res
74	1652	----> type -p -q pkgfile
25	25	-----> set -q argv[1]
47	47	-----> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
71	71	-----> argparse -n type -x t,p,P $options -- $argv
7	32	-----> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
25	25	------> set -q _flag_help
25	25	-----> set -l res 1
24	24	-----> set -l mode normal
26	26	-----> set -l multi no
25	25	-----> set -l selection all
24	24	-----> set -l short no
8	54	-----> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
22	22	------> set -q _flag_quiet
24	24	------> set mode quiet
23	23	-----> set -q _flag_all
22	22	-----> set -q _flag_short
21	21	-----> set -q _flag_no_functions
32	1132	-----> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
26	26	------> set -l found 0
14	559	------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
28	28	-------> test $selection != files
3	93	-------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
90	90	--------> functions -q -- $i
4	424	-------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
327	420	--------> contains -- $i (builtin -n)
93	93	---------> builtin -n
34	34	------> set -l paths
10	400	------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
31	31	-------> test $multi != yes
111	359	-------> set paths (command -s -- $i)
248	248	--------> command -s -- $i
14	14	------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
7	67	------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
32	32	-------> test $found = 0
28	28	-------> test $mode != quiet
27	27	-----> return $res
13	13	----> function __fish_command_not_found_handler --on-event fish_command_not_found
                __fish_default_command_not_found_handler $argv[1]
            ...
53	53	--> set __fish_initialized 3100
37	37	-> functions -e __fish_on_interactive
127	140	> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/fish_mode_prompt.fish
13	13	-> function fish_mode_prompt --description "Displays the current mode"
    # To reuse the mode indicator use this function instead
    fish_default_mode_prompt
...
44	527	> fish_mode_prompt
204	483	-> fish_default_mode_prompt
185	198	--> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/fish_default_mode_prompt.fish
13	13	---> function fish_default_mode_prompt --description "Display the default mode for the prompt"
    # Do nothing if not in vi mode
    if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    end
...
8	81	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
40	40	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
33	33	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
42	64634	> fish_prompt
407	64592	-> echo -nes "\n" (_user_host_name) (_directory) (_git_status) (_node) '\n› '
29	64	--> _user_host_name
5	35	---> if test -n "$SSH_TTY"
    switch "$USER"
      case root toor
        set user_color red
      case '*'
        set user_color yellow
    end
    echo -s (set_color --bold $user_color) $USER (set_color normal) ' at ' (set_color --bold blue) (prompt_hostname) (set_color normal) ' '
  ...
30	30	----> test -n "$SSH_TTY"
34	1436	--> _directory
303	1402	---> echo -s 'in ' (set_color --bold cyan) (prompt_pwd) (set_color normal)
101	101	----> set_color --bold cyan
201	937	----> prompt_pwd
196	212	-----> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/prompt_pwd.fish
16	16	------> function prompt_pwd --description "Print the current working directory, shortened to fit the prompt"
    set -l options 'h/help'
    argparse -n prompt_pwd --max-args=0 $options -- $argv
    or return

    if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    end

    # This allows overriding fish_prompt_pwd_dir_length from the outside (global or universal) without leaking it
    set -q fish_prompt_pwd_dir_length
    or set -l fish_prompt_pwd_dir_length 1

    # Replace $HOME with "~"
    set realhome ~
    set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)

    if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    end
...
48	48	-----> set -l options 'h/help'
38	38	-----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	28	-----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
24	24	------> set -q _flag_help
22	22	-----> set -q fish_prompt_pwd_dir_length
25	25	-----> set -l fish_prompt_pwd_dir_length 1
39	39	-----> set realhome ~
145	220	-----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
75	75	------> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
11	104	-----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
34	34	------> [ $fish_prompt_pwd_dir_length -eq 0 ]
59	59	------> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
61	61	----> set_color normal
66	62606	--> _git_status
140	47909	---> set -l branch_name (__fish_git_prompt "%s" | sed 's/ //')
1104	47769	----> __fish_git_prompt "%s" | sed 's/ //'
103	110	-----> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/__fish_git_prompt.fish
7	7	------> function __fish_git_prompt
    # TODO: This name is deprecated, figure out a way to tell users.
    fish_git_prompt $argv
...
367	46555	-----> fish_git_prompt $argv
2767	4689	------> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/fish_git_prompt.fish
15	15	-------> function __fish_git_prompt_show_upstream --description "Helper function for fish_git_prompt"
    set -q __fish_git_prompt_showupstream
    or set -l __fish_git_prompt_showupstream
    set -l show_upstream $__fish_git_prompt_showupstream
    set -l svn_prefix # For better SVN upstream information
    set -l informative

    set -l svn_url_pattern
    set -l count
    set -l upstream git
    set -l verbose
    set -l name

    # Default to informative if __fish_git_prompt_show_informative_status is set
    if set -q __fish_git_prompt_show_informative_status
        set informative 1
    end

    set -l svn_remote
    # get some config options from git-config
    command git config -z --get-regexp '^(svn-remote\..*\.url|bash\.showupstream)$' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showupstream
                set show_upstream $value
                test -n "$show_upstream"
                or return
            case svn-remote.'*'.url
                set svn_remote $svn_remote $value
                # Avoid adding \| to the beginning to avoid needing #?? later
                if test -n "$svn_url_pattern"
                    set svn_url_pattern $svn_url_pattern"|$value"
                else
                    set svn_url_pattern $value
                end
                set upstream svn+git # default upstream is SVN if available, else git

                # Save the config key (without .url) for later use
                set -l remote_prefix (string replace -r '\.url$' '' -- $key)
                set svn_prefix $svn_prefix $remote_prefix
        end
    end

    # parse configuration variables
    # and clear informative default when needed
    for option in $show_upstream
        switch $option
            case git svn
                set upstream $option
                set -e informative
            case verbose
                set verbose 1
                set -e informative
            case informative
                set informative 1
            case name
                set name 1
            case none
                return
        end
    end

    # Find our upstream
    switch $upstream
        case git
            set upstream '@{upstream}'
        case svn\*
            # get the upstream from the 'git-svn-id: …' in a commit message
            # (git-svn uses essentially the same procedure internally)
            set -l svn_upstream (git log --first-parent -1 --grep="^git-svn-id: \($svn_url_pattern\)" 2>/dev/null)
            if test (count $svn_upstream) -ne 0
                echo $svn_upstream[-1] | read -l __ svn_upstream __
                set svn_upstream (string replace -r '@.*' '' -- $svn_upstream)
                set -l cur_prefix
                for i in (seq (count $svn_remote))
                    set -l remote $svn_remote[$i]
                    set -l mod_upstream (string replace "$remote" "" -- $svn_upstream)
                    if test "$svn_upstream" != "$mod_upstream"
                        # we found a valid remote
                        set svn_upstream $mod_upstream
                        set cur_prefix $svn_prefix[$i]
                        break
                    end
                end

                if test -z "$svn_upstream"
                    # default branch name for checkouts with no layout:
                    if test -n "$GIT_SVN_ID"
                        set upstream $GIT_SVN_ID
                    else
                        set upstream git-svn
                    end
                else
                    set upstream (string replace '/branches' '' -- $svn_upstream | string replace -a '/' '')

                    # Use fetch config to fix upstream
                    set -l fetch_val (command git config "$cur_prefix".fetch)
                    if test -n "$fetch_val"
                        string split -m1 : -- "$fetch_val" | read -l trunk pattern
                        set upstream (string replace -r -- "/$trunk\$" '' $pattern) /$upstream
                    end
                end
            else if test $upstream = svn+git
                set upstream '@{upstream}'
            end
    end

    # Find how many commits we are ahead/behind our upstream
    set count (command git rev-list --count --left-right $upstream...HEAD 2>/dev/null | string replace \t " ")

    # calculate the result
    if test -n "$verbose"
        # Verbose has a space by default
        set -l prefix "$___fish_git_prompt_char_upstream_prefix"
        # Using two underscore version to check if user explicitly set to nothing
        if not set -q __fish_git_prompt_char_upstream_prefix
            set prefix " "
        end

        echo $count | read -l behind ahead
        switch "$count"
            case '' # no upstream
            case "0 0" # equal to upstream
                echo "$prefix$___fish_git_prompt_char_upstream_equal"
            case "0 *" # ahead of upstream
                echo "$prefix$___fish_git_prompt_char_upstream_ahead$ahead"
            case "* 0" # behind upstream
                echo "$prefix$___fish_git_prompt_char_upstream_behind$behind"
            case '*' # diverged from upstream
                echo "$prefix$___fish_git_prompt_char_upstream_diverged$ahead-$behind"
        end
        if test -n "$count" -a -n "$name"
            echo " "(command git rev-parse --abbrev-ref "$upstream" 2>/dev/null)
        end
    else if test -n "$informative"
        echo $count | read -l behind ahead
        switch "$count"
            case '' # no upstream
            case "0 0" # equal to upstream
            case "0 *" # ahead of upstream
                echo "$___fish_git_prompt_char_upstream_prefix$___fish_git_prompt_char_upstream_ahead$ahead"
            case "* 0" # behind upstream
                echo "$___fish_git_prompt_char_upstream_prefix$___fish_git_prompt_char_upstream_behind$behind"
            case '*' # diverged from upstream
                echo "$___fish_git_prompt_char_upstream_prefix$___fish_git_prompt_char_upstream_ahead$ahead$___fish_git_prompt_char_upstream_behind$behind"
        end
    else
        switch "$count"
            case '' # no upstream
            case "0 0" # equal to upstream
                echo "$___fish_git_prompt_char_upstream_prefix$___fish_git_prompt_char_upstream_equal"
            case "0 *" # ahead of upstream
                echo "$___fish_git_prompt_char_upstream_prefix$___fish_git_prompt_char_upstream_ahead"
            case "* 0" # behind upstream
                echo "$___fish_git_prompt_char_upstream_prefix$___fish_git_prompt_char_upstream_behind"
            case '*' # diverged from upstream
                echo "$___fish_git_prompt_char_upstream_prefix$___fish_git_prompt_char_upstream_diverged"
        end
    end

    # For the return status
    test "$count" = "0 0"
...
8	8	-------> function fish_git_prompt --description "Prompt function for Git"
    # If git isn't installed, there's nothing we can do
    # Return 1 so the calling prompt can deal with it
    if not command -sq git
        return 1
    end
    set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
    test -n "$repo_info"
    or return

    set -l git_dir $repo_info[1]
    set -l inside_gitdir $repo_info[2]
    set -l bare_repo $repo_info[3]
    set -l inside_worktree $repo_info[4]
    set -q repo_info[5]
    and set -l sha $repo_info[5]

    set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
    set -l r $rbc[1] # current operation
    set -l b $rbc[2] # current branch
    set -l detached $rbc[3]
    set -l w #dirty working directory
    set -l i #staged changes
    set -l s #stashes
    set -l u #untracked
    set -l c $rbc[4] # bare repository
    set -l p #upstream
    set -l informative_status

    if not set -q ___fish_git_prompt_init
        # This takes a while, so it only needs to be done once,
        # and then whenever the configuration changes.
        __fish_git_prompt_validate_chars
        __fish_git_prompt_validate_colors
        set -g ___fish_git_prompt_init
    end

    set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"

    # Use our variables as defaults, but allow overrides via the local git config.
    # That means if neither is set, this stays empty.
    #
    # So "!= true" or "!= false" are useful tests if you want to do something by default.
    set -l informative (command git config --bool bash.showInformativeStatus)

    set -l dirty (command git config --bool bash.showDirtyState)
    if not set -q dirty[1]
        set -q __fish_git_prompt_showdirtystate
        and set dirty true
    end

    set -l untracked (command git config --bool bash.showUntrackedFiles)
    if not set -q untracked[1]
        set -q __fish_git_prompt_showuntrackedfiles
        and set untracked true
    end

    if test "true" = $inside_worktree
        # Use informative status if it has been enabled locally, or it has been
        # enabled globally (via the fish variable) and dirty or untracked are not false.
        #
        # This is to allow overrides for the repository.
        if test "$informative" = true
            or begin
                set -q __fish_git_prompt_show_informative_status
                and test "$dirty" != false
                and test "$untracked" != false
            end
            set informative_status "$space"(__fish_git_prompt_informative_status $git_dir)
        else
            # This has to be set explicitly.
            if test "$dirty" = true
                set w (__fish_git_prompt_dirty)
                set i (__fish_git_prompt_staged $sha)
            end

            if set -q __fish_git_prompt_showstashstate
                and test -r $git_dir/refs/stash
                set s $___fish_git_prompt_char_stashstate
            end

            if test "$untracked" = true
                set u (__fish_git_prompt_untracked)
            end
        end

        if set -q __fish_git_prompt_showupstream
            or set -q __fish_git_prompt_show_informative_status
            set p (__fish_git_prompt_show_upstream)
        end
    end

    set -l branch_color $___fish_git_prompt_color_branch
    set -l branch_done $___fish_git_prompt_color_branch_done
    if set -q __fish_git_prompt_showcolorhints
        if test $detached = yes
            set branch_color $___fish_git_prompt_color_branch_detached
            set branch_done $___fish_git_prompt_color_branch_detached_done
        end
    end

    if test -n "$w"
        set w "$___fish_git_prompt_color_dirtystate$w$___fish_git_prompt_color_dirtystate_done"
    end
    if test -n "$i"
        set i "$___fish_git_prompt_color_stagedstate$i$___fish_git_prompt_color_stagedstate_done"
    end
    if test -n "$s"
        set s "$___fish_git_prompt_color_stashstate$s$___fish_git_prompt_color_stashstate_done"
    end
    if test -n "$u"
        set u "$___fish_git_prompt_color_untrackedfiles$u$___fish_git_prompt_color_untrackedfiles_done"
    end

    set b (string replace refs/heads/ '' -- $b)
    set -q __fish_git_prompt_shorten_branch_char_suffix
    or set -l __fish_git_prompt_shorten_branch_char_suffix "…"
    if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"; and test (string length "$b") -gt $__fish_git_prompt_shorten_branch_len
        set b (string sub -l "$__fish_git_prompt_shorten_branch_len" "$b")"$__fish_git_prompt_shorten_branch_char_suffix"
    end
    if test -n "$b"
        set b "$branch_color$b$branch_done"
    end

    if test -n "$c"
        set c "$___fish_git_prompt_color_bare$c$___fish_git_prompt_color_bare_done"
    end
    if test -n "$r"
        set r "$___fish_git_prompt_color_merging$r$___fish_git_prompt_color_merging_done"
    end
    if test -n "$p"
        set p "$___fish_git_prompt_color_upstream$p$___fish_git_prompt_color_upstream_done"
    end

    # Formatting
    set -l f "$w$i$s$u"
    if test -n "$f"
        set f "$space$f"
    end
    set -l format $argv[1]
    if test -z "$format"
        set format " (%s)"
    end

    printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
...
11	11	-------> function __fish_git_prompt_staged --description "fish_git_prompt helper, tells whether or not the current branch has staged files"
    set -l sha $argv[1]
    set -l staged
    set -l ret 0

    if test -n "$sha"
        # The "diff" functions all return > 0 if there _is_ a diff,
        # but we want to return 0 if there are staged changes.
        # So we invert the status.
        not command git diff-index --cached --quiet HEAD -- 2>/dev/null
        and set staged $___fish_git_prompt_char_stagedstate
        set ret $status
    else
        set staged $___fish_git_prompt_char_invalidstate
        set ret 2
    end
    echo $staged
    return $ret
...
9	9	-------> function __fish_git_prompt_untracked --description "fish_git_prompt helper, tells whether or not the current repository has untracked files"
    set -l ret 1
    if command git ls-files --others --exclude-standard --directory --no-empty-directory --error-unmatch -- :/ >/dev/null 2>&1
        set ret $status
        set untracked $___fish_git_prompt_char_untrackedfiles
    end
    echo $untracked
    return $ret
...
8	8	-------> function __fish_git_prompt_dirty --description "fish_git_prompt helper, tells whether or not the current branch has tracked, modified files"
    set -l dirty

    # Like staged, invert the status because we want 0 to mean there are dirty files.
    not command git diff --no-ext-diff --quiet --exit-code 2>/dev/null
    set -l os $status
    if test $os -eq 0
        set dirty $___fish_git_prompt_char_dirtystate
    end
    echo $dirty
    return $os
...
43	43	-------> set -g ___fish_git_prompt_status_order stagedstate invalidstate dirtystate untrackedfiles
4	29	-------> if set -q __fish_git_prompt_showstashstate
    set -a ___fish_git_prompt_status_order stashstate
...
25	25	--------> set -q __fish_git_prompt_showstashstate
5	5	-------> function __fish_git_prompt_informative_status

    set -l changedFiles (command git diff --name-status 2>/dev/null | string match -r \\w)
    set -l stagedFiles (command git diff --staged --name-status | string match -r \\w)

    set -l x (count $changedFiles)
    set -l y (count (string match -r "U" -- $changedFiles))
    set -l dirtystate (math $x - $y)
    set -l x (count $stagedFiles)
    set -l invalidstate (count (string match -r "U" -- $stagedFiles))
    set -l stagedstate (math $x - $invalidstate)
    set -l untrackedfiles (command git ls-files --others --exclude-standard | count)
    set -l stashstate 0
    set -l stashfile "$argv[1]/logs/refs/stash"
    if set -q __fish_git_prompt_showstashstate; and test -e "$stashfile"
        set stashstate (count < $stashfile)
    end

    set -l info

    # If `math` fails for some reason, assume the state is clean - it's the simpler path
    set -l state (math $dirtystate + $invalidstate + $stagedstate + $untrackedfiles + $stashstate 2>/dev/null)
    if test -z "$state"
        or test "$state" = 0
        set info $___fish_git_prompt_color_cleanstate$___fish_git_prompt_char_cleanstate$___fish_git_prompt_color_cleanstate_done
    else
        for i in $___fish_git_prompt_status_order
            if [ $$i != "0" ]
                set -l color_var ___fish_git_prompt_color_$i
                set -l color_done_var ___fish_git_prompt_color_{$i}_done
                set -l symbol_var ___fish_git_prompt_char_$i

                set -l color $$color_var
                set -l color_done $$color_done_var
                set -l symbol $$symbol_var

                set -l count

                if not set -q __fish_git_prompt_hide_$i
                    set count $$i
                end

                set info "$info$color$symbol$count$color_done"
            end
        end
    end

    echo $info

...
12	12	-------> function __fish_git_prompt_operation_branch_bare --description "fish_git_prompt helper, returns the current Git operation and branch"
    # This function is passed the full repo_info array
    set -l git_dir $argv[1]
    set -l inside_gitdir $argv[2]
    set -l bare_repo $argv[3]
    set -q argv[5]
    and set -l sha $argv[5]

    set -l branch
    set -l operation
    set -l detached no
    set -l bare
    set -l step
    set -l total
    set -l os

    if test -d $git_dir/rebase-merge
        set branch (cat $git_dir/rebase-merge/head-name 2>/dev/null)
        set step (cat $git_dir/rebase-merge/msgnum 2>/dev/null)
        set total (cat $git_dir/rebase-merge/end 2>/dev/null)
        if test -f $git_dir/rebase-merge/interactive
            set operation "|REBASE-i"
        else
            set operation "|REBASE-m"
        end
    else
        if test -d $git_dir/rebase-apply
            set step (cat $git_dir/rebase-apply/next 2>/dev/null)
            set total (cat $git_dir/rebase-apply/last 2>/dev/null)
            if test -f $git_dir/rebase-apply/rebasing
                set branch (cat $git_dir/rebase-apply/head-name 2>/dev/null)
                set operation "|REBASE"
            else if test -f $git_dir/rebase-apply/applying
                set operation "|AM"
            else
                set operation "|AM/REBASE"
            end
        else if test -f $git_dir/MERGE_HEAD
            set operation "|MERGING"
        else if test -f $git_dir/CHERRY_PICK_HEAD
            set operation "|CHERRY-PICKING"
        else if test -f $git_dir/REVERT_HEAD
            set operation "|REVERTING"
        else if test -f $git_dir/BISECT_LOG
            set operation "|BISECTING"
        end
    end

    if test -n "$step" -a -n "$total"
        set operation "$operation $step/$total"
    end

    if test -z "$branch"
        set branch (command git symbolic-ref HEAD 2>/dev/null; set os $status)
        if test $os -ne 0
            set detached yes
            set branch (switch "$__fish_git_prompt_describe_style"
						case contains
							command git describe --contains HEAD
						case branch
							command git describe --contains --all HEAD
						case describe
							command git describe HEAD
						case default '*'
							command git describe --tags --exact-match HEAD
						end 2>/dev/null; set os $status)
            if test $os -ne 0
                # Shorten the sha ourselves to 8 characters - this should be good for most repositories,
                # and even for large ones it should be good for most commits
                if set -q sha
                    set branch (string match -r '^.{8}' -- $sha)…
                else
                    set branch unknown
                end
            end
            set branch "($branch)"
        end
    end

    if test "true" = $inside_gitdir
        if test "true" = $bare_repo
            set bare "BARE:"
        else
            # Let user know they're inside the git dir of a non-bare repo
            set branch "GIT_DIR!"
        end
    end

    echo $operation
    echo $branch
    echo $detached
    echo $bare
...
4	4	-------> function __fish_git_prompt_set_char
    set -l user_variable_name "$argv[1]"
    set -l char $argv[2]
    set -l user_variable
    if set -q $user_variable_name
        set user_variable $$user_variable_name
    end

    if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    end

    set -l variable _$user_variable_name
    set -l variable_done "$variable"_done

    if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    end
...
8	8	-------> function __fish_git_prompt_validate_chars --description "fish_git_prompt helper, checks char variables"

    __fish_git_prompt_set_char __fish_git_prompt_char_cleanstate '✔'
    __fish_git_prompt_set_char __fish_git_prompt_char_dirtystate '*' '✚'
    __fish_git_prompt_set_char __fish_git_prompt_char_invalidstate '#' '✖'
    __fish_git_prompt_set_char __fish_git_prompt_char_stagedstate '+' '●'
    __fish_git_prompt_set_char __fish_git_prompt_char_stashstate '$' '⚑'
    __fish_git_prompt_set_char __fish_git_prompt_char_stateseparator ' ' '|'
    __fish_git_prompt_set_char __fish_git_prompt_char_untrackedfiles '%' '…'
    __fish_git_prompt_set_char __fish_git_prompt_char_upstream_ahead '>' '↑'
    __fish_git_prompt_set_char __fish_git_prompt_char_upstream_behind '<' '↓'
    __fish_git_prompt_set_char __fish_git_prompt_char_upstream_diverged '<>'
    __fish_git_prompt_set_char __fish_git_prompt_char_upstream_equal '='
    __fish_git_prompt_set_char __fish_git_prompt_char_upstream_prefix ''

...
6	6	-------> function __fish_git_prompt_set_color
    set -l user_variable_name "$argv[1]"
    set -l user_variable
    if set -q $user_variable_name
        set user_variable $$user_variable_name
    end
    set -l user_variable_bright

    set -l default default_done
    switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    end

    set -l variable _$user_variable_name
    set -l variable_done "$variable"_done

    if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    end

...
8	8	-------> function __fish_git_prompt_validate_colors --description "fish_git_prompt helper, checks color variables"

    # Base color defaults to nothing (must be done first)
    __fish_git_prompt_set_color __fish_git_prompt_color '' ''

    # Normal colors
    __fish_git_prompt_set_color __fish_git_prompt_color_prefix
    __fish_git_prompt_set_color __fish_git_prompt_color_suffix
    __fish_git_prompt_set_color __fish_git_prompt_color_bare
    __fish_git_prompt_set_color __fish_git_prompt_color_merging
    __fish_git_prompt_set_color __fish_git_prompt_color_cleanstate
    __fish_git_prompt_set_color __fish_git_prompt_color_invalidstate
    __fish_git_prompt_set_color __fish_git_prompt_color_upstream

    # Colors with defaults with showcolorhints
    if set -q __fish_git_prompt_showcolorhints
        __fish_git_prompt_set_color __fish_git_prompt_color_flags (set_color --bold blue)
        __fish_git_prompt_set_color __fish_git_prompt_color_branch (set_color green)
        __fish_git_prompt_set_color __fish_git_prompt_color_dirtystate (set_color red)
        __fish_git_prompt_set_color __fish_git_prompt_color_stagedstate (set_color green)
    else
        __fish_git_prompt_set_color __fish_git_prompt_color_flags
        __fish_git_prompt_set_color __fish_git_prompt_color_branch
        __fish_git_prompt_set_color __fish_git_prompt_color_dirtystate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
        __fish_git_prompt_set_color __fish_git_prompt_color_stagedstate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
    end

    # Branch_detached has a default, but is only used with showcolorhints
    __fish_git_prompt_set_color __fish_git_prompt_color_branch_detached (set_color red)

    # Colors that depend on flags color
    __fish_git_prompt_set_color __fish_git_prompt_color_stashstate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
    __fish_git_prompt_set_color __fish_git_prompt_color_untrackedfiles $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done

...
29	29	-------> set -l varargs
78	352	-------> for var in repaint describe_style show_informative_status use_informative_chars showdirtystate showstashstate showuntrackedfiles showupstream
    set -a varargs --on-variable __fish_git_prompt_$var
...
37	37	--------> set -a varargs --on-variable __fish_git_prompt_$var
32	32	--------> set -a varargs --on-variable __fish_git_prompt_$var
31	31	--------> set -a varargs --on-variable __fish_git_prompt_$var
32	32	--------> set -a varargs --on-variable __fish_git_prompt_$var
36	36	--------> set -a varargs --on-variable __fish_git_prompt_$var
35	35	--------> set -a varargs --on-variable __fish_git_prompt_$var
35	35	--------> set -a varargs --on-variable __fish_git_prompt_$var
36	36	--------> set -a varargs --on-variable __fish_git_prompt_$var
43	43	-------> function __fish_git_prompt_repaint $varargs --description "Event handler, repaints prompt when functionality changes"
    if status --is-interactive
        if test $argv[3] = __fish_git_prompt_show_informative_status
            # Clear characters that have different defaults with/without informative status
            for name in cleanstate dirtystate invalidstate stagedstate stashstate stateseparator untrackedfiles upstream_ahead upstream_behind
                set -e ___fish_git_prompt_char_$name
            end
            # Clear init so we reset the chars next time.
            set -e ___fish_git_prompt_init
        end

        commandline -f repaint 2>/dev/null
    end
...
27	27	-------> set -l varargs
85	632	-------> for var in '' _prefix _suffix _bare _merging _cleanstate _invalidstate _upstream _flags _branch _dirtystate _stagedstate _branch_detached _stashstate _untrackedfiles
    set -a varargs --on-variable __fish_git_prompt_color$var
...
30	30	--------> set -a varargs --on-variable __fish_git_prompt_color$var
31	31	--------> set -a varargs --on-variable __fish_git_prompt_color$var
31	31	--------> set -a varargs --on-variable __fish_git_prompt_color$var
32	32	--------> set -a varargs --on-variable __fish_git_prompt_color$var
33	33	--------> set -a varargs --on-variable __fish_git_prompt_color$var
34	34	--------> set -a varargs --on-variable __fish_git_prompt_color$var
36	36	--------> set -a varargs --on-variable __fish_git_prompt_color$var
36	36	--------> set -a varargs --on-variable __fish_git_prompt_color$var
37	37	--------> set -a varargs --on-variable __fish_git_prompt_color$var
37	37	--------> set -a varargs --on-variable __fish_git_prompt_color$var
42	42	--------> set -a varargs --on-variable __fish_git_prompt_color$var
41	41	--------> set -a varargs --on-variable __fish_git_prompt_color$var
41	41	--------> set -a varargs --on-variable __fish_git_prompt_color$var
41	41	--------> set -a varargs --on-variable __fish_git_prompt_color$var
45	45	--------> set -a varargs --on-variable __fish_git_prompt_color$var
41	41	-------> set -a varargs --on-variable __fish_git_prompt_showcolorhints
65	65	-------> function __fish_git_prompt_repaint_color $varargs --description "Event handler, repaints prompt when any color changes"
    if status --is-interactive
        set -e ___fish_git_prompt_init
        set -l var $argv[3]
        set -e _$var
        set -e _{$var}_done
        if test $var = __fish_git_prompt_color -o $var = __fish_git_prompt_color_flags -o $var = __fish_git_prompt_showcolorhints
            # reset all the other colors too
            for name in prefix suffix bare merging branch dirtystate stagedstate invalidstate stashstate untrackedfiles upstream flags
                set -e ___fish_git_prompt_color_$name
                set -e ___fish_git_prompt_color_{$name}_done
            end
        end
        commandline -f repaint 2>/dev/null
    end
...
30	30	-------> set -l varargs
68	484	-------> for var in cleanstate dirtystate invalidstate stagedstate stashstate stateseparator untrackedfiles upstream_ahead upstream_behind upstream_diverged upstream_equal upstream_prefix
    set -a varargs --on-variable __fish_git_prompt_char_$var
...
31	31	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
30	30	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
31	31	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
31	31	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
33	33	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
34	34	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
35	35	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
36	36	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
38	38	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
38	38	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
39	39	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
40	40	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
53	53	-------> function __fish_git_prompt_repaint_char $varargs --description "Event handler, repaints prompt when any char changes"
    if status --is-interactive
        set -e ___fish_git_prompt_init
        set -e _$argv[3]
        commandline -f repaint 2>/dev/null
    end
...
6	167	------> if not command -sq git
        return 1
    ...
161	161	-------> not command -sq git
188	5050	------> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
4862	4862	-------> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
35	35	------> test -n "$repo_info"
32	32	------> set -l git_dir $repo_info[1]
30	30	------> set -l inside_gitdir $repo_info[2]
30	30	------> set -l bare_repo $repo_info[3]
29	29	------> set -l inside_worktree $repo_info[4]
24	24	------> set -q repo_info[5]
29	29	------> set -l sha $repo_info[5]
131	5256	------> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
119	5125	-------> __fish_git_prompt_operation_branch_bare $repo_info
32	32	--------> set -l git_dir $argv[1]
29	29	--------> set -l inside_gitdir $argv[2]
29	29	--------> set -l bare_repo $argv[3]
26	26	--------> set -q argv[5]
28	28	--------> set -l sha $argv[5]
24	24	--------> set -l branch
24	24	--------> set -l operation
25	25	--------> set -l detached no
23	23	--------> set -l bare
22	22	--------> set -l step
23	23	--------> set -l total
22	22	--------> set -l os
37	270	--------> if test -d $git_dir/rebase-merge
        set branch (cat $git_dir/rebase-merge/head-name 2>/dev/null)
        set step (cat $git_dir/rebase-merge/msgnum 2>/dev/null)
        set total (cat $git_dir/rebase-merge/end 2>/dev/null)
        if test -f $git_dir/rebase-merge/interactive
            set operation "|REBASE-i"
        else
            set operation "|REBASE-m"
        end
    else
        if test -d $git_dir/rebase-apply
            set step (cat $git_dir/rebase-apply/next 2>/dev/null)
            set total (cat $git_dir/rebase-apply/last 2>/dev/null)
            if test -f $git_dir/rebase-apply/rebasing
                set branch (cat $git_dir/rebase-apply/head-name 2>/dev/null)
                set operation "|REBASE"
            else if test -f $git_dir/rebase-apply/applying
                set operation "|AM"
            else
                set operation "|AM/REBASE"
            end
        else if test -f $git_dir/MERGE_HEAD
            set operation "|MERGING"
        else if test -f $git_dir/CHERRY_PICK_HEAD
            set operation "|CHERRY-PICKING"
        else if test -f $git_dir/REVERT_HEAD
            set operation "|REVERTING"
        else if test -f $git_dir/BISECT_LOG
            set operation "|BISECTING"
        end
    ...
42	42	---------> test -d $git_dir/rebase-merge
18	191	---------> if test -d $git_dir/rebase-apply
            set step (cat $git_dir/rebase-apply/next 2>/dev/null)
            set total (cat $git_dir/rebase-apply/last 2>/dev/null)
            if test -f $git_dir/rebase-apply/rebasing
                set branch (cat $git_dir/rebase-apply/head-name 2>/dev/null)
                set operation "|REBASE"
            else if test -f $git_dir/rebase-apply/applying
                set operation "|AM"
            else
                set operation "|AM/REBASE"
            end
        else if test -f $git_dir/MERGE_HEAD
            set operation "|MERGING"
        else if test -f $git_dir/CHERRY_PICK_HEAD
            set operation "|CHERRY-PICKING"
        else if test -f $git_dir/REVERT_HEAD
            set operation "|REVERTING"
        else if test -f $git_dir/BISECT_LOG
            set operation "|BISECTING"
        ...
37	37	----------> test -d $git_dir/rebase-apply
34	34	----------> test -f $git_dir/MERGE_HEAD
35	35	----------> test -f $git_dir/CHERRY_PICK_HEAD
34	34	----------> test -f $git_dir/REVERT_HEAD
33	33	----------> test -f $git_dir/BISECT_LOG
5	38	--------> if test -n "$step" -a -n "$total"
        set operation "$operation $step/$total"
    ...
33	33	---------> test -n "$step" -a -n "$total"
15	4238	--------> if test -z "$branch"
        set branch (command git symbolic-ref HEAD 2>/dev/null; set os $status)
        if test $os -ne 0
            set detached yes
            set branch (switch "$__fish_git_prompt_describe_style"
						case contains
							command git describe --contains HEAD
						case branch
							command git describe --contains --all HEAD
						case describe
							command git describe HEAD
						case default '*'
							command git describe --tags --exact-match HEAD
						end 2>/dev/null; set os $status)
            if test $os -ne 0
                # Shorten the sha ourselves to 8 characters - this should be good for most repositories,
                # and even for large ones it should be good for most commits
                if set -q sha
                    set branch (string match -r '^.{8}' -- $sha)…
                else
                    set branch unknown
                end
            end
            set branch "($branch)"
        end
    ...
25	25	---------> test -z "$branch"
144	4161	---------> set branch (command git symbolic-ref HEAD 2>/dev/null; set os $status)
3960	3960	----------> command git symbolic-ref HEAD 2>/dev/null
57	57	----------> set os $status
5	37	---------> if test $os -ne 0
            set detached yes
            set branch (switch "$__fish_git_prompt_describe_style"
						case contains
							command git describe --contains HEAD
						case branch
							command git describe --contains --all HEAD
						case describe
							command git describe HEAD
						case default '*'
							command git describe --tags --exact-match HEAD
						end 2>/dev/null; set os $status)
            if test $os -ne 0
                # Shorten the sha ourselves to 8 characters - this should be good for most repositories,
                # and even for large ones it should be good for most commits
                if set -q sha
                    set branch (string match -r '^.{8}' -- $sha)…
                else
                    set branch unknown
                end
            end
            set branch "($branch)"
        ...
32	32	----------> test $os -ne 0
5	36	--------> if test "true" = $inside_gitdir
        if test "true" = $bare_repo
            set bare "BARE:"
        else
            # Let user know they're inside the git dir of a non-bare repo
            set branch "GIT_DIR!"
        end
    ...
31	31	---------> test "true" = $inside_gitdir
32	32	--------> echo $operation
31	31	--------> echo $branch
28	28	--------> echo $detached
26	26	--------> echo $bare
33	33	------> set -l r $rbc[1]
28	28	------> set -l b $rbc[2]
30	30	------> set -l detached $rbc[3]
24	24	------> set -l w
22	22	------> set -l i
22	22	------> set -l s
23	23	------> set -l u
26	26	------> set -l c $rbc[4]
23	23	------> set -l p
25	25	------> set -l informative_status
16	17145	------> if not set -q ___fish_git_prompt_init
        # This takes a while, so it only needs to be done once,
        # and then whenever the configuration changes.
        __fish_git_prompt_validate_chars
        __fish_git_prompt_validate_colors
        set -g ___fish_git_prompt_init
    ...
23	23	-------> not set -q ___fish_git_prompt_init
61	6904	-------> __fish_git_prompt_validate_chars
83	584	--------> __fish_git_prompt_set_char __fish_git_prompt_char_cleanstate '✔'
34	34	---------> set -l user_variable_name "$argv[1]"
28	28	---------> set -l char $argv[2]
24	24	---------> set -l user_variable
5	33	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
28	28	----------> set -q $user_variable_name
4	30	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
26	26	----------> set -q argv[3]
33	33	---------> set -l variable _$user_variable_name
32	32	---------> set -l variable_done "$variable"_done
45	287	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
28	28	----------> not set -q $variable
149	214	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
34	34	-----------> set -q $user_variable_name
31	31	-----------> echo $char
59	585	--------> __fish_git_prompt_set_char __fish_git_prompt_char_dirtystate '*' '✚'
35	35	---------> set -l user_variable_name "$argv[1]"
29	29	---------> set -l char $argv[2]
25	25	---------> set -l user_variable
4	31	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
5	108	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
23	23	----------> set -q argv[3]
35	80	----------> begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        ...
24	24	-----------> set -q __fish_git_prompt_show_informative_status
21	21	-----------> set -q __fish_git_prompt_use_informative_chars
31	31	---------> set -l variable _$user_variable_name
30	30	---------> set -l variable_done "$variable"_done
11	237	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
25	25	----------> not set -q $variable
134	201	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
32	32	-----------> set -q $user_variable_name
35	35	-----------> echo $char
58	579	--------> __fish_git_prompt_set_char __fish_git_prompt_char_invalidstate '#' '✖'
35	35	---------> set -l user_variable_name "$argv[1]"
29	29	---------> set -l char $argv[2]
24	24	---------> set -l user_variable
4	31	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
6	107	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
22	22	----------> set -q argv[3]
34	79	----------> begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        ...
24	24	-----------> set -q __fish_git_prompt_show_informative_status
21	21	-----------> set -q __fish_git_prompt_use_informative_chars
31	31	---------> set -l variable _$user_variable_name
30	30	---------> set -l variable_done "$variable"_done
9	234	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
26	26	----------> not set -q $variable
135	199	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
33	33	-----------> set -q $user_variable_name
31	31	-----------> echo $char
55	583	--------> __fish_git_prompt_set_char __fish_git_prompt_char_stagedstate '+' '●'
35	35	---------> set -l user_variable_name "$argv[1]"
30	30	---------> set -l char $argv[2]
26	26	---------> set -l user_variable
4	31	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
5	112	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
23	23	----------> set -q argv[3]
33	84	----------> begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        ...
28	28	-----------> set -q __fish_git_prompt_show_informative_status
23	23	-----------> set -q __fish_git_prompt_use_informative_chars
31	31	---------> set -l variable _$user_variable_name
30	30	---------> set -l variable_done "$variable"_done
10	233	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
26	26	----------> not set -q $variable
133	197	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
33	33	-----------> set -q $user_variable_name
31	31	-----------> echo $char
56	578	--------> __fish_git_prompt_set_char __fish_git_prompt_char_stashstate '$' '⚑'
35	35	---------> set -l user_variable_name "$argv[1]"
28	28	---------> set -l char $argv[2]
25	25	---------> set -l user_variable
4	31	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
4	107	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
23	23	----------> set -q argv[3]
35	80	----------> begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        ...
24	24	-----------> set -q __fish_git_prompt_show_informative_status
21	21	-----------> set -q __fish_git_prompt_use_informative_chars
30	30	---------> set -l variable _$user_variable_name
31	31	---------> set -l variable_done "$variable"_done
11	235	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
26	26	----------> not set -q $variable
133	198	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
34	34	-----------> set -q $user_variable_name
31	31	-----------> echo $char
59	591	--------> __fish_git_prompt_set_char __fish_git_prompt_char_stateseparator ' ' '|'
35	35	---------> set -l user_variable_name "$argv[1]"
29	29	---------> set -l char $argv[2]
25	25	---------> set -l user_variable
4	31	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
5	107	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
23	23	----------> set -q argv[3]
33	79	----------> begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        ...
24	24	-----------> set -q __fish_git_prompt_show_informative_status
22	22	-----------> set -q __fish_git_prompt_use_informative_chars
31	31	---------> set -l variable _$user_variable_name
30	30	---------> set -l variable_done "$variable"_done
11	244	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
26	26	----------> not set -q $variable
142	207	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
34	34	-----------> set -q $user_variable_name
31	31	-----------> echo $char
55	579	--------> __fish_git_prompt_set_char __fish_git_prompt_char_untrackedfiles '%' '…'
35	35	---------> set -l user_variable_name "$argv[1]"
29	29	---------> set -l char $argv[2]
25	25	---------> set -l user_variable
5	32	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
6	108	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
23	23	----------> set -q argv[3]
33	79	----------> begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        ...
24	24	-----------> set -q __fish_git_prompt_show_informative_status
22	22	-----------> set -q __fish_git_prompt_use_informative_chars
31	31	---------> set -l variable _$user_variable_name
30	30	---------> set -l variable_done "$variable"_done
11	234	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
26	26	----------> not set -q $variable
134	197	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
32	32	-----------> set -q $user_variable_name
31	31	-----------> echo $char
56	580	--------> __fish_git_prompt_set_char __fish_git_prompt_char_upstream_ahead '>' '↑'
36	36	---------> set -l user_variable_name "$argv[1]"
29	29	---------> set -l char $argv[2]
25	25	---------> set -l user_variable
4	31	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
6	108	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
23	23	----------> set -q argv[3]
35	79	----------> begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        ...
23	23	-----------> set -q __fish_git_prompt_show_informative_status
21	21	-----------> set -q __fish_git_prompt_use_informative_chars
31	31	---------> set -l variable _$user_variable_name
30	30	---------> set -l variable_done "$variable"_done
12	234	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
25	25	----------> not set -q $variable
134	197	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
32	32	-----------> set -q $user_variable_name
31	31	-----------> echo $char
57	588	--------> __fish_git_prompt_set_char __fish_git_prompt_char_upstream_behind '<' '↓'
35	35	---------> set -l user_variable_name "$argv[1]"
29	29	---------> set -l char $argv[2]
25	25	---------> set -l user_variable
4	31	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
9	111	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
23	23	----------> set -q argv[3]
34	79	----------> begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        ...
23	23	-----------> set -q __fish_git_prompt_show_informative_status
22	22	-----------> set -q __fish_git_prompt_use_informative_chars
33	33	---------> set -l variable _$user_variable_name
31	31	---------> set -l variable_done "$variable"_done
12	236	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
26	26	----------> not set -q $variable
130	198	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
36	36	-----------> set -q $user_variable_name
32	32	-----------> echo $char
58	548	--------> __fish_git_prompt_set_char __fish_git_prompt_char_upstream_diverged '<>'
35	35	---------> set -l user_variable_name "$argv[1]"
29	29	---------> set -l char $argv[2]
25	25	---------> set -l user_variable
4	31	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
4	27	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
23	23	----------> set -q argv[3]
30	30	---------> set -l variable _$user_variable_name
30	30	---------> set -l variable_done "$variable"_done
36	283	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
26	26	----------> not set -q $variable
142	221	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
42	42	-----------> set -q $user_variable_name
37	37	-----------> echo $char
57	525	--------> __fish_git_prompt_set_char __fish_git_prompt_char_upstream_equal '='
35	35	---------> set -l user_variable_name "$argv[1]"
29	29	---------> set -l char $argv[2]
25	25	---------> set -l user_variable
4	31	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
5	27	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
22	22	----------> set -q argv[3]
30	30	---------> set -l variable _$user_variable_name
30	30	---------> set -l variable_done "$variable"_done
37	261	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
25	25	----------> not set -q $variable
131	199	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
36	36	-----------> set -q $user_variable_name
32	32	-----------> echo $char
55	523	--------> __fish_git_prompt_set_char __fish_git_prompt_char_upstream_prefix ''
35	35	---------> set -l user_variable_name "$argv[1]"
29	29	---------> set -l char $argv[2]
25	25	---------> set -l user_variable
4	31	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
5	27	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
22	22	----------> set -q argv[3]
31	31	---------> set -l variable _$user_variable_name
30	30	---------> set -l variable_done "$variable"_done
35	260	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
27	27	----------> not set -q $variable
135	198	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
32	32	-----------> set -q $user_variable_name
31	31	-----------> echo $char
65	10175	-------> __fish_git_prompt_validate_colors
103	795	--------> __fish_git_prompt_set_color __fish_git_prompt_color '' ''
35	35	---------> set -l user_variable_name "$argv[1]"
25	25	---------> set -l user_variable
5	32	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
25	25	---------> set -l user_variable_bright
26	26	---------> set -l default default_done
137	343	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
123	123	----------> count $argv
49	49	----------> set default "$argv[2]"
34	34	----------> set default_done "$argv[3]"
34	34	---------> set -l variable _$user_variable_name
32	32	---------> set -l variable_done "$variable"_done
8	140	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
27	27	----------> not set -q $variable
11	105	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
27	27	-----------> test -n "$user_variable"
34	34	-----------> set -g $variable $default
33	33	-----------> set -g $variable_done $default_done
53	634	--------> __fish_git_prompt_set_color __fish_git_prompt_color_prefix
31	31	---------> set -l user_variable_name "$argv[1]"
25	25	---------> set -l user_variable
4	31	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
24	24	---------> set -l user_variable_bright
25	25	---------> set -l default default_done
123	245	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
40	40	----------> count $argv
48	48	----------> set default $___fish_git_prompt_color
34	34	----------> set default_done $___fish_git_prompt_color_done
33	33	---------> set -l variable _$user_variable_name
31	31	---------> set -l variable_done "$variable"_done
6	136	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
27	27	----------> not set -q $variable
13	103	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
26	26	-----------> test -n "$user_variable"
33	33	-----------> set -g $variable $default
31	31	-----------> set -g $variable_done $default_done
55	633	--------> __fish_git_prompt_set_color __fish_git_prompt_color_suffix
32	32	---------> set -l user_variable_name "$argv[1]"
25	25	---------> set -l user_variable
4	30	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
26	26	----------> set -q $user_variable_name
24	24	---------> set -l user_variable_bright
24	24	---------> set -l default default_done
119	243	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
43	43	----------> count $argv
47	47	----------> set default $___fish_git_prompt_color
34	34	----------> set default_done $___fish_git_prompt_color_done
34	34	---------> set -l variable _$user_variable_name
32	32	---------> set -l variable_done "$variable"_done
6	134	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
27	27	----------> not set -q $variable
9	101	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
26	26	-----------> test -n "$user_variable"
33	33	-----------> set -g $variable $default
33	33	-----------> set -g $variable_done $default_done
59	637	--------> __fish_git_prompt_set_color __fish_git_prompt_color_bare
32	32	---------> set -l user_variable_name "$argv[1]"
24	24	---------> set -l user_variable
4	30	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
26	26	----------> set -q $user_variable_name
26	26	---------> set -l user_variable_bright
25	25	---------> set -l default default_done
120	241	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
40	40	----------> count $argv
48	48	----------> set default $___fish_git_prompt_color
33	33	----------> set default_done $___fish_git_prompt_color_done
34	34	---------> set -l variable _$user_variable_name
32	32	---------> set -l variable_done "$variable"_done
6	134	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
27	27	----------> not set -q $variable
10	101	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
26	26	-----------> test -n "$user_variable"
33	33	-----------> set -g $variable $default
32	32	-----------> set -g $variable_done $default_done
57	649	--------> __fish_git_prompt_set_color __fish_git_prompt_color_merging
35	35	---------> set -l user_variable_name "$argv[1]"
27	27	---------> set -l user_variable
3	31	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
28	28	----------> set -q $user_variable_name
27	27	---------> set -l user_variable_bright
27	27	---------> set -l default default_done
118	243	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
43	43	----------> count $argv
48	48	----------> set default $___fish_git_prompt_color
34	34	----------> set default_done $___fish_git_prompt_color_done
34	34	---------> set -l variable _$user_variable_name
32	32	---------> set -l variable_done "$variable"_done
7	136	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
26	26	----------> not set -q $variable
10	103	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
26	26	-----------> test -n "$user_variable"
34	34	-----------> set -g $variable $default
33	33	-----------> set -g $variable_done $default_done
55	655	--------> __fish_git_prompt_set_color __fish_git_prompt_color_cleanstate
34	34	---------> set -l user_variable_name "$argv[1]"
26	26	---------> set -l user_variable
4	30	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
26	26	----------> set -q $user_variable_name
24	24	---------> set -l user_variable_bright
28	28	---------> set -l default default_done
123	246	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
42	42	----------> count $argv
47	47	----------> set default $___fish_git_prompt_color
34	34	----------> set default_done $___fish_git_prompt_color_done
35	35	---------> set -l variable _$user_variable_name
31	31	---------> set -l variable_done "$variable"_done
7	146	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
26	26	----------> not set -q $variable
22	113	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
26	26	-----------> test -n "$user_variable"
32	32	-----------> set -g $variable $default
33	33	-----------> set -g $variable_done $default_done
57	637	--------> __fish_git_prompt_set_color __fish_git_prompt_color_invalidstate
32	32	---------> set -l user_variable_name "$argv[1]"
25	25	---------> set -l user_variable
5	34	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
29	29	----------> set -q $user_variable_name
24	24	---------> set -l user_variable_bright
24	24	---------> set -l default default_done
117	238	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
40	40	----------> count $argv
47	47	----------> set default $___fish_git_prompt_color
34	34	----------> set default_done $___fish_git_prompt_color_done
35	35	---------> set -l variable _$user_variable_name
32	32	---------> set -l variable_done "$variable"_done
7	136	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
27	27	----------> not set -q $variable
11	102	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
26	26	-----------> test -n "$user_variable"
33	33	-----------> set -g $variable $default
32	32	-----------> set -g $variable_done $default_done
54	627	--------> __fish_git_prompt_set_color __fish_git_prompt_color_upstream
32	32	---------> set -l user_variable_name "$argv[1]"
24	24	---------> set -l user_variable
4	30	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
26	26	----------> set -q $user_variable_name
26	26	---------> set -l user_variable_bright
26	26	---------> set -l default default_done
116	236	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
39	39	----------> count $argv
48	48	----------> set default $___fish_git_prompt_color
33	33	----------> set default_done $___fish_git_prompt_color_done
33	33	---------> set -l variable _$user_variable_name
31	31	---------> set -l variable_done "$variable"_done
7	135	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
27	27	----------> not set -q $variable
11	101	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
26	26	-----------> test -n "$user_variable"
32	32	-----------> set -g $variable $default
32	32	-----------> set -g $variable_done $default_done
16	2605	--------> if set -q __fish_git_prompt_showcolorhints
        __fish_git_prompt_set_color __fish_git_prompt_color_flags (set_color --bold blue)
        __fish_git_prompt_set_color __fish_git_prompt_color_branch (set_color green)
        __fish_git_prompt_set_color __fish_git_prompt_color_dirtystate (set_color red)
        __fish_git_prompt_set_color __fish_git_prompt_color_stagedstate (set_color green)
    else
        __fish_git_prompt_set_color __fish_git_prompt_color_flags
        __fish_git_prompt_set_color __fish_git_prompt_color_branch
        __fish_git_prompt_set_color __fish_git_prompt_color_dirtystate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
        __fish_git_prompt_set_color __fish_git_prompt_color_stagedstate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
    ...
24	24	---------> set -q __fish_git_prompt_showcolorhints
53	633	---------> __fish_git_prompt_set_color __fish_git_prompt_color_flags
36	36	----------> set -l user_variable_name "$argv[1]"
25	25	----------> set -l user_variable
3	29	----------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
26	26	-----------> set -q $user_variable_name
24	24	----------> set -l user_variable_bright
25	25	----------> set -l default default_done
119	241	----------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
42	42	-----------> count $argv
47	47	-----------> set default $___fish_git_prompt_color
33	33	-----------> set default_done $___fish_git_prompt_color_done
32	32	----------> set -l variable _$user_variable_name
32	32	----------> set -l variable_done "$variable"_done
6	136	----------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
27	27	-----------> not set -q $variable
12	103	-----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
26	26	------------> test -n "$user_variable"
34	34	------------> set -g $variable $default
31	31	------------> set -g $variable_done $default_done
57	639	---------> __fish_git_prompt_set_color __fish_git_prompt_color_branch
31	31	----------> set -l user_variable_name "$argv[1]"
24	24	----------> set -l user_variable
9	36	----------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	-----------> set -q $user_variable_name
24	24	----------> set -l user_variable_bright
25	25	----------> set -l default default_done
119	242	----------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
41	41	-----------> count $argv
48	48	-----------> set default $___fish_git_prompt_color
34	34	-----------> set default_done $___fish_git_prompt_color_done
34	34	----------> set -l variable _$user_variable_name
31	31	----------> set -l variable_done "$variable"_done
7	135	----------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
27	27	-----------> not set -q $variable
9	101	-----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
27	27	------------> test -n "$user_variable"
33	33	------------> set -g $variable $default
32	32	------------> set -g $variable_done $default_done
64	649	---------> __fish_git_prompt_set_color __fish_git_prompt_color_dirtystate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
35	35	----------> set -l user_variable_name "$argv[1]"
25	25	----------> set -l user_variable
5	31	----------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
26	26	-----------> set -q $user_variable_name
25	25	----------> set -l user_variable_bright
25	25	----------> set -l default default_done
117	242	----------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
44	44	-----------> count $argv
47	47	-----------> set default "$argv[2]"
34	34	-----------> set default_done "$argv[3]"
34	34	----------> set -l variable _$user_variable_name
32	32	----------> set -l variable_done "$variable"_done
7	136	----------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
27	27	-----------> not set -q $variable
11	102	-----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
26	26	------------> test -n "$user_variable"
33	33	------------> set -g $variable $default
32	32	------------> set -g $variable_done $default_done
64	644	---------> __fish_git_prompt_set_color __fish_git_prompt_color_stagedstate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
31	31	----------> set -l user_variable_name "$argv[1]"
25	25	----------> set -l user_variable
4	33	----------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
29	29	-----------> set -q $user_variable_name
24	24	----------> set -l user_variable_bright
25	25	----------> set -l default default_done
119	241	----------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
42	42	-----------> count $argv
47	47	-----------> set default "$argv[2]"
33	33	-----------> set default_done "$argv[3]"
35	35	----------> set -l variable _$user_variable_name
31	31	----------> set -l variable_done "$variable"_done
7	135	----------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
27	27	-----------> not set -q $variable
10	101	-----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
26	26	------------> test -n "$user_variable"
33	33	------------> set -g $variable $default
32	32	------------> set -g $variable_done $default_done
153	936	--------> __fish_git_prompt_set_color __fish_git_prompt_color_branch_detached (set_color red)
46	46	---------> set_color red
40	40	---------> set -l user_variable_name "$argv[1]"
27	27	---------> set -l user_variable
4	32	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
28	28	----------> set -q $user_variable_name
25	25	---------> set -l user_variable_bright
25	25	---------> set -l default default_done
121	379	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
44	44	----------> count $argv
48	48	----------> set default "$argv[2]"
124	166	----------> set default_done (set_color normal)
42	42	-----------> set_color normal
38	38	---------> set -l variable _$user_variable_name
33	33	---------> set -l variable_done "$variable"_done
6	138	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
28	28	----------> not set -q $variable
12	104	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
26	26	-----------> test -n "$user_variable"
34	34	-----------> set -g $variable $default
32	32	-----------> set -g $variable_done $default_done
71	658	--------> __fish_git_prompt_set_color __fish_git_prompt_color_stashstate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
31	31	---------> set -l user_variable_name "$argv[1]"
24	24	---------> set -l user_variable
4	30	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
26	26	----------> set -q $user_variable_name
26	26	---------> set -l user_variable_bright
25	25	---------> set -l default default_done
120	249	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
42	42	----------> count $argv
53	53	----------> set default "$argv[2]"
34	34	----------> set default_done "$argv[3]"
35	35	---------> set -l variable _$user_variable_name
31	31	---------> set -l variable_done "$variable"_done
6	136	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
28	28	----------> not set -q $variable
11	102	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
26	26	-----------> test -n "$user_variable"
33	33	-----------> set -g $variable $default
32	32	-----------> set -g $variable_done $default_done
68	644	--------> __fish_git_prompt_set_color __fish_git_prompt_color_untrackedfiles $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
31	31	---------> set -l user_variable_name "$argv[1]"
25	25	---------> set -l user_variable
4	30	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
26	26	----------> set -q $user_variable_name
25	25	---------> set -l user_variable_bright
25	25	---------> set -l default default_done
117	239	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
41	41	----------> count $argv
47	47	----------> set default "$argv[2]"
34	34	----------> set default_done "$argv[3]"
35	35	---------> set -l variable _$user_variable_name
31	31	---------> set -l variable_done "$variable"_done
7	135	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
27	27	----------> not set -q $variable
10	101	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
26	26	-----------> test -n "$user_variable"
33	33	-----------> set -g $variable $default
32	32	-----------> set -g $variable_done $default_done
27	27	-------> set -g ___fish_git_prompt_init
37	37	------> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
138	4195	------> set -l informative (command git config --bool bash.showInformativeStatus)
4057	4057	-------> command git config --bool bash.showInformativeStatus
152	4010	------> set -l dirty (command git config --bool bash.showDirtyState)
3858	3858	-------> command git config --bool bash.showDirtyState
11	62	------> if not set -q dirty[1]
        set -q __fish_git_prompt_showdirtystate
        and set dirty true
    ...
28	28	-------> not set -q dirty[1]
23	23	-------> set -q __fish_git_prompt_showdirtystate
162	3891	------> set -l untracked (command git config --bool bash.showUntrackedFiles)
3729	3729	-------> command git config --bool bash.showUntrackedFiles
11	63	------> if not set -q untracked[1]
        set -q __fish_git_prompt_showuntrackedfiles
        and set untracked true
    ...
28	28	-------> not set -q untracked[1]
24	24	-------> set -q __fish_git_prompt_showuntrackedfiles
10	245	------> if test "true" = $inside_worktree
        # Use informative status if it has been enabled locally, or it has been
        # enabled globally (via the fish variable) and dirty or untracked are not false.
        #
        # This is to allow overrides for the repository.
        if test "$informative" = true
            or begin
                set -q __fish_git_prompt_show_informative_status
                and test "$dirty" != false
                and test "$untracked" != false
            end
            set informative_status "$space"(__fish_git_prompt_informative_status $git_dir)
        else
            # This has to be set explicitly.
            if test "$dirty" = true
                set w (__fish_git_prompt_dirty)
                set i (__fish_git_prompt_staged $sha)
            end

            if set -q __fish_git_prompt_showstashstate
                and test -r $git_dir/refs/stash
                set s $___fish_git_prompt_char_stashstate
            end

            if test "$untracked" = true
                set u (__fish_git_prompt_untracked)
            end
        end

        if set -q __fish_git_prompt_showupstream
            or set -q __fish_git_prompt_show_informative_status
            set p (__fish_git_prompt_show_upstream)
        end
    ...
32	32	-------> test "true" = $inside_worktree
14	154	-------> if test "$informative" = true
            or begin
                set -q __fish_git_prompt_show_informative_status
                and test "$dirty" != false
                and test "$untracked" != false
            end
            set informative_status "$space"(__fish_git_prompt_informative_status $git_dir)
        else
            # This has to be set explicitly.
            if test "$dirty" = true
                set w (__fish_git_prompt_dirty)
                set i (__fish_git_prompt_staged $sha)
            end

            if set -q __fish_git_prompt_showstashstate
                and test -r $git_dir/refs/stash
                set s $___fish_git_prompt_char_stashstate
            end

            if test "$untracked" = true
                set u (__fish_git_prompt_untracked)
            end
        ...
26	26	--------> test "$informative" = true
8	30	--------> begin
                set -q __fish_git_prompt_show_informative_status
                and test "$dirty" != false
                and test "$untracked" != false
            ...
22	22	---------> set -q __fish_git_prompt_show_informative_status
4	30	--------> if test "$dirty" = true
                set w (__fish_git_prompt_dirty)
                set i (__fish_git_prompt_staged $sha)
            ...
26	26	---------> test "$dirty" = true
4	26	--------> if set -q __fish_git_prompt_showstashstate
                and test -r $git_dir/refs/stash
                set s $___fish_git_prompt_char_stashstate
            ...
22	22	---------> set -q __fish_git_prompt_showstashstate
4	28	--------> if test "$untracked" = true
                set u (__fish_git_prompt_untracked)
            ...
24	24	---------> test "$untracked" = true
5	49	-------> if set -q __fish_git_prompt_showupstream
            or set -q __fish_git_prompt_show_informative_status
            set p (__fish_git_prompt_show_upstream)
        ...
23	23	--------> set -q __fish_git_prompt_showupstream
21	21	--------> set -q __fish_git_prompt_show_informative_status
33	33	------> set -l branch_color $___fish_git_prompt_color_branch
31	31	------> set -l branch_done $___fish_git_prompt_color_branch_done
3	25	------> if set -q __fish_git_prompt_showcolorhints
        if test $detached = yes
            set branch_color $___fish_git_prompt_color_branch_detached
            set branch_done $___fish_git_prompt_color_branch_detached_done
        end
    ...
22	22	-------> set -q __fish_git_prompt_showcolorhints
4	30	------> if test -n "$w"
        set w "$___fish_git_prompt_color_dirtystate$w$___fish_git_prompt_color_dirtystate_done"
    ...
26	26	-------> test -n "$w"
2	25	------> if test -n "$i"
        set i "$___fish_git_prompt_color_stagedstate$i$___fish_git_prompt_color_stagedstate_done"
    ...
23	23	-------> test -n "$i"
4	26	------> if test -n "$s"
        set s "$___fish_git_prompt_color_stashstate$s$___fish_git_prompt_color_stashstate_done"
    ...
22	22	-------> test -n "$s"
4	26	------> if test -n "$u"
        set u "$___fish_git_prompt_color_untrackedfiles$u$___fish_git_prompt_color_untrackedfiles_done"
    ...
22	22	-------> test -n "$u"
158	223	------> set b (string replace refs/heads/ '' -- $b)
65	65	-------> string replace refs/heads/ '' -- $b
26	26	------> set -q __fish_git_prompt_shorten_branch_char_suffix
29	29	------> set -l __fish_git_prompt_shorten_branch_char_suffix "…"
5	50	------> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"; and test (string length "$b") -gt $__fish_git_prompt_shorten_branch_len
        set b (string sub -l "$__fish_git_prompt_shorten_branch_len" "$b")"$__fish_git_prompt_shorten_branch_char_suffix"
    ...
45	45	-------> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
9	71	------> if test -n "$b"
        set b "$branch_color$b$branch_done"
    ...
28	28	-------> test -n "$b"
34	34	-------> set b "$branch_color$b$branch_done"
4	28	------> if test -n "$c"
        set c "$___fish_git_prompt_color_bare$c$___fish_git_prompt_color_bare_done"
    ...
24	24	-------> test -n "$c"
3	26	------> if test -n "$r"
        set r "$___fish_git_prompt_color_merging$r$___fish_git_prompt_color_merging_done"
    ...
23	23	-------> test -n "$r"
4	26	------> if test -n "$p"
        set p "$___fish_git_prompt_color_upstream$p$___fish_git_prompt_color_upstream_done"
    ...
22	22	-------> test -n "$p"
30	30	------> set -l f "$w$i$s$u"
3	26	------> if test -n "$f"
        set f "$space$f"
    ...
23	23	-------> test -n "$f"
30	30	------> set -l format $argv[1]
4	29	------> if test -z "$format"
        set format " (%s)"
    ...
25	25	-------> test -z "$format"
123	123	------> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
4	35	---> if test -z $branch_name
    return
  ...
31	31	----> test -z $branch_name
158	209	---> echo -s (set_color normal) " on "
51	51	----> set_color normal
192	8731	---> set -l dirty (command git status --porcelain ^/dev/null)
8539	8539	----> command git status --porcelain ^/dev/null
11	90	---> if test -z "$dirty"
    set_color --bold green
  else
    set_color --bold red
  ...
35	35	----> test -z "$dirty"
44	44	----> set_color --bold green
169	216	---> echo -s "$branch_name" (set_color normal)
47	47	----> set_color normal
168	5273	---> set -l unpushed_changes (git cherry -v ^/dev/null)
5105	5105	----> git cherry -v ^/dev/null
12	77	---> if test -z "$unpushed_changes"
    return
  ...
43	43	----> test -z "$unpushed_changes"
22	22	----> return
39	79	--> _node
6	40	---> if test -f ./package.json
    echo -s (set_color --bold green) ' ⬢ ' (node -v) (set_color normal)
  ...
34	34	----> test -f ./package.json
44	240	> fish_title
151	196	-> echo (status current-command)
45	45	--> status current-command
85	328	> __fish_winch_handler SIGWINCH
243	243	-> commandline -f repaint >/dev/null 2>/dev/null
49	339	> fish_mode_prompt
42	290	-> fish_default_mode_prompt
153	248	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
-69	52	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
34	121	----> __fish_winch_handler SIGWINCH
87	87	-----> commandline -f repaint >/dev/null 2>/dev/null
43	43	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
48	42797	> fish_prompt
450	42749	-> echo -nes "\n" (_user_host_name) (_directory) (_git_status) (_node) '\n› '
39	82	--> _user_host_name
6	43	---> if test -n "$SSH_TTY"
    switch "$USER"
      case root toor
        set user_color red
      case '*'
        set user_color yellow
    end
    echo -s (set_color --bold $user_color) $USER (set_color normal) ' at ' (set_color --bold blue) (prompt_hostname) (set_color normal) ' '
  ...
37	37	----> test -n "$SSH_TTY"
55	1588	--> _directory
427	1533	---> echo -s 'in ' (set_color --bold cyan) (prompt_pwd) (set_color normal)
63	63	----> set_color --bold cyan
133	985	----> prompt_pwd
48	48	-----> set -l options 'h/help'
68	68	-----> argparse -n prompt_pwd --max-args=0 $options -- $argv
8	66	-----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
58	58	------> set -q _flag_help
31	31	-----> set -q fish_prompt_pwd_dir_length
34	34	-----> set -l fish_prompt_pwd_dir_length 1
53	53	-----> set realhome ~
273	383	-----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
110	110	------> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
18	169	-----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
45	45	------> [ $fish_prompt_pwd_dir_length -eq 0 ]
106	106	------> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
58	58	----> set_color normal
81	40533	--> _git_status
149	27178	---> set -l branch_name (__fish_git_prompt "%s" | sed 's/ //')
930	27029	----> __fish_git_prompt "%s" | sed 's/ //'
201	26099	-----> fish_git_prompt $argv
8	266	------> if not command -sq git
        return 1
    ...
258	258	-------> not command -sq git
195	4776	------> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
4581	4581	-------> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
35	35	------> test -n "$repo_info"
32	32	------> set -l git_dir $repo_info[1]
30	30	------> set -l inside_gitdir $repo_info[2]
29	29	------> set -l bare_repo $repo_info[3]
28	28	------> set -l inside_worktree $repo_info[4]
24	24	------> set -q repo_info[5]
27	27	------> set -l sha $repo_info[5]
149	5923	------> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
123	5774	-------> __fish_git_prompt_operation_branch_bare $repo_info
31	31	--------> set -l git_dir $argv[1]
29	29	--------> set -l inside_gitdir $argv[2]
28	28	--------> set -l bare_repo $argv[3]
23	23	--------> set -q argv[5]
27	27	--------> set -l sha $argv[5]
24	24	--------> set -l branch
26	26	--------> set -l operation
24	24	--------> set -l detached no
23	23	--------> set -l bare
22	22	--------> set -l step
23	23	--------> set -l total
22	22	--------> set -l os
36	289	--------> if test -d $git_dir/rebase-merge
        set branch (cat $git_dir/rebase-merge/head-name 2>/dev/null)
        set step (cat $git_dir/rebase-merge/msgnum 2>/dev/null)
        set total (cat $git_dir/rebase-merge/end 2>/dev/null)
        if test -f $git_dir/rebase-merge/interactive
            set operation "|REBASE-i"
        else
            set operation "|REBASE-m"
        end
    else
        if test -d $git_dir/rebase-apply
            set step (cat $git_dir/rebase-apply/next 2>/dev/null)
            set total (cat $git_dir/rebase-apply/last 2>/dev/null)
            if test -f $git_dir/rebase-apply/rebasing
                set branch (cat $git_dir/rebase-apply/head-name 2>/dev/null)
                set operation "|REBASE"
            else if test -f $git_dir/rebase-apply/applying
                set operation "|AM"
            else
                set operation "|AM/REBASE"
            end
        else if test -f $git_dir/MERGE_HEAD
            set operation "|MERGING"
        else if test -f $git_dir/CHERRY_PICK_HEAD
            set operation "|CHERRY-PICKING"
        else if test -f $git_dir/REVERT_HEAD
            set operation "|REVERTING"
        else if test -f $git_dir/BISECT_LOG
            set operation "|BISECTING"
        end
    ...
45	45	---------> test -d $git_dir/rebase-merge
17	208	---------> if test -d $git_dir/rebase-apply
            set step (cat $git_dir/rebase-apply/next 2>/dev/null)
            set total (cat $git_dir/rebase-apply/last 2>/dev/null)
            if test -f $git_dir/rebase-apply/rebasing
                set branch (cat $git_dir/rebase-apply/head-name 2>/dev/null)
                set operation "|REBASE"
            else if test -f $git_dir/rebase-apply/applying
                set operation "|AM"
            else
                set operation "|AM/REBASE"
            end
        else if test -f $git_dir/MERGE_HEAD
            set operation "|MERGING"
        else if test -f $git_dir/CHERRY_PICK_HEAD
            set operation "|CHERRY-PICKING"
        else if test -f $git_dir/REVERT_HEAD
            set operation "|REVERTING"
        else if test -f $git_dir/BISECT_LOG
            set operation "|BISECTING"
        ...
37	37	----------> test -d $git_dir/rebase-apply
34	34	----------> test -f $git_dir/MERGE_HEAD
41	41	----------> test -f $git_dir/CHERRY_PICK_HEAD
46	46	----------> test -f $git_dir/REVERT_HEAD
33	33	----------> test -f $git_dir/BISECT_LOG
4	58	--------> if test -n "$step" -a -n "$total"
        set operation "$operation $step/$total"
    ...
54	54	---------> test -n "$step" -a -n "$total"
25	4837	--------> if test -z "$branch"
        set branch (command git symbolic-ref HEAD 2>/dev/null; set os $status)
        if test $os -ne 0
            set detached yes
            set branch (switch "$__fish_git_prompt_describe_style"
						case contains
							command git describe --contains HEAD
						case branch
							command git describe --contains --all HEAD
						case describe
							command git describe HEAD
						case default '*'
							command git describe --tags --exact-match HEAD
						end 2>/dev/null; set os $status)
            if test $os -ne 0
                # Shorten the sha ourselves to 8 characters - this should be good for most repositories,
                # and even for large ones it should be good for most commits
                if set -q sha
                    set branch (string match -r '^.{8}' -- $sha)…
                else
                    set branch unknown
                end
            end
            set branch "($branch)"
        end
    ...
88	88	---------> test -z "$branch"
198	4684	---------> set branch (command git symbolic-ref HEAD 2>/dev/null; set os $status)
4429	4429	----------> command git symbolic-ref HEAD 2>/dev/null
57	57	----------> set os $status
5	40	---------> if test $os -ne 0
            set detached yes
            set branch (switch "$__fish_git_prompt_describe_style"
						case contains
							command git describe --contains HEAD
						case branch
							command git describe --contains --all HEAD
						case describe
							command git describe HEAD
						case default '*'
							command git describe --tags --exact-match HEAD
						end 2>/dev/null; set os $status)
            if test $os -ne 0
                # Shorten the sha ourselves to 8 characters - this should be good for most repositories,
                # and even for large ones it should be good for most commits
                if set -q sha
                    set branch (string match -r '^.{8}' -- $sha)…
                else
                    set branch unknown
                end
            end
            set branch "($branch)"
        ...
35	35	----------> test $os -ne 0
4	38	--------> if test "true" = $inside_gitdir
        if test "true" = $bare_repo
            set bare "BARE:"
        else
            # Let user know they're inside the git dir of a non-bare repo
            set branch "GIT_DIR!"
        end
    ...
34	34	---------> test "true" = $inside_gitdir
35	35	--------> echo $operation
33	33	--------> echo $branch
31	31	--------> echo $detached
28	28	--------> echo $bare
37	37	------> set -l r $rbc[1]
32	32	------> set -l b $rbc[2]
31	31	------> set -l detached $rbc[3]
25	25	------> set -l w
24	24	------> set -l i
23	23	------> set -l s
30	30	------> set -l u
30	30	------> set -l c $rbc[4]
24	24	------> set -l p
27	27	------> set -l informative_status
5	31	------> if not set -q ___fish_git_prompt_init
        # This takes a while, so it only needs to be done once,
        # and then whenever the configuration changes.
        __fish_git_prompt_validate_chars
        __fish_git_prompt_validate_colors
        set -g ___fish_git_prompt_init
    ...
26	26	-------> not set -q ___fish_git_prompt_init
41	41	------> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
160	5049	------> set -l informative (command git config --bool bash.showInformativeStatus)
4889	4889	-------> command git config --bool bash.showInformativeStatus
160	4015	------> set -l dirty (command git config --bool bash.showDirtyState)
3855	3855	-------> command git config --bool bash.showDirtyState
10	63	------> if not set -q dirty[1]
        set -q __fish_git_prompt_showdirtystate
        and set dirty true
    ...
29	29	-------> not set -q dirty[1]
24	24	-------> set -q __fish_git_prompt_showdirtystate
143	4041	------> set -l untracked (command git config --bool bash.showUntrackedFiles)
3898	3898	-------> command git config --bool bash.showUntrackedFiles
11	68	------> if not set -q untracked[1]
        set -q __fish_git_prompt_showuntrackedfiles
        and set untracked true
    ...
31	31	-------> not set -q untracked[1]
26	26	-------> set -q __fish_git_prompt_showuntrackedfiles
8	252	------> if test "true" = $inside_worktree
        # Use informative status if it has been enabled locally, or it has been
        # enabled globally (via the fish variable) and dirty or untracked are not false.
        #
        # This is to allow overrides for the repository.
        if test "$informative" = true
            or begin
                set -q __fish_git_prompt_show_informative_status
                and test "$dirty" != false
                and test "$untracked" != false
            end
            set informative_status "$space"(__fish_git_prompt_informative_status $git_dir)
        else
            # This has to be set explicitly.
            if test "$dirty" = true
                set w (__fish_git_prompt_dirty)
                set i (__fish_git_prompt_staged $sha)
            end

            if set -q __fish_git_prompt_showstashstate
                and test -r $git_dir/refs/stash
                set s $___fish_git_prompt_char_stashstate
            end

            if test "$untracked" = true
                set u (__fish_git_prompt_untracked)
            end
        end

        if set -q __fish_git_prompt_showupstream
            or set -q __fish_git_prompt_show_informative_status
            set p (__fish_git_prompt_show_upstream)
        end
    ...
33	33	-------> test "true" = $inside_worktree
10	158	-------> if test "$informative" = true
            or begin
                set -q __fish_git_prompt_show_informative_status
                and test "$dirty" != false
                and test "$untracked" != false
            end
            set informative_status "$space"(__fish_git_prompt_informative_status $git_dir)
        else
            # This has to be set explicitly.
            if test "$dirty" = true
                set w (__fish_git_prompt_dirty)
                set i (__fish_git_prompt_staged $sha)
            end

            if set -q __fish_git_prompt_showstashstate
                and test -r $git_dir/refs/stash
                set s $___fish_git_prompt_char_stashstate
            end

            if test "$untracked" = true
                set u (__fish_git_prompt_untracked)
            end
        ...
27	27	--------> test "$informative" = true
7	31	--------> begin
                set -q __fish_git_prompt_show_informative_status
                and test "$dirty" != false
                and test "$untracked" != false
            ...
24	24	---------> set -q __fish_git_prompt_show_informative_status
5	32	--------> if test "$dirty" = true
                set w (__fish_git_prompt_dirty)
                set i (__fish_git_prompt_staged $sha)
            ...
27	27	---------> test "$dirty" = true
4	28	--------> if set -q __fish_git_prompt_showstashstate
                and test -r $git_dir/refs/stash
                set s $___fish_git_prompt_char_stashstate
            ...
24	24	---------> set -q __fish_git_prompt_showstashstate
4	30	--------> if test "$untracked" = true
                set u (__fish_git_prompt_untracked)
            ...
26	26	---------> test "$untracked" = true
6	53	-------> if set -q __fish_git_prompt_showupstream
            or set -q __fish_git_prompt_show_informative_status
            set p (__fish_git_prompt_show_upstream)
        ...
24	24	--------> set -q __fish_git_prompt_showupstream
23	23	--------> set -q __fish_git_prompt_show_informative_status
36	36	------> set -l branch_color $___fish_git_prompt_color_branch
32	32	------> set -l branch_done $___fish_git_prompt_color_branch_done
4	27	------> if set -q __fish_git_prompt_showcolorhints
        if test $detached = yes
            set branch_color $___fish_git_prompt_color_branch_detached
            set branch_done $___fish_git_prompt_color_branch_detached_done
        end
    ...
23	23	-------> set -q __fish_git_prompt_showcolorhints
4	30	------> if test -n "$w"
        set w "$___fish_git_prompt_color_dirtystate$w$___fish_git_prompt_color_dirtystate_done"
    ...
26	26	-------> test -n "$w"
4	28	------> if test -n "$i"
        set i "$___fish_git_prompt_color_stagedstate$i$___fish_git_prompt_color_stagedstate_done"
    ...
24	24	-------> test -n "$i"
4	28	------> if test -n "$s"
        set s "$___fish_git_prompt_color_stashstate$s$___fish_git_prompt_color_stashstate_done"
    ...
24	24	-------> test -n "$s"
3	27	------> if test -n "$u"
        set u "$___fish_git_prompt_color_untrackedfiles$u$___fish_git_prompt_color_untrackedfiles_done"
    ...
24	24	-------> test -n "$u"
129	178	------> set b (string replace refs/heads/ '' -- $b)
49	49	-------> string replace refs/heads/ '' -- $b
26	26	------> set -q __fish_git_prompt_shorten_branch_char_suffix
30	30	------> set -l __fish_git_prompt_shorten_branch_char_suffix "…"
6	51	------> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"; and test (string length "$b") -gt $__fish_git_prompt_shorten_branch_len
        set b (string sub -l "$__fish_git_prompt_shorten_branch_len" "$b")"$__fish_git_prompt_shorten_branch_char_suffix"
    ...
45	45	-------> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
10	84	------> if test -n "$b"
        set b "$branch_color$b$branch_done"
    ...
30	30	-------> test -n "$b"
44	44	-------> set b "$branch_color$b$branch_done"
4	28	------> if test -n "$c"
        set c "$___fish_git_prompt_color_bare$c$___fish_git_prompt_color_bare_done"
    ...
24	24	-------> test -n "$c"
4	27	------> if test -n "$r"
        set r "$___fish_git_prompt_color_merging$r$___fish_git_prompt_color_merging_done"
    ...
23	23	-------> test -n "$r"
4	26	------> if test -n "$p"
        set p "$___fish_git_prompt_color_upstream$p$___fish_git_prompt_color_upstream_done"
    ...
22	22	-------> test -n "$p"
31	31	------> set -l f "$w$i$s$u"
4	27	------> if test -n "$f"
        set f "$space$f"
    ...
23	23	-------> test -n "$f"
34	34	------> set -l format $argv[1]
4	29	------> if test -z "$format"
        set format " (%s)"
    ...
25	25	-------> test -z "$format"
106	106	------> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
4	36	---> if test -z $branch_name
    return
  ...
32	32	----> test -z $branch_name
127	167	---> echo -s (set_color normal) " on "
40	40	----> set_color normal
143	7918	---> set -l dirty (command git status --porcelain ^/dev/null)
7775	7775	----> command git status --porcelain ^/dev/null
11	87	---> if test -z "$dirty"
    set_color --bold green
  else
    set_color --bold red
  ...
34	34	----> test -z "$dirty"
42	42	----> set_color --bold green
155	193	---> echo -s "$branch_name" (set_color normal)
38	38	----> set_color normal
167	4783	---> set -l unpushed_changes (git cherry -v ^/dev/null)
4616	4616	----> git cherry -v ^/dev/null
12	90	---> if test -z "$unpushed_changes"
    return
  ...
50	50	----> test -z "$unpushed_changes"
28	28	----> return
45	96	--> _node
7	51	---> if test -f ./package.json
    echo -s (set_color --bold green) ' ⬢ ' (node -v) (set_color normal)
  ...
44	44	----> test -f ./package.json
48	220	> fish_title
130	172	-> echo (status current-command)
42	42	--> status current-command
72	189	> __fish_winch_handler SIGWINCH
117	117	-> commandline -f repaint >/dev/null 2>/dev/null
36	287	> fish_mode_prompt
37	251	-> fish_default_mode_prompt
134	214	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
-61	43	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
32	104	----> __fish_winch_handler SIGWINCH
72	72	-----> commandline -f repaint >/dev/null 2>/dev/null
37	37	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
56	39900	> fish_prompt
528	39844	-> echo -nes "\n" (_user_host_name) (_directory) (_git_status) (_node) '\n› '
33	77	--> _user_host_name
5	44	---> if test -n "$SSH_TTY"
    switch "$USER"
      case root toor
        set user_color red
      case '*'
        set user_color yellow
    end
    echo -s (set_color --bold $user_color) $USER (set_color normal) ' at ' (set_color --bold blue) (prompt_hostname) (set_color normal) ' '
  ...
39	39	----> test -n "$SSH_TTY"
47	1074	--> _directory
327	1027	---> echo -s 'in ' (set_color --bold cyan) (prompt_pwd) (set_color normal)
56	56	----> set_color --bold cyan
71	590	----> prompt_pwd
39	39	-----> set -l options 'h/help'
42	42	-----> argparse -n prompt_pwd --max-args=0 $options -- $argv
6	31	-----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
25	25	------> set -q _flag_help
24	24	-----> set -q fish_prompt_pwd_dir_length
27	27	-----> set -l fish_prompt_pwd_dir_length 1
35	35	-----> set realhome ~
131	211	-----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
80	80	------> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
12	110	-----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
37	37	------> [ $fish_prompt_pwd_dir_length -eq 0 ]
61	61	------> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
54	54	----> set_color normal
69	38073	--> _git_status
152	26184	---> set -l branch_name (__fish_git_prompt "%s" | sed 's/ //')
872	26032	----> __fish_git_prompt "%s" | sed 's/ //'
285	25160	-----> fish_git_prompt $argv
8	233	------> if not command -sq git
        return 1
    ...
225	225	-------> not command -sq git
173	4431	------> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
4258	4258	-------> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
34	34	------> test -n "$repo_info"
40	40	------> set -l git_dir $repo_info[1]
31	31	------> set -l inside_gitdir $repo_info[2]
30	30	------> set -l bare_repo $repo_info[3]
29	29	------> set -l inside_worktree $repo_info[4]
25	25	------> set -q repo_info[5]
28	28	------> set -l sha $repo_info[5]
164	6215	------> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
125	6051	-------> __fish_git_prompt_operation_branch_bare $repo_info
34	34	--------> set -l git_dir $argv[1]
30	30	--------> set -l inside_gitdir $argv[2]
29	29	--------> set -l bare_repo $argv[3]
23	23	--------> set -q argv[5]
27	27	--------> set -l sha $argv[5]
24	24	--------> set -l branch
24	24	--------> set -l operation
24	24	--------> set -l detached no
23	23	--------> set -l bare
22	22	--------> set -l step
42	42	--------> set -l total
41	41	--------> set -l os
47	240	--------> if test -d $git_dir/rebase-merge
        set branch (cat $git_dir/rebase-merge/head-name 2>/dev/null)
        set step (cat $git_dir/rebase-merge/msgnum 2>/dev/null)
        set total (cat $git_dir/rebase-merge/end 2>/dev/null)
        if test -f $git_dir/rebase-merge/interactive
            set operation "|REBASE-i"
        else
            set operation "|REBASE-m"
        end
    else
        if test -d $git_dir/rebase-apply
            set step (cat $git_dir/rebase-apply/next 2>/dev/null)
            set total (cat $git_dir/rebase-apply/last 2>/dev/null)
            if test -f $git_dir/rebase-apply/rebasing
                set branch (cat $git_dir/rebase-apply/head-name 2>/dev/null)
                set operation "|REBASE"
            else if test -f $git_dir/rebase-apply/applying
                set operation "|AM"
            else
                set operation "|AM/REBASE"
            end
        else if test -f $git_dir/MERGE_HEAD
            set operation "|MERGING"
        else if test -f $git_dir/CHERRY_PICK_HEAD
            set operation "|CHERRY-PICKING"
        else if test -f $git_dir/REVERT_HEAD
            set operation "|REVERTING"
        else if test -f $git_dir/BISECT_LOG
            set operation "|BISECTING"
        end
    ...
35	35	---------> test -d $git_dir/rebase-merge
16	158	---------> if test -d $git_dir/rebase-apply
            set step (cat $git_dir/rebase-apply/next 2>/dev/null)
            set total (cat $git_dir/rebase-apply/last 2>/dev/null)
            if test -f $git_dir/rebase-apply/rebasing
                set branch (cat $git_dir/rebase-apply/head-name 2>/dev/null)
                set operation "|REBASE"
            else if test -f $git_dir/rebase-apply/applying
                set operation "|AM"
            else
                set operation "|AM/REBASE"
            end
        else if test -f $git_dir/MERGE_HEAD
            set operation "|MERGING"
        else if test -f $git_dir/CHERRY_PICK_HEAD
            set operation "|CHERRY-PICKING"
        else if test -f $git_dir/REVERT_HEAD
            set operation "|REVERTING"
        else if test -f $git_dir/BISECT_LOG
            set operation "|BISECTING"
        ...
31	31	----------> test -d $git_dir/rebase-apply
28	28	----------> test -f $git_dir/MERGE_HEAD
28	28	----------> test -f $git_dir/CHERRY_PICK_HEAD
27	27	----------> test -f $git_dir/REVERT_HEAD
28	28	----------> test -f $git_dir/BISECT_LOG
5	38	--------> if test -n "$step" -a -n "$total"
        set operation "$operation $step/$total"
    ...
33	33	---------> test -n "$step" -a -n "$total"
21	5143	--------> if test -z "$branch"
        set branch (command git symbolic-ref HEAD 2>/dev/null; set os $status)
        if test $os -ne 0
            set detached yes
            set branch (switch "$__fish_git_prompt_describe_style"
						case contains
							command git describe --contains HEAD
						case branch
							command git describe --contains --all HEAD
						case describe
							command git describe HEAD
						case default '*'
							command git describe --tags --exact-match HEAD
						end 2>/dev/null; set os $status)
            if test $os -ne 0
                # Shorten the sha ourselves to 8 characters - this should be good for most repositories,
                # and even for large ones it should be good for most commits
                if set -q sha
                    set branch (string match -r '^.{8}' -- $sha)…
                else
                    set branch unknown
                end
            end
            set branch "($branch)"
        end
    ...
25	25	---------> test -z "$branch"
159	5060	---------> set branch (command git symbolic-ref HEAD 2>/dev/null; set os $status)
4817	4817	----------> command git symbolic-ref HEAD 2>/dev/null
84	84	----------> set os $status
5	37	---------> if test $os -ne 0
            set detached yes
            set branch (switch "$__fish_git_prompt_describe_style"
						case contains
							command git describe --contains HEAD
						case branch
							command git describe --contains --all HEAD
						case describe
							command git describe HEAD
						case default '*'
							command git describe --tags --exact-match HEAD
						end 2>/dev/null; set os $status)
            if test $os -ne 0
                # Shorten the sha ourselves to 8 characters - this should be good for most repositories,
                # and even for large ones it should be good for most commits
                if set -q sha
                    set branch (string match -r '^.{8}' -- $sha)…
                else
                    set branch unknown
                end
            end
            set branch "($branch)"
        ...
32	32	----------> test $os -ne 0
3	36	--------> if test "true" = $inside_gitdir
        if test "true" = $bare_repo
            set bare "BARE:"
        else
            # Let user know they're inside the git dir of a non-bare repo
            set branch "GIT_DIR!"
        end
    ...
33	33	---------> test "true" = $inside_gitdir
33	33	--------> echo $operation
31	31	--------> echo $branch
29	29	--------> echo $detached
33	33	--------> echo $bare
40	40	------> set -l r $rbc[1]
35	35	------> set -l b $rbc[2]
36	36	------> set -l detached $rbc[3]
27	27	------> set -l w
24	24	------> set -l i
23	23	------> set -l s
24	24	------> set -l u
31	31	------> set -l c $rbc[4]
25	25	------> set -l p
28	28	------> set -l informative_status
6	34	------> if not set -q ___fish_git_prompt_init
        # This takes a while, so it only needs to be done once,
        # and then whenever the configuration changes.
        __fish_git_prompt_validate_chars
        __fish_git_prompt_validate_colors
        set -g ___fish_git_prompt_init
    ...
28	28	-------> not set -q ___fish_git_prompt_init
48	48	------> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
156	4154	------> set -l informative (command git config --bool bash.showInformativeStatus)
3998	3998	-------> command git config --bool bash.showInformativeStatus
136	3841	------> set -l dirty (command git config --bool bash.showDirtyState)
3705	3705	-------> command git config --bool bash.showDirtyState
10	64	------> if not set -q dirty[1]
        set -q __fish_git_prompt_showdirtystate
        and set dirty true
    ...
29	29	-------> not set -q dirty[1]
25	25	-------> set -q __fish_git_prompt_showdirtystate
145	4005	------> set -l untracked (command git config --bool bash.showUntrackedFiles)
3860	3860	-------> command git config --bool bash.showUntrackedFiles
12	76	------> if not set -q untracked[1]
        set -q __fish_git_prompt_showuntrackedfiles
        and set untracked true
    ...
33	33	-------> not set -q untracked[1]
31	31	-------> set -q __fish_git_prompt_showuntrackedfiles
9	259	------> if test "true" = $inside_worktree
        # Use informative status if it has been enabled locally, or it has been
        # enabled globally (via the fish variable) and dirty or untracked are not false.
        #
        # This is to allow overrides for the repository.
        if test "$informative" = true
            or begin
                set -q __fish_git_prompt_show_informative_status
                and test "$dirty" != false
                and test "$untracked" != false
            end
            set informative_status "$space"(__fish_git_prompt_informative_status $git_dir)
        else
            # This has to be set explicitly.
            if test "$dirty" = true
                set w (__fish_git_prompt_dirty)
                set i (__fish_git_prompt_staged $sha)
            end

            if set -q __fish_git_prompt_showstashstate
                and test -r $git_dir/refs/stash
                set s $___fish_git_prompt_char_stashstate
            end

            if test "$untracked" = true
                set u (__fish_git_prompt_untracked)
            end
        end

        if set -q __fish_git_prompt_showupstream
            or set -q __fish_git_prompt_show_informative_status
            set p (__fish_git_prompt_show_upstream)
        end
    ...
34	34	-------> test "true" = $inside_worktree
9	160	-------> if test "$informative" = true
            or begin
                set -q __fish_git_prompt_show_informative_status
                and test "$dirty" != false
                and test "$untracked" != false
            end
            set informative_status "$space"(__fish_git_prompt_informative_status $git_dir)
        else
            # This has to be set explicitly.
            if test "$dirty" = true
                set w (__fish_git_prompt_dirty)
                set i (__fish_git_prompt_staged $sha)
            end

            if set -q __fish_git_prompt_showstashstate
                and test -r $git_dir/refs/stash
                set s $___fish_git_prompt_char_stashstate
            end

            if test "$untracked" = true
                set u (__fish_git_prompt_untracked)
            end
        ...
28	28	--------> test "$informative" = true
7	32	--------> begin
                set -q __fish_git_prompt_show_informative_status
                and test "$dirty" != false
                and test "$untracked" != false
            ...
25	25	---------> set -q __fish_git_prompt_show_informative_status
5	32	--------> if test "$dirty" = true
                set w (__fish_git_prompt_dirty)
                set i (__fish_git_prompt_staged $sha)
            ...
27	27	---------> test "$dirty" = true
4	28	--------> if set -q __fish_git_prompt_showstashstate
                and test -r $git_dir/refs/stash
                set s $___fish_git_prompt_char_stashstate
            ...
24	24	---------> set -q __fish_git_prompt_showstashstate
4	31	--------> if test "$untracked" = true
                set u (__fish_git_prompt_untracked)
            ...
27	27	---------> test "$untracked" = true
6	56	-------> if set -q __fish_git_prompt_showupstream
            or set -q __fish_git_prompt_show_informative_status
            set p (__fish_git_prompt_show_upstream)
        ...
24	24	--------> set -q __fish_git_prompt_showupstream
26	26	--------> set -q __fish_git_prompt_show_informative_status
56	56	------> set -l branch_color $___fish_git_prompt_color_branch
51	51	------> set -l branch_done $___fish_git_prompt_color_branch_done
5	31	------> if set -q __fish_git_prompt_showcolorhints
        if test $detached = yes
            set branch_color $___fish_git_prompt_color_branch_detached
            set branch_done $___fish_git_prompt_color_branch_detached_done
        end
    ...
26	26	-------> set -q __fish_git_prompt_showcolorhints
5	33	------> if test -n "$w"
        set w "$___fish_git_prompt_color_dirtystate$w$___fish_git_prompt_color_dirtystate_done"
    ...
28	28	-------> test -n "$w"
4	29	------> if test -n "$i"
        set i "$___fish_git_prompt_color_stagedstate$i$___fish_git_prompt_color_stagedstate_done"
    ...
25	25	-------> test -n "$i"
4	28	------> if test -n "$s"
        set s "$___fish_git_prompt_color_stashstate$s$___fish_git_prompt_color_stashstate_done"
    ...
24	24	-------> test -n "$s"
4	28	------> if test -n "$u"
        set u "$___fish_git_prompt_color_untrackedfiles$u$___fish_git_prompt_color_untrackedfiles_done"
    ...
24	24	-------> test -n "$u"
136	187	------> set b (string replace refs/heads/ '' -- $b)
51	51	-------> string replace refs/heads/ '' -- $b
29	29	------> set -q __fish_git_prompt_shorten_branch_char_suffix
35	35	------> set -l __fish_git_prompt_shorten_branch_char_suffix "…"
6	54	------> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"; and test (string length "$b") -gt $__fish_git_prompt_shorten_branch_len
        set b (string sub -l "$__fish_git_prompt_shorten_branch_len" "$b")"$__fish_git_prompt_shorten_branch_char_suffix"
    ...
48	48	-------> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
11	78	------> if test -n "$b"
        set b "$branch_color$b$branch_done"
    ...
31	31	-------> test -n "$b"
36	36	-------> set b "$branch_color$b$branch_done"
4	30	------> if test -n "$c"
        set c "$___fish_git_prompt_color_bare$c$___fish_git_prompt_color_bare_done"
    ...
26	26	-------> test -n "$c"
3	28	------> if test -n "$r"
        set r "$___fish_git_prompt_color_merging$r$___fish_git_prompt_color_merging_done"
    ...
25	25	-------> test -n "$r"
4	29	------> if test -n "$p"
        set p "$___fish_git_prompt_color_upstream$p$___fish_git_prompt_color_upstream_done"
    ...
25	25	-------> test -n "$p"
39	39	------> set -l f "$w$i$s$u"
5	32	------> if test -n "$f"
        set f "$space$f"
    ...
27	27	-------> test -n "$f"
36	36	------> set -l format $argv[1]
4	34	------> if test -z "$format"
        set format " (%s)"
    ...
30	30	-------> test -z "$format"
138	138	------> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
6	38	---> if test -z $branch_name
    return
  ...
32	32	----> test -z $branch_name
162	206	---> echo -s (set_color normal) " on "
44	44	----> set_color normal
147	6870	---> set -l dirty (command git status --porcelain ^/dev/null)
6723	6723	----> command git status --porcelain ^/dev/null
11	86	---> if test -z "$dirty"
    set_color --bold green
  else
    set_color --bold red
  ...
33	33	----> test -z "$dirty"
42	42	----> set_color --bold green
134	172	---> echo -s "$branch_name" (set_color normal)
38	38	----> set_color normal
152	4374	---> set -l unpushed_changes (git cherry -v ^/dev/null)
4222	4222	----> git cherry -v ^/dev/null
11	74	---> if test -z "$unpushed_changes"
    return
  ...
38	38	----> test -z "$unpushed_changes"
25	25	----> return
50	92	--> _node
6	42	---> if test -f ./package.json
    echo -s (set_color --bold green) ' ⬢ ' (node -v) (set_color normal)
  ...
36	36	----> test -f ./package.json
51	259	> fish_title
163	208	-> echo (status current-command)
45	45	--> status current-command
61	143	> __fish_disable_bracketed_paste exit
82	82	-> printf "\e[?2004l"
61	335	> fish_title exit
189	274	-> echo (status current-command)
85	85	--> status current-command
144	144	> exit
58	141	> __fish_disable_bracketed_paste 0
83	83	-> printf "\e[?2004l"
